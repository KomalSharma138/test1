package com.consert.core.ejb.session;

import static org.apache.commons.collections.CollectionUtils.isNotEmpty;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.ejb.EJB;
import javax.ejb.Stateless;

import net.sf.ehcache.Element;
import net.sf.ehcache.search.Result;
import net.sf.ehcache.search.Results;

import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;
import org.joda.time.LocalTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.consert.core.ejb.cache.CEAccountMapCacheData;
import com.consert.core.ejb.cache.ControlEventCacheData;
import com.consert.core.ejb.cache.EsiCacheData;
import com.consert.core.ejb.cache.EsiDcCacheData;
import com.consert.core.ejb.cache.EsiTstatCacheData;
import com.consert.core.ejb.cache.GridStreamTstatCacheData;
import com.consert.core.ejb.constant.DefaultResources;
import com.consert.core.ejb.constant.OpsCenterConstants;
import com.consert.core.ejb.exception.AbstractOpsCenterException;
import com.consert.core.ejb.exception.AbstractOpsCenterRuntimeException;
import com.consert.core.ejb.exception.AccountNotFoundException;
import com.consert.core.ejb.exception.AccountNumberNotFoundException;
import com.consert.core.ejb.exception.DataNotAvailableException;
import com.consert.core.ejb.exception.DatabaseUpdateFailed;
import com.consert.core.ejb.exception.DeleteDefaultProgramException;
import com.consert.core.ejb.exception.DeviceOptOutWindowException;
import com.consert.core.ejb.exception.DeviceStatisticsOperationFailedException;
import com.consert.core.ejb.exception.EsiDcNotFoundException;
import com.consert.core.ejb.exception.EsiGatewayNotFoundException;
import com.consert.core.ejb.exception.EsiGatewayNotNormalMode;
import com.consert.core.ejb.exception.EsiNotFoundException;
import com.consert.core.ejb.exception.EsiNotUniqueException;
import com.consert.core.ejb.exception.EsiPowerOutageException;
import com.consert.core.ejb.exception.EsiTstatNotFoundException;
import com.consert.core.ejb.exception.EsiUnderMaintenanceException;
import com.consert.core.ejb.exception.InvalidDeviceProgIDException;
import com.consert.core.ejb.exception.PayloadAddException;
import com.consert.core.ejb.exception.ProgramNameAlreadyExistsException;
import com.consert.core.ejb.exception.ProgramNotCurrentlyScheduledByRangeException;
import com.consert.core.ejb.exception.ProgramNotFoundException;
import com.consert.core.ejb.exception.PublishMessageFailedException;
import com.consert.core.ejb.exception.SchedulesNotFoundException;
import com.consert.core.ejb.exception.TransitionPointDBUpdateFailed;
import com.consert.core.ejb.exception.TransitionPointNotFoundException;
import com.consert.core.ejb.exception.UserNotUniqueException;
import com.consert.core.ejb.multitenant.TenantContext;
import com.consert.core.ejb.multitenant.interfaces.MultiTenantEntityManagerWrapper;
import com.consert.core.ejb.session.demandmanager.SendDemandManagerMessageBean;
import com.consert.core.ejb.session.facade.DemandManagerFacade;
import com.consert.core.ejb.session.facade.interfaces.ControlEventBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.DeviceBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.DeviceReadingBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.EsiBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.GenericFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.MessagingBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.ProgramBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.ProgramTemplateFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.UserAccountBeanFacadeLocal;
import com.consert.core.ejb.session.interfaces.DemandManagerBeanLocal;
import com.consert.core.ejb.session.interfaces.PublisherBeanRemote;
import com.consert.core.ejb.session.interfaces.UserProgramBeanRemote;
import com.consert.core.ejb.session.interfaces.local.ControlEventPowerBeanLocal;
import com.consert.core.ejb.session.interfaces.local.DeviceConfigurationBeanLocal;
import com.consert.core.ejb.session.interfaces.local.GenericBeanLocal;
import com.consert.core.ejb.session.interfaces.local.UserBeanLocal;
import com.consert.core.ejb.session.interfaces.local.UserLoginBeanLocal;
import com.consert.core.ejb.session.interfaces.local.UserProgramBeanLocal;
import com.consert.core.ejb.session.thirdparty.honeywell.tccapi.TccApiRequestsBean;
import com.consert.core.ejb.session.utility.DefaultTemplate;
import com.consert.core.ejb.session.utility.DefaultTemplateCache;
import com.consert.core.ejb.session.utility.DefaultTemplateRepair;
import com.consert.core.ejb.session.utility.DefaultTemplateValidator;
import com.consert.core.ejb.session.utility.GridStreamDcProgramOverrideHandler;
import com.consert.core.ejb.session.utility.GridStreamProgramPushHandler;
import com.consert.core.ejb.session.utility.GridStreamTstatProgramOverrideHandler;
import com.consert.core.ejb.session.utility.Program2ProgramModel;
import com.consert.core.entities.Account;
import com.consert.core.entities.Dc;
import com.consert.core.entities.DcHistory;
import com.consert.core.entities.DcTransitionPoint;
import com.consert.core.entities.DcTransitionPointAttHistory;
import com.consert.core.entities.DeviceStatistics;
import com.consert.core.entities.Esi;
import com.consert.core.entities.EsiDc;
import com.consert.core.entities.EsiTstat;
import com.consert.core.entities.HistoryAction;
import com.consert.core.entities.MessagingAlarm;
import com.consert.core.entities.MessagingAlarmProgramRel;
import com.consert.core.entities.OpMode;
import com.consert.core.entities.Program;
import com.consert.core.entities.ProgramHistory;
import com.consert.core.entities.ProgramScheduleMonthDay;
import com.consert.core.entities.ProgramScheduleMonthDayAttHistory;
import com.consert.core.entities.ProgramScheduleRange;
import com.consert.core.entities.ProgramScheduleRangeAttHistory;
import com.consert.core.entities.ProgramTemplate;
import com.consert.core.entities.Tstat;
import com.consert.core.entities.TstatHistory;
import com.consert.core.entities.TstatTransitionPoint;
import com.consert.core.entities.TstatTransitionPointAttHistory;
import com.consert.core.entities.User;
import com.consert.core.entities.UtilityProperty;
import com.consert.core.messages.DcTransitionPointData;
import com.consert.core.messages.EndpointIdentifier;
import com.consert.core.messages.GSProgramMessage;
import com.consert.core.messages.GSProgramOverrideDcMessage;
import com.consert.core.messages.GSProgramOverrideTstatMessage;
import com.consert.core.messages.ProgramDataMessage;
import com.consert.core.messages.ProgramDayData;
import com.consert.core.messages.ProgramDaySchedule;
import com.consert.core.messages.TemporaryOverrideDataMessage;
import com.consert.core.messages.TstatTransitionPointData;
import com.consert.core.messages.TstatTransitionPointDev;
import com.consert.core.model.DCTransitionPointDev;
import com.consert.core.model.DCTransitionPointModel;
import com.consert.core.model.DcCurrentReadingModel;
import com.consert.core.model.DcTransitionPointDataModel;
import com.consert.core.model.DefaultTemplateModel;
import com.consert.core.model.DeviceStatisticsModel;
import com.consert.core.model.EsiDcModel;
import com.consert.core.model.EsiTstatModel;
import com.consert.core.model.ProgramDayDataModel;
import com.consert.core.model.ProgramDeviceSettingModel;
import com.consert.core.model.ProgramOverrideModel;
import com.consert.core.model.ProgramScheduleMonthDayMap;
import com.consert.core.model.ProgramScheduleRangeModel;
import com.consert.core.model.ProgramStatusModel;
import com.consert.core.model.ProgramValidationModel;
import com.consert.core.model.TransitionPointModel;
import com.consert.core.model.TstatCurrentReadingModel;
import com.consert.core.model.TstatTransitionPointDataModel;
import com.consert.core.model.TstatTransitionPointDevModel;
import com.consert.core.model.TstatTransitionPointModel;
import com.consert.core.model.UserProgramModel;
import com.consert.core.model.UserProgramName;
import com.consert.core.model.UserProgramNameModel;
import com.consert.core.utils.ByteUtilityLocal;
import com.consert.core.utils.Day;
import com.consert.core.utils.PersistenceUtilities;
import com.consert.core.utils.PropertyUtil;
import com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioningLocal;

/**
 * Session Bean implementation class UserProgramBean
 */
@Stateless(name = "UserProgramBean")
public class UserProgramBean implements UserProgramBeanRemote, UserProgramBeanLocal
{
	// JIRA-3488
	private static final int MAXIMUM_REALISTIC_TEMP = 150;
	public static final String PROGRAM_DELETE_MESSAGE = "Program Delete";
	private static final String ESI_DC_PING_REQUEST = OpsCenterConstants.ESI_DC_PING_REQUEST;
	private static final long INVALID_MAC_ADDRESS = 0L;

	@EJB
	ProgramSchedulesBean schBean;

	@EJB
	UserProgramScheduleBean schUserBean;

	@EJB
	UserLoginBeanLocal userLoginBean;

	@EJB
	ProgramBeanFacadeLocal progFacade;

	@EJB
	UserAccountBeanFacadeLocal userAccountFacade;

	@EJB
	DeviceBeanFacadeLocal deviceFacade;

	@EJB
	DeviceReadingBeanFacadeLocal deviceReadingFacade;

	@EJB
	EsiBeanFacadeLocal esiFacade;

	@EJB
	GenericFacadeLocal genericFacade;

	@EJB
	MessagingBeanFacadeLocal messagingFacade;

	@EJB
	ControlEventPowerBeanLocal controlEventPowerBean;

	@EJB
	GenericBeanLocal genericBean;

	@EJB
	private CcPublisherBean ccPublisherBean;

	@EJB
	ControlEventBeanFacadeLocal controlEventFacade;

	@EJB
	public PublisherBeanRemote publisher;

	@EJB
	private CacheManagerBean cacheManager;

	@EJB
	DeviceBeanFacadeLocal deviceBeanFacade;
	
	@EJB
	DeviceConfigurationBeanLocal deviceConfigBean;
	
	@EJB
	private EsiBeanFacadeLocal esiBeanFacade;
	
	@EJB
	private ConsertAccountProvisioningLocal consertAccountProvisioning;
	
	@EJB
	private ProgramTemplateFacadeLocal prgmTemplateFacade;
	
	
	@EJB
	UserBeanLocal userBean;
	
	@EJB
	ConsertAccountProvisioningLocal consertAccProvBean;
	
	@EJB
	private TccApiRequestsBean tccApiRequestsBean;
	

	@EJB
	private MultiTenantEntityManagerWrapper entityManager;
	
	@EJB
	private SendDemandManagerMessageBean sendDmConfigBean;
	
	@EJB
	private UserAccountBeanFacadeLocal userAccountBeanFacadeLocal;
	
	@EJB
	private DemandManagerFacade demandManagerFacade;
	
	@EJB
	private DemandManagerBeanLocal dmConfigBean;

	// private Logger logger = LoggerFactory.getLogger(getClass());
	private Logger logger = LoggerFactory.getLogger(UserProgramBean.class);

	/**
	 * Default constructor.
	 */
	public UserProgramBean()
	{
	}
	public PublisherBeanRemote getPublisher()
	{
		return publisher;
	}

	/**
	 * Adds a new program to the Program entity in the db and publishes the
	 * program for the specific account/esi to the gateway
	 * <p>
	 * 
	 * @param prog
	 *            - Program
	 * @return none
	 * @see
	 */
	
	private class ReadingTimesData {
		
		 
		private DateTime tstatReadingDateTime; 
		private DateTime tstatReadingResponseDateTime;
		private DateTime messageOutgoingDateTime;
		private DateTime messageOutgoingSndLatestDateTime;
		private DateTime messageLastOpsReceivedDateTime ;
		
		public ReadingTimesData () {
			this.tstatReadingDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
			this.tstatReadingResponseDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
			this.messageOutgoingDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
			this.messageOutgoingSndLatestDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
			this.messageLastOpsReceivedDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;		}
		
		public DateTime getTstatReadingDateTime() {
			return tstatReadingDateTime;
		}
		public void setTstatReadingDateTime(DateTime tstatReadingDateTime) {
			this.tstatReadingDateTime = tstatReadingDateTime;
		}
		public DateTime getTstatReadingResponseDateTime() {
			return tstatReadingResponseDateTime;
		}
		public void setTstatReadingResponseDateTime(
				DateTime tstatReadingResponseDateTime) {
			this.tstatReadingResponseDateTime = tstatReadingResponseDateTime;
		}
		public DateTime getMessageOutgoingDateTime() {
			return messageOutgoingDateTime;
		}
		public void setMessageOutgoingDateTime(DateTime messageOutgoingDateTime) {
			this.messageOutgoingDateTime = messageOutgoingDateTime;
		}
		public DateTime getMessageOutgoingSndLatestDateTime() {
			return messageOutgoingSndLatestDateTime;
		}
		public void setMessageOutgoingSndLatestDateTime(
				DateTime messageOutgoingSndLatestDateTime) {
			this.messageOutgoingSndLatestDateTime = messageOutgoingSndLatestDateTime;
		}
		public DateTime getMessageLastOpsReceivedDateTime() {
			return messageLastOpsReceivedDateTime;
		}
		public void setMessageLastOpsReceivedDateTime(
				DateTime messageLastOpsReceivedDateTime) {
			this.messageLastOpsReceivedDateTime = messageLastOpsReceivedDateTime;
		}
	}
	public void addProgram(Program program) throws AbstractOpsCenterRuntimeException
	{
		logger.info("[ENTER] void UserProgramBean.addProgram(programId = " + program.getProgramId() + ")");

		logger.debug("<< Adding Program >>");

		try
		{
			progFacade.updateProgram(program);
		}
		catch (Exception e)
		{
			e.printStackTrace();
			logger.info("[ EXIT] UserProgramBean.addProgram");
			throw new AbstractOpsCenterRuntimeException(e);
		}

		logger.info("[ EXIT] UserProgramBean.addProgram");
	}

	/**
	 * Gets all the programs for a specified account id
	 * 
	 * If there is a Day cross over in the date range that is provided, then the
	 * device settings that returned might belong to different programs.
	 * 
	 * @param acc
	 *            an AccountId
	 * @return List <Programs>
	 * @see
	 * */

	
	public UserProgramNameModel getAllPrograms(String accountNumber)
			throws AbstractOpsCenterException
	{

		logger.info("Entering getAllPrograms");
		List<UserProgramName> progNameList = new ArrayList<UserProgramName>();

		List<Account> acc = userAccountFacade.getAccountByAccountNumber(accountNumber);
		if (acc == null || acc.size() == 0)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Error:  No valid account found in DB for account number  "
						+ accountNumber);
			}
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No account found for account # " + accountNumber);

		}
		if (acc.size() > 1)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Error:  More than 1 account found in DB for acc # :  "
						+ accountNumber);
			}
			return null;
		}
		Account account = acc.get(0);
		int accId = account.getAccountId();
		logger.debug("acc id = " + accId);

		List<Program> programList = progFacade.getProgramByAccountId(accId);
		if (programList == null || programList.size() == 0)
		{
			logger.debug("No programs found for Account ID =  " + accId);
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
					"No programs found for Account #  " + accountNumber);
		}
		UserProgramNameModel programs = new UserProgramNameModel();
		UserProgramName prgName = null;
		for (Program prog : programList)
		{

			prgName = new UserProgramName();
			programs.setAccountId(prog.getAccountId().getAccountId());
			prgName.setProgramId(prog.getProgramId());
			prgName.setProgramName(prog.getName());
			prgName.setSchedByRangeFlag(prog.getSchedByRangeFlag().equals(OpsCenterConstants.TRUE));
			progNameList.add(prgName);
		}

		programs.setUserProgramNameCollection(progNameList);

		logger.info("Exiting getAllPrograms");

		return programs;
	}

	@Override
	public boolean isProgramTemplateUsed(int accountId, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering isProgramTemplateUsed");
		boolean isProgramTemplateUsed = false;
		Account account = userAccountFacade.findAccountByAccountId(accountId);
		if (account == null)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Error:  No valid account found in DB for account Id  " + accountId);
			}
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No account found for account Id " + accountId);

		}

		logger.debug("acc id = " + accountId);

		List<Program> programList = progFacade.getProgramByAccountId(accountId);
		if (programList == null || programList.size() == 0)
		{
			logger.debug("No programs found for Account ID =  " + accountId);
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
					"No programs found for Account #  " + account.getAccountNumber());
		}
		
		if(account!=null && account.getProgramTemplateId() != null && !(account.getProgramTemplateId().getProgramTemplateId()<1))
			isProgramTemplateUsed = true;	
		
			

		logger.info("Exiting isProgramTemplateUsed");

		return isProgramTemplateUsed;
	}
	
	@Override
	public UserProgramNameModel getAllPrograms(int accountId, Integer tenantId)
			throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering getAllPrograms");
		List<UserProgramName> progNameList = new ArrayList<UserProgramName>();

		Account account = userAccountFacade.findAccountByAccountId(accountId);
		if (account == null)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Error:  No valid account found in DB for account Id  " + accountId);
			}
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No account found for account Id " + accountId);

		}

		logger.debug("acc id = " + accountId);

		List<Program> programList = progFacade.getProgramByAccountId(accountId);
		if (programList == null || programList.size() == 0)
		{
			logger.debug("No programs found for Account ID =  " + accountId);
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
					"No programs found for Account #  " + account.getAccountNumber());
		}
		UserProgramNameModel programs = new UserProgramNameModel();
		UserProgramName prgName = null;
		for (Program prog : programList)
		{

			prgName = new UserProgramName();
			programs.setAccountId(prog.getAccountId().getAccountId());
			prgName.setProgramId(prog.getProgramId());
			prgName.setProgramName(prog.getName());
			prgName.setSchedByRangeFlag(prog.getSchedByRangeFlag().equals(OpsCenterConstants.TRUE));
			progNameList.add(prgName);
		}

		programs.setUserProgramNameCollection(progNameList);

		logger.info("Exiting getAllPrograms");

		return programs;
	}

	// KRMT-2676 - Program Push Schedular Optimizations
	private void getActiveDevicesMod(int accountId, ProgramDataMessage msg)
	{

		int numOfDc = 0, numOfTstat = 0;

		Results dcResults = cacheManager.getCacheDataByAccId(cacheManager.getGwDCCache(),
				accountId);
		numOfDc = dcResults.size();

		Results tstatResults = cacheManager.getCacheDataByAccId(
				cacheManager.getGwTstatCache(), accountId);
		numOfTstat = tstatResults.size();
		dcResults.discard();
		tstatResults.discard();

		msg.setNumberOfTstatDevices(numOfTstat);
		msg.setNumberOfDCDevices(numOfDc);
	}

	/**
	 * Builds a message containing all of the program/schedules/transition points settings
	 * for the account specified for the number of days specified (usually 14)
	 * 
	 * If there is a Day cross over in the date range that is provided, then 
	 * the device settings that returned might belong to different programs.
	 * @param  accId the location of the image, relative to the url argument
	 * @param  checkForMaint : 
	 * @return none
	 * @see
	 * @throws EsiPowerOutageException 
	 * @throws EsiUnderMaintenanceException
	 * @throws AbstractOpsCenterException
	 * */

	@Override
	public void publishMessageForSingleAccount(int accId, boolean checkForMaint, Integer tenantId)
			throws AbstractOpsCenterException, EsiPowerOutageException,
			EsiUnderMaintenanceException
	{
		TenantContext.setCurrentTenant(tenantId);
		publishMessageForSingleAccount(accId, checkForMaint);
	}
	
	@Override
	public void publishMessageForSingleAccount(int accId, boolean checkForMaint)
			throws AbstractOpsCenterException, EsiPowerOutageException,
			EsiUnderMaintenanceException
	{
		logger.info("Entering publishMessageForSingleAccount: accountId=" + +accId);

		Esi esi = null;

		try
		{
			List<Esi> esiList = esiFacade.getEsiByActiveFlagAccountId(accId,
					OpsCenterConstants.TRUE);
			esi = esiList.get(0);
		}
		catch (Exception ex)
		{
			logger.error("No ESI configured for AccountId=" + accId);
			throw new EsiNotFoundException("AccountId=" + accId);
		}

		// check if ESI GW is in outage or maintenance mode
		if (OpsCenterConstants.POWER_OUTAGE_FLAG.equals(esi.getEsiGatewayId().getOutageFlag()))
		{
			throw new EsiPowerOutageException();
		}
		if (checkForMaint)
		{
			if (OpsCenterConstants.ESI_MODE_MAINTENANCE == esi.getManageModeId().getManageModeId())
			{
				throw new EsiUnderMaintenanceException();
			}
		}

		int esiId = esi.getEsiId();
		int esiMqId = esi.getEsiMqId();

		DateTimeZone datetimeZone = esi.getAccountId().getTimezoneId().getDateTimeZone();

		if (isAccInCriticalCe(accId))
			//hmbrd-440 do not opt opt if critical CE -- last param=false
			publishMessageForSingleAccountMod(accId, esi.getHardwareType(), esiMqId, esiId,datetimeZone,false,checkForMaint);
		else

		   //dev-2005 must pass in opt-out = true since UI prog push must opt-out
		   publishMessageForSingleAccountMod(accId, esi.getHardwareType(), esiMqId, esiId,datetimeZone,true,checkForMaint);
		

	}
	
 



	// KRMT-2676 - Program Push Schedular Optimizations
	
	public void publishMessageForSingleAccountMod(int accId, String hardwareType,
			int esiMqId, int esiId, DateTimeZone datetimeZone, boolean optOut, boolean checkForMaint)
			throws AbstractOpsCenterException
	{
		if (optOut)
			controlEventPowerBean.optOutEsiFromCE(accId,OpsCenterConstants.OptOutReason.GUI);
		publishMessageForSingleAccountMod(accId, hardwareType, esiMqId, esiId, datetimeZone, 0, false,checkForMaint);

	}

	@Override
	public void publishMessageForSingleAccountAuto(int accId, String hardwareType,
			int esiMqId, int esiId, DateTimeZone datetimeZone)
			throws AbstractOpsCenterException
	{

		publishMessageForSingleAccountMod(accId, hardwareType, esiMqId, esiId, datetimeZone, 0, true, true);

	}
	
	@Override
	public void pushProgramsToMacAddress(long macAddress, boolean autoPush)
			throws AbstractOpsCenterException
	{
		
		int esiId;
		int accountId;
		int esiMqId;
		DateTimeZone datetimeZone;
		List<EsiDc> esiDcList = esiBeanFacade
				.getEsiDcByDevMacId(macAddress);
		if (null != esiDcList && !esiDcList.isEmpty())
		{

			for (EsiDc esiDc : esiDcList)
			{
				if (!esiDc.isDeleted())
				{
					esiId = esiDc.getEsiId().getEsiId();
					accountId = esiDc.getEsiId().getAccountId().getAccountId();
					esiMqId = esiDc.getEsiId().getEsiMqId();
					datetimeZone = esiDc.getEsiId().getAccountId().getTimezoneId().getDateTimeZone();
					publishMessageForSingleAccountMod(accountId, OpsCenterConstants.GRIDSTREAM_RF_DELIVERY, esiMqId, esiId, datetimeZone, 0, true, true);
					break;
				}

			}

		}
		else
		{
			EsiTstat esiTstat = esiBeanFacade.getEsiTstatByDeviceMacId(macAddress);

			if (null != esiTstat && !esiTstat.isDeleted())
			{				
				EsiDc esiDc = esiTstat.getEsiDcId();
				esiId = esiDc.getEsiId().getEsiId();
				accountId = esiDc.getEsiId().getAccountId().getAccountId();
				esiMqId = esiDc.getEsiId().getEsiMqId();
				datetimeZone = esiDc.getEsiId().getAccountId().getTimezoneId().getDateTimeZone();
				publishMessageForSingleAccountMod(accountId, OpsCenterConstants.GRIDSTREAM_RF_DELIVERY, esiMqId, esiId, datetimeZone, 0, true, true);
								
			}

		}
		

	}

	
	public void publishMessageForSingleAccountMod(int accId, String hardwareType,
			int esiMqId, int esiId, DateTimeZone datetimeZone,
			long deviceMacId, boolean autoPush, boolean checkForMaint) throws AbstractOpsCenterException
	{
		if (logger.isInfoEnabled())
		{
			logger.info("Entering publishMessageForSingleAccountMod: accountId=" + +accId);
		}
		List<ProgramDayData> messageDataList = null;
		Esi esi = esiFacade.findEsiByEsiId(esiId);
		// check if ESI GW is in outage or maintenance mode
		//power outage is not supported for GS acc
		if (OpsCenterConstants.POWER_OUTAGE_FLAG.equals(esi.getEsiGatewayId().getOutageFlag()) &&
			!hardwareType.equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
			{
				throw new EsiPowerOutageException();
			}
		//Code fix for KRMT-6732 To activate account in maintenance mode 
		if (checkForMaint)
		{
			logger.info(" Check if the account is in maintenance : accountId=" + +accId + " : Mode= "+ esi.getManageModeId().getManageModeId());
			if (OpsCenterConstants.MANAGE_MODE_MAINTENANCE == esi.getManageModeId().getManageModeId())
			{
				logger.info("Account is in maintenance");
				throw new EsiUnderMaintenanceException();
			}
		}

		try
		{

			// KRMT-2715--must start the 14 day progs current time - 1 day to
			// allow
			// for gaps in transition points for first day after push
			LocalDate accountLocalDate = new LocalDate(datetimeZone).minusDays(1);
			if (logger.isDebugEnabled())
			{
				logger.debug("Account DateTimeZone=" + datetimeZone + ", accountLocalDate="
						+ accountLocalDate);
			}

			long localWallTime = toUserWallTime(accountLocalDate, datetimeZone);

			 	// rdrn-660 --now determine if we have prog template, if so update the DB and push
				//template data if template was changed
			if (autoPush) {
				//this means is the scheduler is calling  and power up health status
				Account account = findAccountEntityByAccountID(accId);
				if (account.getProgramTemplateId() != null && hardwareType.equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY ))  {
				
					ProgramTemplate progTmplt  = prgmTemplateFacade.getActiveProgramTemplateById(account.getProgramTemplateId().getProgramTemplateId());
					if (progTmplt != null) {
						//found a valid template, delete all non- default programs, reapply template programs(should only be 1 value returned)
						//but first determine if template has changed
						DateTime tmplDateModified =progTmplt.getDateModified();
			    		logger.debug("dateModified =  " + tmplDateModified);
	
						DateTime currTime = new DateTime();
	 				    if (tmplDateModified != null && tmplDateModified.getMillis() >= currTime.minusDays(7).getMillis()) {
					    	//the template has changed for this mac since last push
					    	//go ahead and wipe out prog and recopy from template
					    	List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account.getAccountId());
					    	if (esiList.size() <=0 ) 
					    		logger.error("No ESI found for accountId = " + account.getAccountId());
					    	else{
					    		//reset the autoPush flag here to allow prog to be
					    		//applied at device and not interfere with temp ovrr
					    		autoPush = false;
					    		//this method first deletes all prog/tp, then assigns new ones
	 					    	consertAccProvBean.assignProgramTemplateProgramsIfNecessary(account, OpsCenterConstants.PROVISIONING_USER, currTime);
						    	userBean.checkDevicesAndAssignProgramTemplateTPData(esiList.get(0));
					    		logger.debug("Just copied new prog/tp for esiId " + esiList.get(0).getEsiId());
	
					    	}
					    }
					}
			  }
			}
				
			// this is for GW so pass true to offset
			messageDataList = getProgramsScheduleForAccount(accId, true);

			if (messageDataList == null || messageDataList.isEmpty())
			{
				throw new ProgramNotFoundException(
						DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
						"No programs found for Account # " + accId);
			}

			// Program Id is null since we are not sending a specific program
			Set<Integer> programs = new HashSet<Integer>();
			for (ProgramDayData programDayData : messageDataList)
			{
				programs.add(new Long(programDayData.getPrgrmId()).intValue());
			}

			// For GridStream send a program push for each device
			if (hardwareType.equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
			{
				// Get the gridstream messages for each mac
				GridStreamProgramPushHandler gsProgramPushHandler = new GridStreamProgramPushHandler();
				Map<Long, GSProgramMessage> programDataMessages = gsProgramPushHandler
						.getProgramPush(messageDataList, localWallTime);

				// Push an individual message for each mac
				for (Long devMac : programDataMessages.keySet())
				{
					
					if (devMac == null
							|| deviceMacId != 0 && deviceMacId != devMac.longValue())
					{
						continue;
					}
					if (cacheManager.getGsTstatCache().isKeyInCache(devMac))
					{
						Element gsTstatElement = cacheManager.getGsTstatCache().get(devMac);
						GridStreamTstatCacheData gsTstatCache = null;
						gsTstatCache = (GridStreamTstatCacheData) gsTstatElement.getObjectValue();
						if(gsTstatCache.getEsiDcTypeName().equalsIgnoreCase(OpsCenterConstants.THIRD_PARTY_TSTAT))
						{
							logger.info("Skip Pushing an individual message for third party mac:"+devMac.longValue());
							continue;
						}
					
					}
					else
					{
						logger.debug("Not found in cache checking device mac in db");
						EsiTstat esitstat1=esiBeanFacade.getEsiTstatByDeviceMacId(devMac.longValue());
						if(esitstat1!=null)
						{
							EsiDc esiDc=esitstat1.getEsiDcId();
								if(OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT== esiDc.getDeviceTypeId().getDeviceTypeId())
									{
										logger.info("Skip Pushing an individual message for third party mac:"+devMac.longValue());
										continue;
										
									}
						}
					}

					GSProgramMessage programDataMessage = programDataMessages.get(devMac);
					//DEV-2325  - autoPush means the prog push scheduler is pushing, so set flag if so in message

                    programDataMessage.setAutoPush(autoPush ? (byte)01 : (byte)00);

					logger.debug("autoPush  = "+ programDataMessage.getAutoPush());
/*					// KGRF-17 (Put back when Firmware chages done)
					//Reset Indefinate Hold only first time device provisioned
					// Workflow succeed at least one time
					boolean isDevProvFirstTime = isDeviceFirstTimeProvisioned(devMac); 
					logger.debug("isDevProvFirstTimeProvisioned :" + isDevProvFirstTime );
					programDataMessage.setResetIndefiniteHold(isDevProvFirstTime ? (byte)01 : (byte)00);
*/
					// For GridStream we have to set program push time at a
					// device level
					String gsTstatCacheKey = Long.toString(devMac);
					if (cacheManager.getGsTstatCache().isKeyInCache(gsTstatCacheKey))
					{
						Element gsTstatElement = cacheManager.getGsTstatCache().get(
								gsTstatCacheKey);
						GridStreamTstatCacheData gsTstatCache = null;
						gsTstatCache = (GridStreamTstatCacheData) gsTstatElement.getObjectValue();
						gsTstatCache.setPgrmRequestTime(new DateTime().getMillis());
						logger.debug("publishMessageForSingleAccountMod for GS Mac ID = "+ gsTstatCacheKey);
						logger.debug("setPgrmRequestTime = "+ gsTstatCache.getPgrmRequestTime());
						
						cacheManager.getGsTstatCache().put(gsTstatElement);
					}
					else
					{
						EsiDcCacheData gsDcCache = null;
						// now search for lcs in cache
						//dev-2110, we must not allow ac_switch devices to get a program, but they can co-exists
						//on same LCS with other non-acswitch, so check here ( R4.0)
						String cacheKey = buildLcsCacheKey(devMac, OpsCenterConstants.LCS_RELAY_1);
						if (cacheManager.getGwDCCache().isKeyInCache(cacheKey))
						{
							Element gsdcElement = cacheManager.getGwDCCache().get(cacheKey);
							gsDcCache = (EsiDcCacheData) gsdcElement
									.getObjectValue();
							if (!OpsCenterConstants.DC_HVAC_SWITCH.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_SINGLE_HEAT.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_DUAL_HEAT.equals(gsDcCache.getDeviceType())) {
							   gsDcCache.setPgrmRequestTime(new DateTime().getMillis());
							   logger.debug("setPgrmRequestTime = "+ gsDcCache.getPgrmRequestTime() + " for cache key " + cacheKey);
							   cacheManager.getGwDCCache().put(gsdcElement);
							}

						}

						cacheKey = buildLcsCacheKey(devMac, OpsCenterConstants.LCS_RELAY_2);
						if (cacheManager.getGwDCCache().isKeyInCache(cacheKey))
						{
							Element gsdcElement = cacheManager.getGwDCCache().get(cacheKey);
							gsDcCache = (EsiDcCacheData) gsdcElement
									.getObjectValue();
							if (!OpsCenterConstants.DC_HVAC_SWITCH.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_SINGLE_HEAT.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_DUAL_HEAT.equals(gsDcCache.getDeviceType())){
							   gsDcCache.setPgrmRequestTime(new DateTime().getMillis());
							   logger.debug("setPgrmRequestTime = "+ gsDcCache.getPgrmRequestTime()+ " for cache key " + cacheKey);
							   cacheManager.getGwDCCache().put(gsdcElement);
							}

						}
						
						cacheKey = buildLcsCacheKey(devMac, OpsCenterConstants.LCS_RELAY_3);
						if (cacheManager.getGwDCCache().isKeyInCache(cacheKey))
						{
							Element gsdcElement = cacheManager.getGwDCCache().get(cacheKey);
							gsDcCache = (EsiDcCacheData) gsdcElement
									.getObjectValue();
							if (!OpsCenterConstants.DC_HVAC_SWITCH.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_SINGLE_HEAT.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_DUAL_HEAT.equals(gsDcCache.getDeviceType())){
							   gsDcCache.setPgrmRequestTime(new DateTime().getMillis());
							   logger.debug("setPgrmRequestTime = "+ gsDcCache.getPgrmRequestTime()+ " for cache key " + cacheKey);
							   cacheManager.getGwDCCache().put(gsdcElement);
							}

						}
						
						cacheKey = buildLcsCacheKey(devMac, OpsCenterConstants.LCS_RELAY_4);
						if (cacheManager.getGwDCCache().isKeyInCache(cacheKey))
						{
							Element gsdcElement = cacheManager.getGwDCCache().get(cacheKey);
							gsDcCache = (EsiDcCacheData) gsdcElement
									.getObjectValue();
							if (!OpsCenterConstants.DC_HVAC_SWITCH.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_SINGLE_HEAT.equals(gsDcCache.getDeviceType())
									&& !OpsCenterConstants.DC_DUAL_HEAT.equals(gsDcCache.getDeviceType())){
							   gsDcCache.setPgrmRequestTime(new DateTime().getMillis());
							   logger.debug("setPgrmRequestTime = "+ gsDcCache.getPgrmRequestTime()+ " for cache key " + cacheKey);
							   cacheManager.getGwDCCache().put(gsdcElement);
							}

						}

				    }

					// End point for GS is MAC address
					EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
					endpointIdentifier.setMacId(devMac);

					programDataMessage.dump();

					setProgPushAlarm(programs, esiId, new Long(devMac), null,
							OpsCenterConstants.OPCODE_DEVICE_PROGRAM_PUSH);

					publishProgramPush(endpointIdentifier, esiMqId, programDataMessage.getPayload(), esiId);

					genericBean.createMessageResponse(
							programDataMessage.getMessageIdInUtcSecs(),
							programDataMessage.getDeviceMacAddress(), esiId,
							programDataMessage.getOpCode(), new DateTime(), null);
				}
			}

		}
		catch (AbstractOpsCenterException e)
		{
			throw e;
		}
		catch (Exception e)
		{
			logger.error("generateAndPublishMessage() - >>> failed for AccountId=" + accId, e);
			e.printStackTrace();
			throw new PublishMessageFailedException(e);
		}
	}
	
	// KGRF-17 (Put back when Firmware chages done)
	/*private boolean isDeviceFirstTimeProvisioned(Long devMacId){
		boolean flag =  false;
		int count = genericFacade.getWorkflowCountByDeviceMacId(devMacId);
		logger.debug("Count of Worklfows: "+ count + " for Device Mac Id: "+ devMacId);
		if (count==0){
			flag = true;
		}
		return flag;
	}*/

	/**
	 * @param endpointIdentifier
	 * @param esiMqId
	 * @throws PayloadAddException 
	 */
	private void publishProgramPush(EndpointIdentifier endpointIdentifier, int esiMqId,
			byte[] payload, int esiId) throws PayloadAddException
	{

		// now build the msg and send to the GW
		publisher.publish(endpointIdentifier, payload);

		logger.debug("Program data sent for Device >>> " + endpointIdentifier.toString());

		// Set the prg request time in the cache
		String gwCacheKey = endpointIdentifier.toString();

	}
	
	@Override
	public ArrayList<ProgramDayDataModel> getProgramScheduleModelForAccount(int accId,
			boolean offsetForGW, Integer tenantId) throws AbstractOpsCenterException, EsiPowerOutageException,
			EsiUnderMaintenanceException
	{		
		TenantContext.setCurrentTenant(tenantId);
		ArrayList<ProgramDayDataModel> accountProgramModels = new ArrayList<ProgramDayDataModel>();
		ArrayList<ProgramDayData> accountPrograms = getProgramsScheduleForAccount(accId, offsetForGW);
		
		for(ProgramDayData accountProgram : accountPrograms)
		{
			ProgramDayDataModel accountProgramModel = mapProgramDayDataToModel(accountProgram);
			accountProgramModels.add(accountProgramModel);
		}
		
		return accountProgramModels;
	}
	
	private ProgramDayDataModel mapProgramDayDataToModel(ProgramDayData accountProgram)
	{
		ProgramDayDataModel programModel = new ProgramDayDataModel();
		
		if (null != accountProgram)
		{
			programModel.setEndDate(accountProgram.getEndDate());
			programModel.setNumOfDays(accountProgram.getNumOfDays());
			programModel.setPrgrmId(accountProgram.getPrgrmId());
			programModel.setStartDate(accountProgram.getStartDate());
			programModel.setStartTime(accountProgram.getStartTime());
			
			Set<DcTransitionPointData> dcTPs = accountProgram.getDcTransPoint();
			programModel.setDcTransPoint(new TreeSet<DcTransitionPointDataModel>());
			for (DcTransitionPointData dcTP : dcTPs)
			{
				DcTransitionPointDataModel dcModel = new DcTransitionPointDataModel();
				dcModel.setDcId(dcTP.getDcId());
				dcModel.setDeviceId(dcTP.getDeviceId());
				if (null != dcTP.getProgramId())
				{
					dcModel.setProgramId(dcTP.getProgramId().getProgramId());
				}
				dcModel.setDcTransPointDev(dcTP.getDcTransPointDev());
				programModel.getDcTransPoint().add(dcModel);
			}
			
			TreeSet<TstatTransitionPointData> tstatTPs = accountProgram.getTsatTransPoint();
			programModel.setTsatTransPoint(new TreeSet<TstatTransitionPointDataModel>());
			for (TstatTransitionPointData tstatTP : tstatTPs)
			{
				TstatTransitionPointDataModel tstatModel = new TstatTransitionPointDataModel();
				tstatModel.setDeviceId(tstatTP.getDeviceId());
				if (null != tstatTP.getProgramId())
				{
					tstatModel.setProgramId(tstatTP.getProgramId().getProgramId());
				}
				tstatModel.setTstatId(tstatTP.getTstatId());
				TreeSet<TstatTransitionPointDevModel> tstatTransPointDev = new TreeSet<TstatTransitionPointDevModel>();
				for (TstatTransitionPointDev source : tstatTP.getTstatTransPointDev())
				{
					TstatTransitionPointDevModel tpDevModel = new TstatTransitionPointDevModel();
					tpDevModel.setActiveFlag(source.getActiveFlag());
					tpDevModel.setMaxTemp(source.getMaxTemp());
					tpDevModel.setMinTemp(source.getMinTemp());
					tpDevModel.setPrefCoolTemp(source.getPrefCoolTemp());
					tpDevModel.setPrefHeatTemp(source.getPrefHeatTemp());
					tpDevModel.setTstatMode(source.getTstatMode());
					tpDevModel.setTpStartTime(source.getTpStartTime());
					tpDevModel.setTemporaryFlag(source.getTemporaryFlag());
					tpDevModel.setHoldStatus(source.getHoldStatus());
					
					tstatTransPointDev.add(tpDevModel);
				}
				tstatModel.setTstatTransPointDev(tstatTransPointDev);
				programModel.getTsatTransPoint().add(tstatModel);
			}
			
			
		}
		
		return programModel;
	}

	/**
	 * KRMT-1468
	 * Builds a list containing all of the program/schedules/transition
	 * points settings for the account specified for the number of days
	 * specified (usually 14)
	 * 
	 * If there is a Day cross over in the date range that is provided, then the
	 * device settings that returned might belong to different programs.
	 * 
	 * @param accId
	 * @return none
	 * @see
	 * @throws EsiPowerOutageException
	 * @throws EsiUnderMaintenanceException
	 * @throws AbstractOpsCenterException
	 * */

	
	public ArrayList<ProgramDayData> getProgramsScheduleForAccount(int accId,
			boolean offsetForGW) throws AbstractOpsCenterException, EsiPowerOutageException,
			EsiUnderMaintenanceException
	{
		logger.info("Entering getProgramsSchedule: accountId=" + +accId);

		ArrayList<ProgramDayData> messageDataList = null;
		Account account = null;

		try
		{
			account = findAccountEntityByAccountID(accId);
		}
		catch (Exception ex)
		{
			logger.error("No account found in DB for AccountId=" + accId + ". Exception: " + ex);
			throw new AccountNotFoundException(accId);
		}

		boolean foundInCache = true;
		List<Esi> esiList = null;
		int esiId = -1;
		Results esiResults = cacheManager.getCacheDataByAccId(cacheManager.getGwEsiCache(),
				accId);

		if (esiResults == null || esiResults.size() == 0)
		{
			foundInCache = false;
			if (logger.isDebugEnabled())
			{
				logger.debug("No ESIs found in cache for AccountId=" + accId);
			}
			esiList = esiFacade.getEsiByActiveFlagAccountId(accId, OpsCenterConstants.TRUE);
			if (esiList == null || esiList.isEmpty())
			{
				if (logger.isErrorEnabled())
				{
					logger.error("No ESIs found in DB for AccountId=" + accId);
				}
				throw new EsiNotFoundException("ESI not found for AccountId=" + accId);
			}
		}

		if (foundInCache && esiResults != null)
		{
			esiId = ((EsiCacheData) esiResults.all().get(0).getValue()).getEsiId();
			logger.debug("getProgramsScheduleForAccount(): getting esiResults from cache; id = "
					+ esiId);
			
			esiList = esiFacade.getEsiByActiveFlagAccountId(accId, OpsCenterConstants.TRUE);
			if (esiList == null || esiList.isEmpty())
			{
				if (logger.isErrorEnabled())
				{
					logger.error("No ESIs found in DB for AccountId=" + accId);
				}
				throw new EsiNotFoundException("ESI not found for AccountId=" + accId);
			}
			
			if (esiList != null && esiList.size() > 0)
			{
				Esi esi= esiList.get(0);
				int esiDbId = esi.getEsiId();
				logger.debug("getProgramsScheduleForAccount(): getting esiResults from DB; id = " + esiDbId + " and AccountId = " + accId);

				if (esiDbId == esiId)
				{
					logger.debug("Esi Cache is in sync with DB, esi id = "+ esiDbId + " and AccountId = " + accId);
				}
				else
				{
					logger.debug("Esi Cache is out of sync with DB, esi id in Cache= "+ esiId + " and AccountId = " + accId);
					esiId=esiDbId;
					cacheManager.updateGsEsiCache(esi);				
				}
			}
		}
		else
		{
			if (esiList == null)
			{
				logger.error("esiList returned null in getProgramScheduleForAccount()");
				return null;
			}
			Esi esi = esiList.get(0);
			esiId = esi.getEsiId();
			logger.debug("getProgramsScheduleForAccount(): getting esiResults from DB and updating cache; id = "
					+ esiId + " and AccountId = " + accId);
			cacheManager.updateGsEsiCache(esi);
		}

		try
		{

			// JIRA KRMT-1285
			DateTimeZone datetimeZone = account.getTimezoneId().getDateTimeZone();
			LocalDate accountLocalDate = new LocalDate(datetimeZone);
			logger.debug("Account DateTimeZone=" + datetimeZone + ", accountLocalDate="
					+ accountLocalDate);

			messageDataList = processProgramData(account, esiId, datetimeZone, offsetForGW);

		}
		catch (AbstractOpsCenterException e)
		{
			throw e;
		}

		return messageDataList;
	}

	/**
	 * Retrieves active and next program names and id and populates an object
	 * to return for the client
	 * @param  accountNumber- String
	 * @return none
	 * @see   
	 * */
	
	public UserProgramNameModel getProgramsForDashBoard(int accountId)
			throws AbstractOpsCenterException
	{
		logger.info("Entering getProgramsForDashBoard");

		UserProgramNameModel userProgramNameModel = new UserProgramNameModel();
		List<UserProgramName> progNameList = new ArrayList<UserProgramName>();
		List<ProgramDayData> messageDataList = null;

		// confirm Account is good
		// KRMT-6401 don't need to do this check
		// Account acc = userAccountFacade.findAccountByAccountId(accountId);
		// if (acc == null ) {
		// if (logger.isErrorEnabled())
		// logger
		// .error("Error:  No valid account found in DB for account ID  "
		// + accountId);
		// throw new AccountNumberNotFoundException(
		// DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
		// "No account found for account ID " + accountId);
		// }
		// krmt6212-- no need to check size, at this point we will have specific
		// account
		// no need to get first account when CAK is enabled there could be same
		// acc # for home
		/*		if (acc.size() > 1) {
					if (logger.isErrorEnabled())
						logger
								.error("Error:  More than 1 account found in DB for acc # :  "
										+ accountNumber);
					throw new AccountNumberNotFoundException(
							DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
							"More than one account found for account # "
									+ accountNumber);
				}
				Account account = (Account) acc.get(0);*/
		int accId = accountId;
		userProgramNameModel.setAccountId(accId);

		// get the list of programdaydata's
		messageDataList = getProgramsScheduleForAccount(accId, false); // this
																		// is
																		// for
																		// UI,
																		// so
																		// pass
																		// false
																		// for
																		// gwoffset

		// populate currently active program
		UserProgramName activeProgramName = new UserProgramName();
		ProgramDayData activeProgramDayData = messageDataList.get(0);
		Program activeProgram = progFacade.findProgramByProgramId((int) activeProgramDayData
				.getPrgrmId());

		activeProgramName.setProgramId(activeProgram.getProgramId());
		activeProgramName.setProgramName(activeProgram.getName());
		activeProgramName.setStartTime(activeProgramDayData.getStartDate());
		activeProgramName.setEndTime(activeProgramDayData.getEndDate());
		activeProgramName.setSchedByRangeFlag(activeProgram.getSchedByRangeFlag().equals(
				OpsCenterConstants.TRUE));
		activeProgramName.setActiveFlag(true);
		progNameList.add(activeProgramName);

		if (messageDataList.size() > 1)
		{
			// populate next active program
			UserProgramName nextProgramName = new UserProgramName();
			ProgramDayData nextProgramDayData = messageDataList.get(1);
			Program nextProgram = progFacade.findProgramByProgramId((int) nextProgramDayData
					.getPrgrmId());

			nextProgramName.setProgramId(nextProgram.getProgramId());
			nextProgramName.setProgramName(nextProgram.getName());
			nextProgramName.setStartTime(nextProgramDayData.getStartDate());
			nextProgramName.setEndTime(nextProgramDayData.getEndDate());
			nextProgramName.setSchedByRangeFlag(nextProgram.getSchedByRangeFlag().equals(
					OpsCenterConstants.TRUE));
			nextProgramName.setActiveFlag(true);
			progNameList.add(nextProgramName);
		}

		userProgramNameModel.setUserProgramNameCollection(progNameList);
		logger.info("Exiting getProgramsForDashBoard");

		return userProgramNameModel;
	}

	/**
	 * <p>
	 * Creates a new program based on the account and user info provided in the
	 * user program model reference. Once this operation is performed it will
	 * publish this information into the gateway.
	 * </p>
	 * 
	 * <p>
	 * Time slots are now called Transition Points.
	 * </p>
	 * 
	 * <p>
	 * A new instance of program will be created, populated with default data.
	 * Then transitions points (provided in the user program model) will be
	 * processed and added one by one to each table (DC and TSTAT).
	 * </p>
	 * 
	 * @param userPgmModel
	 * @return Program
	 * @throws ProgramNameAlreadyExistsException
	 * @throws Exception
	 */

	@Override
	public UserProgramModel createProgram(UserProgramModel userPgmModel, Integer tenantId)
			throws ProgramNameAlreadyExistsException, Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("createProgram() - starting");

		// Validate this is not a duplicate program name
		int l = userPgmModel.getName().length();
		if (l > OpsCenterConstants.PROGRAM_NAME_SIZE)
		{
			l = OpsCenterConstants.PROGRAM_NAME_SIZE;
		}
		String programName = userPgmModel.getName().substring(0, l);
		int accountId = userPgmModel.getAccountId();
		List<Program> programs = progFacade.getProgramByNameAndAccountId(programName,
				accountId);

		if (programs != null && programs.size() > 0)
		{
			for (Program program : programs)
			{
				if (program.getName().equals(programName)
						&& program.getProgramId() != userPgmModel.getProgramId())
				{
					logger.error("Program name already exists");
					throw new ProgramNameAlreadyExistsException(
							DefaultResources.PRG_ERR_CODE_PROGRAM_NAME_ALREADY_EXISTS,
							"Program name already exists with name " + programName);
				}
			}
		}

		// Create new program based on Model info
		Program program = progFacade.getNewProgram();
		program.setAccountId(userAccountFacade.findAccountByAccountId(accountId));
		program.setActiveFlag(OpsCenterConstants.TRUE);
		DateTime now = new DateTime();
		program.setDateCreated(now);
		program.setDateModified(now);

		// KRMT-382: Allow creation of programs to activate default
		if (userPgmModel.getDefaultFlag() != null)
		{
			program.setDefaultFlag(userPgmModel.getDefaultFlag());
		}
		else
		{
			program.setDefaultFlag(OpsCenterConstants.FALSE);
			// TODO: Should this ever be set as the default? If so, what do we
			// do with the old one?
		}

		String userCreated = userPgmModel.getUserCreated();
		String userModified = userPgmModel.getUserModified();

		program.setDeleteFlag(OpsCenterConstants.TRUE);
		program.setName(OpsCenterConstants.TMP_PGM_NAME);
		program.setSchedByRangeFlag(userPgmModel.getSchedByRangeFlag());
		program.setUserCreated(userCreated);
		program.setUserModified(userModified);
		progFacade.createProgram(program);
		// add prog history entry in DB - KRMT-2999
		ProgramHistory progHist = new ProgramHistory();
		try
		{
			progHist.setActionUserId(userAccountFacade.findUserByUsername(userModified));
		}
		catch (UserNotUniqueException e)
		{
			progHist.setActionUserId(null);
		}
		List<HistoryAction> histActionList = genericFacade
				.getHistoryActionByActionName("Created");
		if (histActionList == null || histActionList.size() <= 0)
		{
			logger.error("No History Action found for Created in DB, hist record not created for program");
		}
		else
		{
			progHist.setActionDate(now);
			progHist.setProgramId(program);
			progHist.setActionShortComments("Program Create");
			progHist.setHistoryActionId(histActionList.get(0));
			progFacade.createProgramHistory(progHist);
		}

		logger.info("New program instance created " + program.getProgramId());

		// Process DC transition points (create, populate and save) based on
		// Model info

		if (userPgmModel.getDcTransitionPointCollection() != null
				&& userPgmModel.getDcTransitionPointCollection().size() != 0)
		{
			List<DCTransitionPointModel> dcTransitionPoints = userPgmModel
					.getDcTransitionPointCollection();
			Iterator<DCTransitionPointModel> iterDCTransPoints = dcTransitionPoints
					.iterator();
			while (iterDCTransPoints.hasNext())
			{
				DCTransitionPointModel dcTransModel = iterDCTransPoints.next();
				DcTransitionPoint dcTransPoint = new DcTransitionPoint();
				dcTransPoint.setActiveFlag(OpsCenterConstants.TRUE);
				int id = dcTransModel.getEsiDcId();
				dcTransPoint.setEsiDcId(esiFacade.findEsiDcByEsiDcId(id));
				dcTransPoint.setDeleteFlag(OpsCenterConstants.FALSE);
				dcTransPoint.setPowerStatusFlag(dcTransModel.getPowerStatusFlag());
				dcTransPoint.setProgramId(program);
				dcTransPoint.setTemporaryFlag(OpsCenterConstants.FALSE);
				dcTransPoint.setTpTime(dcTransModel.getTpTime());
				dcTransPoint.setDateCreated(now);
				dcTransPoint.setUserCreated(userCreated);
				dcTransPoint.setDateModified(now);
				dcTransPoint.setUserModified(userModified);
				progFacade.createDcTransitionPoint(dcTransPoint);
				DcTransitionPointAttHistory dcTPHist = new DcTransitionPointAttHistory();
				dcTPHist.setActionDate(now);
				dcTPHist.setPowerStatusFlagBefore(dcTransPoint.getPowerStatusFlag());
				dcTPHist.setPowerStatusFlagAfter(dcTransModel.getPowerStatusFlag());
				dcTPHist.setTemporaryFlag(OpsCenterConstants.FALSE);
				dcTPHist.setTpTimeBefore(dcTransPoint.getTpTime());
				dcTPHist.setTpTimeAfter(dcTransModel.getTpTime());
				dcTPHist.setDcTransitionPointId(dcTransPoint);
				progFacade.createDcTransitionPointAttHistory(dcTPHist);

				logger.trace("DC transition point added: " + dcTransPoint.getDcTransitionPointId());
			}

		}

		// Process TSAT transition points (create, populate and save) based on
		// Model info
		if (userPgmModel.getTstatTransitionPointCollection() != null
				&& userPgmModel.getTstatTransitionPointCollection().size() != 0)
		{
			List<TstatTransitionPointModel> tsatTransitionPoints = userPgmModel
					.getTstatTransitionPointCollection();
			Iterator<TstatTransitionPointModel> iterTSATTransPoints = tsatTransitionPoints
					.iterator();
			while (iterTSATTransPoints.hasNext())
			{
				TstatTransitionPointModel tstatTransModel = iterTSATTransPoints.next();
				TstatTransitionPoint tstatTransPoint = new TstatTransitionPoint();
				tstatTransPoint.setActiveFlag(OpsCenterConstants.TRUE);
				tstatTransPoint.setDeleteFlag(OpsCenterConstants.FALSE);
				tstatTransPoint.setMaxTemp(tstatTransModel.getMaxTemp());
				tstatTransPoint.setMinTemp(tstatTransModel.getMinTemp());
				tstatTransPoint.setOpModeId(progFacade.findOpModeByOpModeId(tstatTransModel
						.getOpModeId()));
				tstatTransPoint.setPrefCoolTemp(tstatTransModel.getPrefCoolTemp());
				tstatTransPoint.setPrefHeatTemp(tstatTransModel.getPrefHeatTemp());
				tstatTransPoint.setProgramId(program);
				tstatTransPoint.setTemporaryFlag(OpsCenterConstants.FALSE);
				tstatTransPoint.setTpTime(tstatTransModel.getTpTime());
				tstatTransPoint.setEsiTstatId(esiFacade.findEsiTstatByEsiTstatId(tstatTransModel
						.getEsiTstatId()));
				tstatTransPoint.setDateCreated(now);
				tstatTransPoint.setUserCreated(userCreated);
				tstatTransPoint.setDateModified(now);
				tstatTransPoint.setUserModified(userModified);
				tstatTransPoint.setHoldStatus(OpsCenterConstants.FALSE);
				progFacade.createTstatTransitionPoint(tstatTransPoint);
				logger.trace("TSTAT transition point added: "
						+ tstatTransPoint.getTstatTransitionPointId());

				TstatTransitionPointAttHistory tsTPHist = new TstatTransitionPointAttHistory();

				// fill in ts transistion point history info
				try
				{
					tsTPHist.setActionUserId(userAccountFacade.findUserByUsername(userModified));
				}
				catch (UserNotUniqueException e)
				{
					tsTPHist.setActionUserId(null);
				}

				tsTPHist.setActionDate(now);
				tsTPHist.setMaxTempBefore(tstatTransPoint.getMaxTemp());
				tsTPHist.setMaxTempAfter(tstatTransModel.getMaxTemp());
				tsTPHist.setMinTempBefore(tstatTransPoint.getMinTemp());
				tsTPHist.setMinTempAfter(tstatTransModel.getMinTemp());
				tsTPHist.setPrefCoolTempBefore(tstatTransPoint.getPrefCoolTemp());
				tsTPHist.setPrefCoolTempAfter(tstatTransModel.getPrefCoolTemp());
				tsTPHist.setPrefHeatTempBefore(tstatTransPoint.getPrefHeatTemp());
				tsTPHist.setPrefHeatTempAfter(tstatTransModel.getPrefHeatTemp());
				tsTPHist.setTemporaryFlag(OpsCenterConstants.FALSE);
				tsTPHist.setTpTimeBefore(tstatTransPoint.getTpTime());
				tsTPHist.setTpTimeAfter(tstatTransModel.getTpTime());
				tsTPHist.setOpModeBefore(tstatTransPoint.getOpModeId());
				tsTPHist.setOpModeAfter(progFacade.findOpModeByOpModeId(tstatTransModel
						.getOpModeId()));
				tsTPHist.setTstatTransitionPointId(tstatTransPoint);
				tsTPHist.setHoldStatus(OpsCenterConstants.FALSE);
				progFacade.createTstatTransitionPointAttHistory(tsTPHist);

			}
		}
		// Process schedules by range or month day
		if (OpsCenterConstants.TRUE.equals(userPgmModel.getSchedByRangeFlag()))
		{
			List<ProgramScheduleRangeModel> pgmScheduleRanges = userPgmModel
					.getProgramScheduleRangeCollection();
			Iterator<ProgramScheduleRangeModel> iterProgramScheduleRange = pgmScheduleRanges
					.iterator();
			List<ProgramScheduleRange> newScheduleRanges = new ArrayList<ProgramScheduleRange>();
			while (iterProgramScheduleRange.hasNext())
			{
				ProgramScheduleRangeModel pgmScheduleRangeModel = iterProgramScheduleRange
						.next();
				ProgramScheduleRange pgmScheduleRange = new ProgramScheduleRange();
				pgmScheduleRange.setActiveFlag(OpsCenterConstants.TRUE);
				pgmScheduleRange.setDeleteFlag(OpsCenterConstants.FALSE);
				pgmScheduleRange.setEndDate(pgmScheduleRangeModel.getEndDate());
				pgmScheduleRange.setProgramId(program);
				pgmScheduleRange.setStartDate(pgmScheduleRangeModel.getStartDate());
				pgmScheduleRange.setDateCreated(now);
				pgmScheduleRange.setUserCreated(userCreated);
				pgmScheduleRange.setDateModified(now);
				pgmScheduleRange.setUserModified(userModified);
				progFacade.createProgramScheduleRange(pgmScheduleRange);
				logger.trace("Schedule Range added: "
						+ pgmScheduleRange.getProgramScheduleRangeId());
				ProgramScheduleRangeAttHistory progSchedAttHist = null;

				progSchedAttHist = new ProgramScheduleRangeAttHistory();
				progSchedAttHist.setProgramScheduleRangeId(pgmScheduleRange);
				progSchedAttHist.setActionDate(now);
				progSchedAttHist.setEndDateAfter(pgmScheduleRange.getEndDate());
				progSchedAttHist.setEndDateBefore(pgmScheduleRange.getEndDate());
				progSchedAttHist.setStartDateAfter(pgmScheduleRange.getStartDate());
				progSchedAttHist.setStartDateBefore(pgmScheduleRange.getStartDate());
				// fill in ts transistion point history info
				try
				{
					progSchedAttHist.setActionUserId(userAccountFacade
							.findUserByUsername(userModified));
				}
				catch (UserNotUniqueException e)
				{
					progSchedAttHist.setActionUserId(null);
				}

				progFacade.createProgramScheduleRangeAttHistory(progSchedAttHist);
				logger.debug("Created Sch Rng Hist entry in DB for hist ID ="
						+ pgmScheduleRange.getProgramScheduleRangeId());

				// Save program schedule range
				newScheduleRanges.add(pgmScheduleRange);
			}
			// Verify overlapping programs and process it correctly
			schUserBean.saveProgramSchedulesRange(program, newScheduleRanges);

		}
		else
		{

			// process handling of monthday schedule

			LinkedHashMap<String, String> pgmScheduleMonth = userPgmModel
					.getProgramScheduleMonthMap();
			LinkedHashMap<String, String> pgmScheduleDays = userPgmModel
					.getProgramScheduleDayMap();

			if (pgmScheduleMonth != null && pgmScheduleMonth.size() != 0
					&& pgmScheduleDays != null && pgmScheduleDays.size() != 0)
			{
				processMonthDaySchedule(pgmScheduleMonth, pgmScheduleDays, program, userPgmModel);
			}
		}

		// got this far, everything is good so set fields to good values
		program.setDeleteFlag(OpsCenterConstants.FALSE);
		program.setName(programName); // Set real program name
		progFacade.updateProgram(program);

		logger.info("new program " + program.getName());
		logger.info("createProgram() - ending");

		UserProgramModel programModel = Program2ProgramModel.transformProgramEntityToModel(
				program, progFacade);

		return programModel;
	}

	/**
	 * Processes monthday schedules as requested by client. Extracts setting
	 * from the month map and day map, creates an instance of the
	 * ProgramScheduleMonthDay entity and stores passed in data in the database
	 * 
	 * @param LinkedHashMap
	 *            <String, String> monthSch - the month hash map to be stored in
	 *            db
	 * @param LinkedHashMap
	 *            <String, String> daySch - the day hash map to be stored in db
	 */
	private void processMonthDaySchedule(LinkedHashMap<String, String> monthSch,
			LinkedHashMap<String, String> daySch, Program program,
			UserProgramModel model)
	{

		logger.info("entering processMonthDaySchedule");

		// create an instance of the entity
		ProgramScheduleMonthDay pgmScheduleMonthDay = new ProgramScheduleMonthDay();

		pgmScheduleMonthDay.setActiveFlag(OpsCenterConstants.TRUE);
		pgmScheduleMonthDay.setDeleteFlag(OpsCenterConstants.FALSE);
		pgmScheduleMonthDay.setProgramId(program);

		LinkedHashMap<String, String> dayMap = new LinkedHashMap<String, String>();
		LinkedHashMap<String, String> monthMap = new LinkedHashMap<String, String>();

		// we must use the monthMap and dayMap and create complete map with all
		// entries set to "0"
		// the client only passes in values which are set, but we must pass in
		// the entire map to the DB
		// so its important that all fields are initialized using the static map
		// to "0".
		monthMap = ProgramScheduleMonthDayMap.getProgSchMonthDefaultMap();
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_JAN))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JAN,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_JAN));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_FEB))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_FEB,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_FEB));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_MAR))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_MAR,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_MAR));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_APR))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_APR,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_APR));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_MAY))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_MAY,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_MAY));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_JUN))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JUN,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_JUN));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_JUL))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JUL,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_JUL));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_AUG))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_AUG,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_AUG));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_SEP))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_SEP,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_SEP));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_OCT))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_OCT,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_OCT));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_NOV))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_NOV,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_NOV));
		}
		if (monthSch.containsKey(ProgramScheduleMonthDayMap.MONTH_DEC))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_DEC,
					monthSch.get(ProgramScheduleMonthDayMap.MONTH_DEC));
		}

		pgmScheduleMonthDay.setMonthMapping(monthMap);

		dayMap = ProgramScheduleMonthDayMap.getProgSchDayDefaultMap();
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_MON))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_MON,
					daySch.get(ProgramScheduleMonthDayMap.DAY_MON));
		}
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_TUE))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_TUE,
					daySch.get(ProgramScheduleMonthDayMap.DAY_TUE));
		}
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_WED))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_WED,
					daySch.get(ProgramScheduleMonthDayMap.DAY_WED));
		}
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_THU))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_THU,
					daySch.get(ProgramScheduleMonthDayMap.DAY_THU));
		}
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_FRI))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_FRI,
					daySch.get(ProgramScheduleMonthDayMap.DAY_FRI));
		}
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_SAT))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_SAT,
					daySch.get(ProgramScheduleMonthDayMap.DAY_SAT));
		}
		if (daySch.containsKey(ProgramScheduleMonthDayMap.DAY_SUN))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_SUN,
					daySch.get(ProgramScheduleMonthDayMap.DAY_SUN));
		}

		pgmScheduleMonthDay.setDayMapping(dayMap);
		String userModified = model.getUserModified();
		DateTime now = new DateTime();
		try
		{
			List<ProgramScheduleMonthDay> oldPgmScheduleMonthDayList = progFacade
					.getProgramScheduleMonthDayByProgramId(program.getProgramId());
			if (oldPgmScheduleMonthDayList == null || oldPgmScheduleMonthDayList.size() == 0)
			{
				logger.debug("No ProgramScheduleMonthDay found for Program ID =  "
						+ program.getProgramId());
			}
			else
			{

				ProgramScheduleMonthDayAttHistory psmdatHist = null;
				for (ProgramScheduleMonthDay psmd : oldPgmScheduleMonthDayList)
				{

					// TODO: create atthistory entry
					psmdatHist = new ProgramScheduleMonthDayAttHistory();
					try
					{
						psmdatHist.setActionUserId(userAccountFacade
								.findUserByUsername(userModified));
					}
					catch (UserNotUniqueException e)
					{
						psmdatHist.setActionUserId(null);
					}
					psmdatHist.setActionDate(now);
					psmdatHist.setProgramScheduleMonthDayId(psmd);
					psmdatHist = setOldMonthDaySchedule(pgmScheduleMonthDay.getMonthMapping(),
							pgmScheduleMonthDay.getDayMapping(), psmdatHist, psmd);
					progFacade.updateProgramScheduleMonthDayAttHistory(psmdatHist);

					// logical delete
					psmd.setDeleteFlag(OpsCenterConstants.TRUE);
					psmd.setDateModified(now);
					psmd.setUserModified(userModified);
					progFacade.updateProgramScheduleMonthDay(psmd);
				}
			}
			pgmScheduleMonthDay.setDateCreated(now);
			pgmScheduleMonthDay.setUserCreated(userModified);
			pgmScheduleMonthDay.setDateModified(now);
			pgmScheduleMonthDay.setUserModified(userModified);
			progFacade.createProgramScheduleMonthDay(pgmScheduleMonthDay);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		logger.trace("Schedule Month Day added: "
				+ pgmScheduleMonthDay.getProgramScheduleMonthDayId());

	}

	/**
	 * @param newScheduleMonth
	 * @param newScheduledaySch
	 * @param newMonthDayHist
	 * @param oldPrg
	 * @return
	 */
	private ProgramScheduleMonthDayAttHistory setOldMonthDaySchedule(
			LinkedHashMap<String, String> newScheduleMonth,
			LinkedHashMap<String, String> newScheduledaySch,
			ProgramScheduleMonthDayAttHistory newMonthDayHist,
			ProgramScheduleMonthDay oldPrg)
	{
		LinkedHashMap<String, String> monthMap = new LinkedHashMap<String, String>();
		LinkedHashMap<String, String> dayMap = new LinkedHashMap<String, String>();
		LinkedHashMap<String, String> monthMapBefore = oldPrg.getMonthMapping();
		LinkedHashMap<String, String> dayMapBefore = oldPrg.getDayMapping();

		// first build the before info
		monthMap = ProgramScheduleMonthDayMap.getProgSchMonthDefaultMap();
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_JAN))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JAN,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_JAN));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_FEB))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_FEB,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_FEB));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_MAR))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_MAR,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_MAR));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_APR))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_APR,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_APR));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_MAY))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_MAY,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_MAY));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_JUN))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JUN,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_JUN));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_JUL))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JUL,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_JUL));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_AUG))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_AUG,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_AUG));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_SEP))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_SEP,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_SEP));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_OCT))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_OCT,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_OCT));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_NOV))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_NOV,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_NOV));
		}
		if (monthMapBefore.containsKey(ProgramScheduleMonthDayMap.MONTH_DEC))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_DEC,
					monthMapBefore.get(ProgramScheduleMonthDayMap.MONTH_DEC));
		}

		newMonthDayHist.setMonthMappingBefore(monthMap);

		dayMap = ProgramScheduleMonthDayMap.getProgSchDayDefaultMap();
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_MON))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_MON,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_MON));
		}
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_TUE))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_TUE,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_TUE));
		}
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_WED))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_WED,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_WED));
		}
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_THU))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_THU,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_THU));
		}
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_FRI))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_FRI,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_FRI));
		}
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_SAT))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_SAT,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_SAT));
		}
		if (dayMapBefore.containsKey(ProgramScheduleMonthDayMap.DAY_SUN))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_SUN,
					dayMapBefore.get(ProgramScheduleMonthDayMap.DAY_SUN));
		}

		newMonthDayHist.setDayMappingBefore(dayMap);

		// now populate After info
		monthMap = ProgramScheduleMonthDayMap.getProgSchMonthDefaultMap();
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_JAN))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JAN,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_JAN));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_FEB))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_FEB,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_FEB));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_MAR))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_MAR,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_MAR));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_APR))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_APR,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_APR));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_MAY))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_MAY,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_MAY));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_JUN))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JUN,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_JUN));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_JUL))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_JUL,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_JUL));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_AUG))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_AUG,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_AUG));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_SEP))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_SEP,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_SEP));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_OCT))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_OCT,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_OCT));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_NOV))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_NOV,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_NOV));
		}
		if (newScheduleMonth.containsKey(ProgramScheduleMonthDayMap.MONTH_DEC))
		{
			monthMap.put(ProgramScheduleMonthDayMap.MONTH_DEC,
					newScheduleMonth.get(ProgramScheduleMonthDayMap.MONTH_DEC));
		}

		newMonthDayHist.setMonthMappingAfter(monthMap);

		dayMap = ProgramScheduleMonthDayMap.getProgSchDayDefaultMap();
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_MON))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_MON,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_MON));
		}
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_TUE))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_TUE,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_TUE));
		}
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_WED))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_WED,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_WED));
		}
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_THU))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_THU,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_THU));
		}
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_FRI))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_FRI,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_FRI));
		}
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_SAT))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_SAT,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_SAT));
		}
		if (newScheduledaySch.containsKey(ProgramScheduleMonthDayMap.DAY_SUN))
		{
			dayMap.put(ProgramScheduleMonthDayMap.DAY_SUN,
					newScheduledaySch.get(ProgramScheduleMonthDayMap.DAY_SUN));
		}

		newMonthDayHist.setDayMappingAfter(dayMap);

		return newMonthDayHist;
	}

	/**
	 * Retrieves the next active program for account number indicated and
	 * returns it in an Object user program Modelate reference.
	 * 
	 * @param account
	 * @param userPgmModel
	 * @throws AccountNumberNotFoundException
	 * @throws ProgramNameAlreadyExistsException
	 * @throws Exception
	 */

	/**
	 * Renames existing program based on the account and user info provided in
	 * the user program Model reference.
	 * 
	 * @param account
	 * @param userPgmModel
	 * @throws ProgramNameAlreadyExistsException
	 * @throws Exception
	 */
	
	public void renameProgram(UserProgramModel userPgmModel)
			throws ProgramNameAlreadyExistsException, ProgramNotFoundException, Exception
	{

		logger.info("renameProgram() - starting");

		if (userPgmModel == null)
		{
			throw new Exception("UserProgramModel is null");
		}

		logger.debug("accountId: " + userPgmModel.getAccountId());
		logger.debug("programId: " + userPgmModel.getProgramId());
		logger.debug("new program name: " + userPgmModel.getName());

		Program programToRename = progFacade.findProgramByProgramId(userPgmModel
				.getProgramId());
		if (programToRename == null)
		{
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"No programs found for ID =  " + userPgmModel.getProgramId());
		}

		validateProgramName(userPgmModel, programToRename);

		programToRename.setName(userPgmModel.getName());
		programToRename.setDateModified(new DateTime());
		programToRename.setUserModified(userPgmModel.getUserModified());
		progFacade.updateProgram(programToRename);
		logger.info("new program name " + programToRename.getName());
		logger.info("renameProgram() - ending");
	}

	/**
	 * @param userPgmModel
	 * @param programToRename
	 * @return
	 */
	private void validateProgramName(UserProgramModel userPgmModel,
			Program programToRename) throws ProgramNameAlreadyExistsException,
			ProgramNotFoundException
	{
		List<Program> programs = null;

		if (userPgmModel.getName() == null || userPgmModel.getName().length() == 0)
		{
			logger.error("Null or empty program name passed for program name");
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NAME_EMPTY,
					"Null or empty program name passed for program name");
		}

		programs = progFacade.getProgramByNameAndAccountId(userPgmModel.getName(),
				userPgmModel.getAccountId());

		/* Search for duplicate program name */
		if (programs != null && programs.size() > 0)
		{
			for (Program program : programs)
			{
				if (program.getName().equals(userPgmModel.getName())
						&& program.getProgramId() != userPgmModel.getProgramId())
				{
					logger.error("Program name already exists: " + userPgmModel.getName());
					throw new ProgramNameAlreadyExistsException(
							DefaultResources.PRG_ERR_CODE_PROGRAM_NAME_ALREADY_EXISTS,
							"Program name already exists with name " + userPgmModel.getName());
				}
			}
		}
	}

	/**
	 * Deletes a program based on the account and user info provided in the user
	 * program Modelate reference. Deleted program will be replaced with default
	 * program and it will be published to the gateway, if the program timeslot
	 * matches current time it will be pushed to the gateway.
	 * 
	 * @param account
	 * @param userPgmModel
	 *            (containing accoutnid, programid, usermodified)
	 * @throws Exception
	 */
	@SuppressWarnings("unused")
	@Override
	public void deleteProgram(UserProgramModel userPgmModel, Integer tenantId) throws ProgramNotFoundException,
			Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("deleteProgram() - starting");
		Program defaultProgram = null;
		Program programToDelete = null;
		List<Program> defaultPrograms = null;

		if (userPgmModel == null)
		{
			throw new Exception("UserProgramModel is null");
		}
		defaultPrograms = progFacade.getProgramByAccountId(userPgmModel.getAccountId());
		if (defaultPrograms == null || defaultPrograms.isEmpty())
		{
			throw new Exception("No default program available");
		}
		for (Program program : defaultPrograms)
		{
			if (OpsCenterConstants.TRUE.equals(program.getDefaultFlag()))
			{
				defaultProgram = program;
				break;
			}
		}
		if (defaultProgram == null)
		{
			throw new Exception("No default program available");
		}
		programToDelete = progFacade.findProgramByProgramId(userPgmModel.getProgramId());
		if (programToDelete == null)
		{
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"No programs found for ID =  " + userPgmModel.getProgramId());
		}

		if (programToDelete.getProgramId() == defaultProgram.getProgramId())
		{
			throw new DeleteDefaultProgramException(
					DefaultResources.PRG_ERR_CODE_DELETE_DEFAULT_PROGRAM,
					"Can't delete default program for ID =  " + userPgmModel.getProgramId());

		}
		logger.info("programIdToBeDeleted: " + programToDelete.getProgramId());
		logger.info("defaultProgramId: " + defaultProgram.getProgramId());
		/* Program marked as deleted (logical delete) */
		programToDelete.setDeleteFlag(OpsCenterConstants.TRUE);
		programToDelete.setDateModified(new DateTime());
		programToDelete.setUserModified(userPgmModel.getUserModified());

		/* Program is scheduled by range */
		if (OpsCenterConstants.TRUE.equalsIgnoreCase(programToDelete.getSchedByRangeFlag()))
		{
			HashSet<ProgramScheduleRange> schedulesOfProgramFordeletion = new HashSet<ProgramScheduleRange>(
					programToDelete.getProgramScheduleRangeCollection());

			// KRMT-2041 remove code that was trying to move schedule to default
			// program if
			// it was scheduled for today. No longer needed.

			List<ProgramScheduleRange> newList = new ArrayList<ProgramScheduleRange>();
			List<ProgramScheduleRange> oldList = new ArrayList<ProgramScheduleRange>(
					schedulesOfProgramFordeletion);

			/* Verify overlapping programs and process it correctly */
			schUserBean.saveNewSchedulesRange(newList, programToDelete.getAccountId()
					.getAccountId(), oldList, null, userPgmModel);

		}
		else
		{ // Program is scheduled by month day

			HashSet<ProgramScheduleMonthDay> schedulesOfProgramFordeletion = new HashSet<ProgramScheduleMonthDay>(
					programToDelete.getProgramScheduleMonthDayCollection());
			new ArrayList<ProgramScheduleMonthDay>();
			for (ProgramScheduleMonthDay pgmSchMonthDay : schedulesOfProgramFordeletion)
			{

				// TODO: Delete ProgramScheduleMonthDays
			}

		}

		/* Complete deletion of program */
		progFacade.updateProgram(programToDelete);
		// add prog history entry in DB - KRMT-2999
		ProgramHistory progHist = new ProgramHistory();
		try
		{
			progHist.setActionUserId(userAccountFacade.findUserByUsername(userPgmModel
					.getUserModified()));
		}
		catch (UserNotUniqueException e)
		{
			progHist.setActionUserId(null);
		}
		List<HistoryAction> histActionList = genericFacade
				.getHistoryActionByActionName("Retired");
		if (histActionList == null || histActionList.size() <= 0)
		{
			logger.error("No History Action found for Created in DB, hist record not created for program");
		}
		else
		{
			progHist.setActionDate(new DateTime());
			progHist.setProgramId(programToDelete);
			progHist.setActionShortComments(UserProgramBean.PROGRAM_DELETE_MESSAGE);
			progHist.setHistoryActionId(histActionList.get(0));
			progFacade.createProgramHistory(progHist);
		}

		logger.info("deleteProgram() - ending");
	}

	/**
	 * Creates a new program based on the information provided in user program
	 * model source reference and using program name in new user program model
	 * reference. If program matches current timeslot it will be pushed to the
	 * gateway.
	 * 
	 * @param userPgmModelSource
	 * @param newUserPgmModel
	 *            (name, userCreated, userModified)
	 * @throws ProgramNameAlreadyExistsException
	 * @throws Exception
	 */
	
	public void copyProgram(UserProgramModel userPgmModelSource,
			UserProgramModel newUserPgmModel) throws ProgramNameAlreadyExistsException,
			ProgramNotFoundException, Exception
	{
		logger.info("copyProgram() - starting");

		if (userPgmModelSource == null || newUserPgmModel == null)
		{
			logger.error("UserProgramModel(source) or UserProgramModel(new) is null");
			throw new Exception("UserProgramModel(source) or UserProgramModel(new) is null");
		}

		/* Get source program */
		Program sourceProgram = progFacade.findProgramByProgramId(userPgmModelSource
				.getProgramId());
		if (sourceProgram == null)
		{
			logger.error("Source program to copy not found");
			throw new Exception("Source program to copy not found");
		}
		int sourceProgramId = sourceProgram.getProgramId();
		int l = newUserPgmModel.getName().length();
		if (l > OpsCenterConstants.PROGRAM_NAME_SIZE)
		{
			l = OpsCenterConstants.PROGRAM_NAME_SIZE;
		}
		String name = newUserPgmModel.getName().substring(0, l);

		DateTime now = new DateTime();
		String userCreated = newUserPgmModel.getUserCreated();
		String userModified = newUserPgmModel.getUserModified();

		/* Create new program and copy previous information */
		Program newCopyProgram = progFacade.getNewProgram();
		newCopyProgram.setAccountId(sourceProgram.getAccountId());
		newCopyProgram.setActiveFlag(sourceProgram.getActiveFlag());
		newCopyProgram.setDateCreated(now);
		newCopyProgram.setDateModified(now);
		newCopyProgram.setDefaultFlag(OpsCenterConstants.FALSE);
		newCopyProgram.setDeleteFlag(sourceProgram.getDeleteFlag());
		newCopyProgram.setName(name);
		newCopyProgram.setSchedByRangeFlag(sourceProgram.getSchedByRangeFlag());
		newCopyProgram.setUserCreated(userCreated);
		newCopyProgram.setUserModified(userModified);
		progFacade.createProgram(newCopyProgram);

		logger.info("New program copy instance created " + newCopyProgram.getProgramId());

		// Copy dc transition points
		List<DcTransitionPoint> dcTPList = progFacade
				.getDcTransitionPointByProgramIdExcludeTemp(sourceProgramId); // KRMT-4825
																				// Exclude
																				// Temp
																				// TP's
		if (dcTPList != null && !dcTPList.isEmpty())
		{
			/*
			 * Process DC transition points (create, populate and save) based on
			 * source program
			 */
			Iterator<DcTransitionPoint> iterDCTransPoints = dcTPList.iterator();
			while (iterDCTransPoints.hasNext())
			{
				DcTransitionPoint dcTransPoint = iterDCTransPoints.next();
				DcTransitionPoint newDcTransPoint = new DcTransitionPoint();
				newDcTransPoint.setActiveFlag(dcTransPoint.getActiveFlag());
				newDcTransPoint.setEsiDcId(dcTransPoint.getEsiDcId());
				newDcTransPoint.setDeleteFlag(dcTransPoint.getDeleteFlag());
				newDcTransPoint.setPowerStatusFlag(dcTransPoint.getPowerStatusFlag());
				newDcTransPoint.setTemporaryFlag(dcTransPoint.getTemporaryFlag());
				newDcTransPoint.setTpTime(dcTransPoint.getTpTime());
				newDcTransPoint.setProgramId(newCopyProgram);
				newDcTransPoint.setDateCreated(now);
				newDcTransPoint.setUserCreated(userCreated);
				newDcTransPoint.setDateModified(now);
				newDcTransPoint.setUserModified(userModified);

				progFacade.createDcTransitionPoint(newDcTransPoint);
				logger.trace("DC transition point added: "
						+ newDcTransPoint.getDcTransitionPointId());
			}
		}

		// Copy tstat transition points
		List<TstatTransitionPoint> tstatTPList = progFacade
				.getTstatTransitionPointByProgramIdExcludeTemp(sourceProgramId); // KRMT-4825
																					// Exclude
																					// Temp
																					// TP's
		if (tstatTPList != null && !tstatTPList.isEmpty())
		{
			Iterator<TstatTransitionPoint> iterTSATTransPoints = tstatTPList.iterator();
			while (iterTSATTransPoints.hasNext())
			{
				TstatTransitionPoint tstatTrans = iterTSATTransPoints.next();
				TstatTransitionPoint newTstatTransPoint = PersistenceUtilities.getTargetedClone(tstatTrans);
				newTstatTransPoint.setProgramId(newCopyProgram);
				newTstatTransPoint.setDateCreated(now);
				newTstatTransPoint.setUserCreated(userCreated);
				newTstatTransPoint.setDateModified(now);
				newTstatTransPoint.setUserModified(userModified);
				progFacade.createTstatTransitionPoint(newTstatTransPoint);
				logger.trace("TSTAT transition point added: "
						+ newTstatTransPoint.getTstatTransitionPointId());
			}
		}

		// Copy schedules by range
		if (OpsCenterConstants.TRUE.equalsIgnoreCase(sourceProgram.getSchedByRangeFlag()))
		{
			List<ProgramScheduleRange> pgmScheRangeList = new ArrayList<ProgramScheduleRange>(
					sourceProgram.getProgramScheduleRangeCollection());
			if (!pgmScheRangeList.isEmpty())
			{
				Iterator<ProgramScheduleRange> iterProgramScheduleRange = pgmScheRangeList
						.iterator();
				while (iterProgramScheduleRange.hasNext())
				{
					ProgramScheduleRange pgmScheduleRange = iterProgramScheduleRange.next();
					ProgramScheduleRange newPgmScheduleRange = new ProgramScheduleRange();
					newPgmScheduleRange.setActiveFlag(pgmScheduleRange.getActiveFlag());
					newPgmScheduleRange.setDeleteFlag(pgmScheduleRange.getDeleteFlag());
					newPgmScheduleRange.setEndDate(pgmScheduleRange.getEndDate());
					// newPgmScheduleRange.setProgramScheduleRangeId(pgmScheduleRange.getProgramScheduleRangeId());
					newPgmScheduleRange.setProgramId(newCopyProgram);
					newPgmScheduleRange.setStartDate(pgmScheduleRange.getStartDate());
					newPgmScheduleRange.setDateCreated(now);
					newPgmScheduleRange.setUserCreated(userCreated);
					newPgmScheduleRange.setDateModified(now);
					newPgmScheduleRange.setUserModified(userModified);
					progFacade.createProgramScheduleRange(newPgmScheduleRange);
					logger.trace("Schedule Range added: "
							+ newPgmScheduleRange.getProgramScheduleRangeId());
				}
			}

		}
		else
		{
			// Copy schedules by month day
			List<ProgramScheduleMonthDay> pgmScheMonthDayList = new ArrayList<ProgramScheduleMonthDay>(
					sourceProgram.getProgramScheduleMonthDayCollection());
			;
			if (!pgmScheMonthDayList.isEmpty())
			{
				Iterator<ProgramScheduleMonthDay> iterProgramScheduleMonthDay = pgmScheMonthDayList
						.iterator();
				while (iterProgramScheduleMonthDay.hasNext())
				{
					ProgramScheduleMonthDay pgmScheduleMonthDay = iterProgramScheduleMonthDay
							.next();
					ProgramScheduleMonthDay newPgmScheduleMonthDay = new ProgramScheduleMonthDay();
					newPgmScheduleMonthDay.setActiveFlag(pgmScheduleMonthDay.getActiveFlag());
					newPgmScheduleMonthDay.setApr(pgmScheduleMonthDay.getApr());
					newPgmScheduleMonthDay.setAug(pgmScheduleMonthDay.getAug());
					newPgmScheduleMonthDay.setDec(pgmScheduleMonthDay.getDec());
					newPgmScheduleMonthDay.setDeleteFlag(pgmScheduleMonthDay.getDeleteFlag());
					newPgmScheduleMonthDay.setFeb(pgmScheduleMonthDay.getFeb());
					newPgmScheduleMonthDay.setJan(pgmScheduleMonthDay.getJan());
					newPgmScheduleMonthDay.setJul(pgmScheduleMonthDay.getJul());
					newPgmScheduleMonthDay.setJun(pgmScheduleMonthDay.getJun());
					newPgmScheduleMonthDay.setMar(pgmScheduleMonthDay.getMar());
					newPgmScheduleMonthDay.setMay(pgmScheduleMonthDay.getMay());
					newPgmScheduleMonthDay.setNov(pgmScheduleMonthDay.getNov());
					newPgmScheduleMonthDay.setSep(pgmScheduleMonthDay.getSep());
					newPgmScheduleMonthDay.setOct(pgmScheduleMonthDay.getOct());
					newPgmScheduleMonthDay.setProgramId(newCopyProgram);
					newPgmScheduleMonthDay.setSat(pgmScheduleMonthDay.getSat());
					newPgmScheduleMonthDay.setFri(pgmScheduleMonthDay.getFri());
					newPgmScheduleMonthDay.setSun(pgmScheduleMonthDay.getSun());
					newPgmScheduleMonthDay.setMon(pgmScheduleMonthDay.getMon());
					newPgmScheduleMonthDay.setThu(pgmScheduleMonthDay.getThu());
					newPgmScheduleMonthDay.setTue(pgmScheduleMonthDay.getTue());
					newPgmScheduleMonthDay.setWed(pgmScheduleMonthDay.getWed());
					newPgmScheduleMonthDay.setDateCreated(now);
					newPgmScheduleMonthDay.setUserCreated(userCreated);
					newPgmScheduleMonthDay.setDateModified(now);
					newPgmScheduleMonthDay.setUserModified(userModified);
					progFacade.createProgramScheduleMonthDay(pgmScheduleMonthDay);
					logger.trace("Schedule Month Day added: "
							+ newPgmScheduleMonthDay.getProgramScheduleMonthDayId());
				}
			}
		}
		logger.info("copyProgram() - ending");
	}

	/**
	 * Updates an existing program based on the account and user info provided
	 * in the user program Modelate reference.
	 * 
	 * @param userPgmModel
	 *            (dest programid, source accountid,
	 * @throws Exception
	 */

    private void processValidTP (List<TstatTransitionPointModel> tsatTransitionPoints,String userModified,Program program)
    							throws ProgramNotFoundException,Exception{
    	
		DateTime now = new DateTime();


		Iterator<TstatTransitionPointModel> iterTSATTransPoints = tsatTransitionPoints
				.iterator();
		while (iterTSATTransPoints.hasNext())
		{
			TstatTransitionPointModel tstatTransModel = iterTSATTransPoints.next();

			TstatTransitionPoint tstatTransPoint = null;
			TstatTransitionPointAttHistory tsTPHist = new TstatTransitionPointAttHistory();
			boolean operationIsCreate = false;

			// Sending in Models with TransitionPoint ID <= 0 means to
			// create
			// new transition points.
			if (tstatTransModel.getTpId() > 0)
			{
				tstatTransPoint = progFacade.findTstatTransitionPointByTpId(tstatTransModel
						.getTpId());
			}

			// Did the search find anything in the DB?
			if (tstatTransPoint == null || tstatTransPoint.getTstatTransitionPointId() <= 0)
			{
				logger.trace("UserProgramBean: detected a new TstatTransitionPoint coming in for creation: "
						+ tstatTransModel);
				tstatTransPoint = new TstatTransitionPoint();
				tstatTransPoint.setTpTime(tstatTransModel.getTpTime());
				tstatTransPoint.setMaxTemp(tstatTransModel.getMaxTemp());
				tstatTransPoint.setMinTemp(tstatTransModel.getMinTemp());
				tstatTransPoint.setPrefCoolTemp(tstatTransModel.getPrefCoolTemp());
				tstatTransPoint.setPrefHeatTemp(tstatTransModel.getPrefHeatTemp());
				tstatTransPoint.setOpModeId(progFacade
						.findOpModeByOpModeId(OpsCenterConstants.opModeNameToIdMap.get(
								OpsCenterConstants.TSTAT_UNAVAIL).intValue()));
				tstatTransPoint.setDateCreated(now);
				tstatTransPoint.setHoldStatus(OpsCenterConstants.FALSE);

				operationIsCreate = true;
			}
			else
			{
				logger.trace("UserProgramBean: detected an existing TstatTransitionPoint coming in for update: "
						+ tstatTransModel);
			}

			// fill in ts transistion point history info
			try
			{
				tsTPHist.setActionUserId(userAccountFacade.findUserByUsername(userModified));
			}
			catch (UserNotUniqueException e)
			{
				tsTPHist.setActionUserId(null);
			}

			tsTPHist.setActionDate(now);
			tsTPHist.setMaxTempBefore(tstatTransPoint.getMaxTemp());
			tsTPHist.setMaxTempAfter(tstatTransModel.getMaxTemp());
			tsTPHist.setMinTempBefore(tstatTransPoint.getMinTemp());
			tsTPHist.setMinTempAfter(tstatTransModel.getMinTemp());
			tsTPHist.setPrefCoolTempBefore(tstatTransPoint.getPrefCoolTemp());
			tsTPHist.setPrefCoolTempAfter(tstatTransModel.getPrefCoolTemp());
			tsTPHist.setPrefHeatTempBefore(tstatTransPoint.getPrefHeatTemp());
			tsTPHist.setPrefHeatTempAfter(tstatTransModel.getPrefHeatTemp());
			tsTPHist.setTemporaryFlag(OpsCenterConstants.FALSE);
			tsTPHist.setTpTimeBefore(tstatTransPoint.getTpTime());
			tsTPHist.setTpTimeAfter(tstatTransModel.getTpTime());
			tsTPHist.setOpModeBefore(tstatTransPoint.getOpModeId());
			tsTPHist.setOpModeAfter(progFacade.findOpModeByOpModeId(tstatTransModel
					.getOpModeId()));
			tsTPHist.setHoldStatus(OpsCenterConstants.FALSE);


			// fill in ts transition point info
			tstatTransPoint.setActiveFlag(tstatTransModel.getActiveFlag());
			tstatTransPoint.setDeleteFlag(tstatTransModel.getDeleteFlag());
			tstatTransPoint.setMaxTemp(tstatTransModel.getMaxTemp());
			tstatTransPoint.setMinTemp(tstatTransModel.getMinTemp());
			tstatTransPoint.setOpModeId(progFacade.findOpModeByOpModeId(tstatTransModel
					.getOpModeId()));
			tstatTransPoint.setPrefCoolTemp(tstatTransModel.getPrefCoolTemp());
			tstatTransPoint.setPrefHeatTemp(tstatTransModel.getPrefHeatTemp());
			tstatTransPoint.setProgramId(program);
			tstatTransPoint.setTemporaryFlag(tstatTransModel.getTempFlag());
			tstatTransPoint.setTpTime(tstatTransModel.getTpTime());
			tstatTransPoint.setEsiTstatId(esiFacade.findEsiTstatByEsiTstatId(tstatTransModel
					.getEsiTstatId()));
			tstatTransPoint.setUserModified(userModified);
			tstatTransPoint.setDateModified(now);
			tstatTransPoint.setUserCreated(userModified);
			tstatTransPoint.setHoldStatus(OpsCenterConstants.FALSE);

			if (operationIsCreate)
			{
				try
				{
					progFacade.createTstatTransitionPoint(tstatTransPoint);
					tsTPHist.setTstatTransitionPointId(tstatTransPoint);
					progFacade.createTstatTransitionPointAttHistory(tsTPHist);
				}
				catch (Exception e1)
				{
					if (logger.isErrorEnabled())
					{
						logger.error(
								"Failed to create Tstat TP in DB for Prog ID = "
										+ program.getProgramId(), e1);
					}
					throw new TransitionPointDBUpdateFailed(
							DefaultResources.PRG_ERR_CODE_TP_CREATE_FAILED,
							"Failed to create DC TP in DB for Prog ID = "
									+ program.getProgramId(), e1);
					// do not send to GW if DB does not get created
				}

			}
			else
			{

				try
				{
					progFacade.updateTstatTransitionPoint(tstatTransPoint);
					entityManager.flush();
					tsTPHist.setTstatTransitionPointId(tstatTransPoint);
					try
					{
						progFacade.createTstatTransitionPointAttHistory(tsTPHist);
						entityManager.flush();
					}
					catch (Exception e)
					{
						// swallow error with creating history record
						if (logger.isErrorEnabled())
						{
							logger.error("Failed to create TS TP ID AttHistory for tsTPid=  "
									+ tstatTransPoint.getTstatTransitionPointId(), e);
						}
					}

				}
				catch (Exception e1)
				{
					if (logger.isErrorEnabled())
					{
						logger.error(
								"Failed to update tstat TP in DB for Prog ID = "
										+ program.getProgramId(), e1);
					}
					throw new TransitionPointDBUpdateFailed(
							DefaultResources.PRG_ERR_CODE_TP_UPDATE_FAILED,
							"Failed to update Tstat TP in DB for Prog ID = "
									+ program.getProgramId(), e1);
					// do not send to GW if DB does not get updated
				}
			}

			// KRMT-4648 Remove logging because breaks with large number of
			// Tstats.
			// logger.trace("TSTAT transition point "
			// + (operationIsCreate ? "created" : "updated") + ": "
			// + tstatTransPoint.getTstatTransitionPointId());
		}

	
		
	}
    
    private void iterateOverDCTP (Iterator<DCTransitionPointModel> iterDCTransPoints,String userModified,Program program)
    							  throws ProgramNotFoundException,Exception{
    	

		DateTime now = new DateTime();
		while (iterDCTransPoints.hasNext()) 
		{

	    	DCTransitionPointModel dcTransModel = iterDCTransPoints.next();
	
			DcTransitionPoint dcTransPoint = null;
			DcTransitionPointAttHistory dcTPHist = new DcTransitionPointAttHistory();
			boolean operationIsCreate = false;
	
			// Sending in Models with TransitionPoint ID <= 0 means to create
			// new transition points.
			if (dcTransModel.getTpId() > 0)
			{
				dcTransPoint = progFacade.findDcTransitionPointByTpId(dcTransModel.getTpId());
			}
	
			if (dcTransPoint == null || dcTransPoint.getDcTransitionPointId() <= 0)
			{
				logger.trace("UserProgramBean: detected a new DcTransitionPoint coming in for creation: "
						+ dcTransModel);
				dcTransPoint = new DcTransitionPoint();
				dcTransPoint.setTpTime(dcTransModel.getTpTime());
				dcTransPoint.setPowerStatusFlag(OpsCenterConstants.FALSE);
				dcTransPoint.setDateCreated(now);
				operationIsCreate = true;
			}
			else
			{
				logger.trace("UserProgramBean: detected an existing DcTransitionPoint coming in for update: "
						+ dcTransModel);
			}
	
			// fill in dc transition point history info
			try
			{
				dcTPHist.setActionUserId(userAccountFacade.findUserByUsername(userModified));
			}
			catch (UserNotUniqueException e)
			{
				dcTPHist.setActionUserId(null);
			}
			dcTPHist.setActionDate(now);
			dcTPHist.setPowerStatusFlagBefore(dcTransPoint.getPowerStatusFlag());
			dcTPHist.setPowerStatusFlagAfter(dcTransModel.getPowerStatusFlag());
			dcTPHist.setTemporaryFlag(OpsCenterConstants.FALSE);
			dcTPHist.setTpTimeBefore(dcTransPoint.getTpTime());
			dcTPHist.setTpTimeAfter(dcTransModel.getTpTime());
	
			// fill in dc transition point info
			dcTransPoint.setActiveFlag(dcTransModel.getActiveFlag());
			dcTransPoint.setEsiDcId(esiFacade.findEsiDcByEsiDcId(dcTransModel.getEsiDcId()));
			dcTransPoint.setDeleteFlag(dcTransModel.getDeleteFlag());
			dcTransPoint.setPowerStatusFlag(dcTransModel.getPowerStatusFlag());
			dcTransPoint.setProgramId(program);
			dcTransPoint.setTemporaryFlag(OpsCenterConstants.FALSE);
			dcTransPoint.setTemporaryFlag(dcTransModel.getTempFlag());
			dcTransPoint.setTpTime(dcTransModel.getTpTime());
			dcTransPoint.setUserModified(userModified);
			dcTransPoint.setDateModified(now);
			dcTransPoint.setUserCreated(userModified);
	
			if (operationIsCreate)
			{
				try
				{
					progFacade.createDcTransitionPoint(dcTransPoint);
					dcTPHist.setDcTransitionPointId(dcTransPoint);
					progFacade.createDcTransitionPointAttHistory(dcTPHist);
				}
				catch (Exception e1)
				{
					if (logger.isErrorEnabled())
					{
						logger.error(
								"Failed to create DC TP in DB for Prog ID = "
										+ program.getProgramId(), e1);
					}
					throw new TransitionPointDBUpdateFailed(
							DefaultResources.PRG_ERR_CODE_TP_CREATE_FAILED,
							"Failed to create DC TP in DB for Prog ID = " + program.getProgramId(),
							e1);
					// do not send to GW if DB does not get created
				}
			}
			else
			{
	
				try
				{
					progFacade.updateDcTransitionPoint(dcTransPoint);
					entityManager.flush();
					dcTPHist.setDcTransitionPointId(dcTransPoint);
					try
					{
						progFacade.createDcTransitionPointAttHistory(dcTPHist);
					}
					catch (Exception e)
					{
						// swallow error with creating history record
						if (logger.isErrorEnabled())
						{
							logger.error("Failed to create DC TP ID AttHistory for dcTPid=  "
									+ dcTransPoint.getDcTransitionPointId(), e);
						}
					}
	
				}
				catch (Exception e1)
				{
					if (logger.isErrorEnabled())
					{
						logger.error(
								"Failed to update DC TP in DB for Prog ID = "
										+ program.getProgramId(), e1);
					}
					throw new TransitionPointDBUpdateFailed(
							DefaultResources.PRG_ERR_CODE_TP_UPDATE_FAILED,
							"Failed to update DC TP in DB for Prog ID = " + program.getProgramId(),
							e1);
					// do not send to GW if DB does not get updated
				}
	
			}
			logger.trace("DC transition point " + (operationIsCreate ? "created" : "updated")
					+ ": " + dcTransPoint.getDcTransitionPointId());
		}
		
    	
    }
	
    @Override
	public void updateProgram(UserProgramModel userPgmModel, Integer tenantId) throws ProgramNotFoundException,
			Exception
	{
    	TenantContext.setCurrentTenant(tenantId);
		Program program;
		logger.info("updateProgram() - starting");

		if (userPgmModel == null)
		{
			logger.error("UserProgramModel is null");
			throw new Exception("UserProgramModel is null");
		}
		program = progFacade.findProgramByProgramId(userPgmModel.getProgramId());
		/* If program not found throw exception */
		if (program == null)
		{
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"No programs found for ID =  " + userPgmModel.getProgramId());
		}

		// program and send 14 days to GW
		program.setAccountId(userAccountFacade.findAccountByAccountId(userPgmModel.getAccountId()));
		DateTime now = new DateTime();
		String userModified = userPgmModel.getUserModified();
		if (userModified != null)
		{
			logger.debug("updateProgram: Program " + userPgmModel.getName() + " modified by : "
					+ userModified);
		}
		else
		{
			logger.error("updateProgram: Program " + userPgmModel.getName()
					+ " user modified is null");
		}

		// Rename the program if the name has changed
		validateProgramName(userPgmModel, program);
		program.setName(userPgmModel.getName());

		program.setDateModified(now);
		program.setDefaultFlag(userPgmModel.getDefaultFlag());
		program.setSchedByRangeFlag(userPgmModel.getSchedByRangeFlag());
		program.setUserModified(userModified);

		/*
		 * Process DC transition points (create, populate and save) based on
		 * model info
		 */
		List<DCTransitionPointModel> dcTransitionPoints = userPgmModel
				.getDcTransitionPointCollection();
		Iterator<DCTransitionPointModel> iterDCTransPoints = dcTransitionPoints.iterator();
		 
		//rdrn-244 remove if complexity
		iterateOverDCTP (iterDCTransPoints,userModified,program);
		/*
		 * Process TSAT transition points (create, populate and save) based on
		 * Modelate info
		 */
		List<TstatTransitionPointModel> tsatTransitionPoints = userPgmModel
				.getTstatTransitionPointCollection();
		// KRMT-3577 Check for null because there might not be Tstats
		if (tsatTransitionPoints != null)
		{
			//rdrn-244 remove if complexity
			processValidTP (tsatTransitionPoints,userModified,program);
		}// KRMT-3577 end change

		// KRMT-1399 ; Save the ranges down for the program even if it is not
		// scheduled by range.
		// KRMT-4227 Saving Program with sched by range when it is marked as
		// sched by recurring throws error.
		// only do this if truly marked as "schedule by range"

		if (userPgmModel.getSchedByRangeFlag().equals(OpsCenterConstants.TRUE))
		{
			// ==== Schedule by Range ===========
			// First, logically delete all old schedules by range and re-create
			// fresh every time.
			List<ProgramScheduleRange> existingRanges = progFacade
					.getProgramScheduleRangeByProgramId(program.getProgramId());
			logger.debug("existingRanges before delete = " + existingRanges.size());

			for (ProgramScheduleRange existingRange : existingRanges)
			{
				if (existingRange.getDeleteFlag().equals(OpsCenterConstants.FALSE))
				{
					logger.debug("Deleting All Existing Sched By Range for ProgramId: "
							+ program.getProgramId() + " :  ProgramScheduleByRangeId = "
							+ existingRange.getProgramScheduleRangeId());
					existingRange.setDeleteFlag(OpsCenterConstants.TRUE);
					existingRange.setUserModified(userModified);
					existingRange.setDateModified(now);
					progFacade.updateProgramScheduleRange(existingRange);
				}
			}
			logger.debug("existingRanges after delete = " + existingRanges.size());
			// Second, Add new incoming Schedules in, even if the program is not
			// flagged as sched by Range

			ArrayList<ProgramScheduleRange> newRangesAdded = new ArrayList<ProgramScheduleRange>();

			if (userPgmModel.getProgramScheduleRangeCollection() != null)
			{

				for (ProgramScheduleRangeModel newModel : userPgmModel
						.getProgramScheduleRangeCollection())
				{

					ProgramScheduleRange newRangeToAdd = new ProgramScheduleRange();

					newRangeToAdd.setProgramId(program);
					newRangeToAdd.setActiveFlag(OpsCenterConstants.TRUE);
					newRangeToAdd.setDeleteFlag(OpsCenterConstants.FALSE);

					newRangeToAdd.setStartDate(newModel.getStartDate());
					newRangeToAdd.setEndDate(newModel.getEndDate());
					newRangeToAdd.setDateCreated(now);
					newRangeToAdd.setUserModified(userModified);
					newRangeToAdd.setDateModified(now);
					newRangeToAdd.setUserCreated(userModified);

					progFacade.createProgramScheduleRange(newRangeToAdd);
					logger.debug("Created sch rng entry for prgId =  " + program.getProgramId());

					ProgramScheduleRangeAttHistory progSchedAttHist = null;
					for (ProgramScheduleRange existingRange : existingRanges)
					{

						progSchedAttHist = new ProgramScheduleRangeAttHistory();
						progSchedAttHist.setProgramScheduleRangeId(newRangeToAdd);
						progSchedAttHist.setActionDate(now);
						progSchedAttHist.setEndDateAfter(newRangeToAdd.getEndDate());
						progSchedAttHist.setEndDateBefore(existingRange.getEndDate());
						progSchedAttHist.setStartDateAfter(newRangeToAdd.getStartDate());
						progSchedAttHist.setStartDateBefore(existingRange.getStartDate());
						progSchedAttHist.setProgramScheduleRangeId(newRangeToAdd);
						// fill in ts transistion point history info
						try
						{
							progSchedAttHist.setActionUserId(userAccountFacade
									.findUserByUsername(userModified));
						}
						catch (UserNotUniqueException e)
						{
							progSchedAttHist.setActionUserId(null);
						}

					}
					if (progSchedAttHist != null)
					{
						progFacade.createProgramScheduleRangeAttHistory(progSchedAttHist);
						logger.debug("Created Sch Rng Hist entry in DB for hist ID ="
								+ newRangeToAdd.getProgramScheduleRangeId());

					}
					else
					{
						logger.error("No Sch Range Hist added, existing range not found in DB");
					}
					// Save a reference for post-processing cleanup.
					newRangesAdded.add(newRangeToAdd);
				}

				/* After all new have been added, verify overlapping programs and process it correctly */
				schUserBean.saveProgramSchedulesRange(program, newRangesAdded);

				logger.debug("Schedule Range added a total count of " + newRangesAdded.size()
						+ "  to programId " + program.getProgramId());
			}
		} // only do if schedule marked as "schedule by range"

		// ==== Schedule by DoW/MoY ===========
		// KRMT-1399: Save the DoW/MoY mapping down eeven if it's schedule by
		// range
		LinkedHashMap<String, String> pgmScheduleMonth = userPgmModel
				.getProgramScheduleMonthMap();
		LinkedHashMap<String, String> pgmScheduleDays = userPgmModel
				.getProgramScheduleDayMap();

		if (pgmScheduleMonth != null && pgmScheduleMonth.size() != 0
				&& pgmScheduleDays != null && pgmScheduleDays.size() != 0)
		{
			processMonthDaySchedule(pgmScheduleMonth, pgmScheduleDays, program, userPgmModel);
		}

		// -- Complete --
		program.setDeleteFlag(OpsCenterConstants.FALSE); // Program sucesfully
															// created will be
															// set to true

		int l = userPgmModel.getName().length();
		if (l > OpsCenterConstants.PROGRAM_NAME_SIZE)
		{
			l = OpsCenterConstants.PROGRAM_NAME_SIZE;
		}

		progFacade.updateProgram(program);

		// add prog history entry in DB - KRMT-2999
		ProgramHistory progHist = new ProgramHistory();
		try
		{
			progHist.setActionUserId(userAccountFacade.findUserByUsername(userModified));
		}
		catch (UserNotUniqueException e)
		{
			progHist.setActionUserId(null);
		}
		List<HistoryAction> histActionList = genericFacade
				.getHistoryActionByActionName("Created");
		if (histActionList == null || histActionList.size() <= 0)
		{
			logger.error("No History Action found for Created in DB, hist record not created for program");
		}
		else
		{
			progHist.setActionDate(now);
			progHist.setProgramId(program);
			progHist.setActionShortComments("Program Update");
			progHist.setHistoryActionId(histActionList.get(0));
			progFacade.createProgramHistory(progHist);
		}
		
		if (!isAccInCriticalCe(userPgmModel.getAccountId())) {

		    controlEventPowerBean.optOutEsiFromCE(userPgmModel.getAccountId(),
				OpsCenterConstants.OptOutReason.GUI);
		}

		logger.info("updateProgram() - ending");
	}
	
	public boolean isAccInCriticalCe(int accId) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] boolean isAccInCriticalCe(accId = " + accId );

		boolean result = false;
		Results accMapResults = cacheManager.getCacheDataByCeAccId(cacheManager.getCeAccMapCache(),
				accId);

		CEAccountMapCacheData accMapCache = null;

		for (Result accMap : accMapResults.all())
		{
			accMapCache = (CEAccountMapCacheData) accMap.getValue();
			if (accMapCache.getCriticalFlag().equals(OpsCenterConstants.TRUE))
				result= true;
			    break;
		}
		logger.info("[Exit] boolean isAccInCriticalCe)");

		return result;
		

			
  }

	/**
	 * Determines if the request TP data is for override TP and if so creates an
	 * OVR TP in DB, creates the OVR payload and calls method to send payload to
	 * GW
	 * 
	 * @param userPgmModel
	 *            TransitionPointModel
	 * @return true if at least 1 OVR tp found in provided userPgmTmpl otherwise
	 *         false iks returned.
	 */
	
	@Override
	public void updateTempTransitionPoint(TransitionPointModel userPgmModel, Integer tenantId)
			throws ProgramNotFoundException, TransitionPointDBUpdateFailed
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] void UserProgramBean.updateTempTransitionPoint(...)");

		// first see if there is DC TP in the requested data, if so look for it
		// in DB
		// if TP is found then updated and send to GW, otherwise create a new
		// entry in DB and send to GW
		
		DCTransitionPointModel dctpt = userPgmModel.getDcTransitionPoint();
		
		if (dctpt != null)
		{
			overrideTransitionPointDC(userPgmModel);
		}
		else
		{
			overrideTransitionPointTstat(userPgmModel);
		}

		// opt out of a CE
		Program prog = progFacade.findProgramByProgramId(userPgmModel.getProgramId());
		if (prog != null)
		{
			TstatTransitionPointModel tstpt = userPgmModel.getTstatTransitionPoint();
			boolean shouldOptOutTstat = true;
			EsiDcCacheData dcCache = null;
			if (null != dctpt) {
				Results lcsResults = cacheManager.getCacheDataByEsiDcId(
						cacheManager.getGwDCCache(), dctpt.getEsiDcId());
				if (null != lcsResults) {

					for (Result dcResult : lcsResults.all()) {
						dcCache = (EsiDcCacheData) dcResult.getValue();

					}
					if(null !=dcCache && dcCache.getCeId()<=0)
					{
					logger.debug("UserProgramBean.updateTempTransitionPoint The CEID is"+dcCache.getCeId());
					shouldOptOutTstat = dmConfigBean.optOUTDMDevice(dcCache, prog
							.getAccountId().getAccountId(),false,false,userPgmModel.getUserModified());
					}
				}
			}
           if (null != tstpt)
			{

				int esiTstat = tstpt.getEsiTstatId();
				Results tstatResults = cacheManager.getCacheDataByEsiTstatId(cacheManager.getGsTstatCache(),esiTstat);
				GridStreamTstatCacheData tstatCacheData = null;
				ControlEventCacheData ceCache = null;
				OpsCenterConstants.eventMode eventMode = OpsCenterConstants.eventMode.VPP;

				//Do not opt out the tstat on a temporary override if the device is in a cycling CE
				//and the device configuration for the device is set to "1". This only applies
				//to GS devices.
				if (null != tstatResults)
				{

					for (Result result : tstatResults.all())
					{

						tstatCacheData = (GridStreamTstatCacheData) result.getValue();

						Results dcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(),tstatCacheData.getEsiHvacDcId());

						if (null != dcResults)
						{

							for (Result dcResult : dcResults.all())
							{
								dcCache = (EsiDcCacheData) dcResult.getValue();
								if (null!=dcCache)
								{
									if(0<dcCache.getCeId())
									{
									logger.debug("UserProgramBean.updateTempTransitionPoint The CEID is"+dcCache.getCeId());
									int esiDcId = dcCache.getEsiDcId();

									Results ceResults = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(), dcCache.getCeId());

									if (null != ceResults)
									{
										for (Result ceResult : ceResults.all())
										{
											ceCache = (ControlEventCacheData) ceResult.getValue();
											eventMode = ceCache.getMode();

											if (OpsCenterConstants.eventMode.CYCLING == eventMode)
											{
												EsiDc esiDc = esiFacade.findEsiDcByEsiDcId(esiDcId);

												int dcId = esiDc.getDcId().getDcId();

												entityManager.detach(esiDc);
										        shouldOptOutTstat = deviceConfigBean.doesDeviceOptOutOnTempOverride(dcId);
											}
										}
									}
									}
									else
									{
										//Added for PHNX-378 DM Manual OverRide Case
										//To be Called for optout
										logger.debug("UserProgramBean.updateTempTransitionPoint Inside when CEID is zero");
										shouldOptOutTstat=dmConfigBean.optOUTDMDevice(dcCache,prog.getAccountId().getAccountId(),true,false,userPgmModel.getUserModified());
									}
								}
								
							}
						}

						dcResults.discard();
					}
				}
			}

			if (shouldOptOutTstat)
			{
				try
				{
					controlEventPowerBean.optOutEsiFromCE(prog.getAccountId().getAccountId(),
							OpsCenterConstants.OptOutReason.GUI);
				}
				catch (AbstractOpsCenterException e)
				{
					e.printStackTrace();
				}
			}
		}
		else
		{
			logger.debug("updateTempTransitionPoint: program not found for program id  = "
					+ userPgmModel.getProgramId());
		}

		logger.info("[ EXIT] UserProgramBean.updateTempTransitionPoint");
	}


	/**
	 * @param userPgmModel
	 * @throws ProgramNotFoundException
	 * @throws TransitionPointDBUpdateFailed
	 */
	private void overrideTransitionPointDC(TransitionPointModel userPgmModel)
			throws ProgramNotFoundException, TransitionPointDBUpdateFailed
	{
		logger.debug("[ENTER] void UserProgramBean.overrideTransitionPointDC(...)");

		boolean newTP = false;
		Esi esiEntry = null;
		DcTransitionPoint dcTP = null;
		DcTransitionPointAttHistory dcTPHist = new DcTransitionPointAttHistory();

		logger.debug("dumping pass in power status model data" +userPgmModel.getDcTransitionPoint().getPowerStatusFlag());
		// first see if there is DC TP in the requested data, if so look for it
		// in DB
		// if TP is found then updated and send to GW, otherwise create a new
		// entry in DB and send to GW
		DCTransitionPointModel dctpt = userPgmModel.getDcTransitionPoint();
		Program program = null;

		String userModified = userPgmModel.getUserModified();
		DateTime now = new DateTime();

		// could be updating a TP which already exist in DB
		program = progFacade.findProgramByProgramId(dctpt.getProgramId());

		if (program == null)
		{
			logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointDC");
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"Program not found for program ID =  " + dctpt.getProgramId());
		}

		dcTP = progFacade.findDcTransitionPointByTpId(dctpt.getTpId());
		if (dcTP == null)
		{
			dcTP = new DcTransitionPoint();
			dcTP.setTpTime(dctpt.getTpTime());
			dcTP.setPowerStatusFlag(OpsCenterConstants.FALSE);
			newTP = true;
		}

		// fill in DC transition point history info
		User user = null;
		try
		{
			user = userAccountFacade.findUserByUsername(userModified);
			dcTPHist.setActionUserId(user);
		}
		catch (UserNotUniqueException e)
		{
			dcTPHist.setActionUserId(null);
		}
		dcTPHist.setActionDate(now);
		dcTPHist.setPowerStatusFlagBefore(dcTP.getPowerStatusFlag());
		dcTPHist.setPowerStatusFlagAfter(dctpt.getPowerStatusFlag());
		dcTPHist.setTemporaryFlag(newTP ? OpsCenterConstants.TRUE : OpsCenterConstants.FALSE);
		dcTPHist.setTpTimeBefore(dcTP.getTpTime());
		dcTPHist.setTpTimeAfter(dctpt.getTpTime());

		// fill in dc transition point info
		dcTP.setProgramId(program);
		dcTP.setTpTime(dctpt.getTpTime());
		dcTP.setEsiDcId(esiFacade.findEsiDcByEsiDcId(dctpt.getEsiDcId()));
		dcTP.setTemporaryFlag(newTP ? OpsCenterConstants.TRUE : OpsCenterConstants.FALSE);
		dcTP.setDeleteFlag(OpsCenterConstants.FALSE);
		dcTP.setActiveFlag(OpsCenterConstants.TRUE);
		dcTP.setPowerStatusFlag(dctpt.getPowerStatusFlag());
		dcTP.setDateCreated(now);
		dcTP.setUserModified(userModified);
		dcTP.setDateModified(now);
		dcTP.setUserCreated(userModified);

		if (newTP)
		{
			// requested TP not found in DB, create it now
			try
			{
				progFacade.createDcTransitionPoint(dcTP);
				int dctpid = dcTP.getDcTransitionPointId();
				if (dctpid == 0)
				{
					// TODO: this is temp fix for now... fix error
					if (logger.isErrorEnabled())
					{
						logger.error("Failed to retrieve DC TP ID after creation of TP for EsiDcId =  "
								+ dcTP.getEsiDcId());
					}
					DcTransitionPoint ndc = progFacade.getDcTransitionPointByEsiDcId(
							dcTP.getEsiDcId().getEsiDcId()).get(0);
					dcTPHist.setDcTransitionPointId(ndc);
				}
				else
				{
					dcTPHist.setDcTransitionPointId(dcTP);
				}

				progFacade.createDcTransitionPointAttHistory(dcTPHist);
			}
			catch (Exception e1)
			{
				if (logger.isErrorEnabled())
				{
					logger.error("Failed to create DC TP in DB for Prog ID = "
							+ program.getProgramId());
				}

				logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointDC");

				throw new TransitionPointDBUpdateFailed(
						DefaultResources.PRG_ERR_CODE_TP_CREATE_FAILED,
						"Failed to create DC TP in DB for Prog ID = " + program.getProgramId(), e1);
				// do not send to GW if DB does not get created
			}
		}
		else
		{
			// otherwise update the TP
			try
			{
				progFacade.updateDcTransitionPoint(dcTP);
				dcTPHist.setDcTransitionPointId(dcTP);
				progFacade.createDcTransitionPointAttHistory(dcTPHist);
			}
			catch (Exception e)
			{
				if (logger.isErrorEnabled())
				{
					logger.error("Failed to update DC TP in DB for Prog ID = "
							+ program.getProgramId());
				}

				logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointDC");

				throw new TransitionPointDBUpdateFailed(
						DefaultResources.PRG_ERR_CODE_TP_UPDATE_FAILED,
						"Failed to update DC TP in DB for Prog ID = " + program.getProgramId(), e);
				// do not send to GW if DB does not get updated
			}
		}

		esiEntry = getEsiForAccountId(program.getAccountId().getAccountId());

		// Set the alarm. It gets cleared in OperationalMessagesGroupBean when
		// the ack (0x43) is received.
		Set<Integer> programs = new HashSet<Integer>();
		programs.add(program.getProgramId());

		String gwCacheKey = "";
		if (esiEntry.getHardwareType().equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
		{
			GridStreamDcProgramOverrideHandler gsProgramOverrideHandler = new GridStreamDcProgramOverrideHandler();

			GSProgramOverrideDcMessage gsProgramOverrideMessage = gsProgramOverrideHandler
					.getProgramPush(esiEntry, dcTP);

			gsProgramOverrideMessage.dump();

			setProgPushAlarm(programs, esiEntry.getEsiId(),
					gsProgramOverrideMessage.getDeviceMacAddress(), user,
					OpsCenterConstants.OPCODE_SEND_OVERRIDE_PROGRAM);

			gwCacheKey = sendDcOverrideMessageGS(gsProgramOverrideMessage, dcTP);

			logger.debug("***overrideTransitionPointDC for GS Mac ID = "+ gwCacheKey);

			String relayId = "1";
			if (null != dcTP.getEsiDcId() && null != dcTP.getEsiDcId().getRelayId())
			{
				relayId = dcTP.getEsiDcId().getRelayId();
			}
			StringBuffer id1 = new StringBuffer();
			gwCacheKey = id1.append((Long) gsProgramOverrideMessage.getDeviceMacAddress()).append(relayId).toString().intern();

			//DEV-1524
			// For GridStream we have to set program push time at a device level
			if (cacheManager.getGwDCCache().isKeyInCache(gwCacheKey))
			{
				Element gsDcElement = cacheManager.getGwDCCache().get(gwCacheKey);
				EsiDcCacheData esiDcCache = null;
				esiDcCache = (EsiDcCacheData) gsDcElement.getObjectValue();
				esiDcCache.setPgrmRequestTime(new DateTime().getMillis());
				logger.debug("setPgrmRequestTime = "+ esiDcCache.getPgrmRequestTime() + " for cache key " + gwCacheKey);
				cacheManager.getGwDCCache().put(gsDcElement);
			}
			else
			{
				logger.debug("Key not in cache for GS Mac ID = "+ gwCacheKey);
			}
		}
		else
		{
			int alarmId = setProgPushAlarm(programs, esiEntry.getEsiId(), null, user,
					OpsCenterConstants.OPCODE_SEND_OVERRIDE_PROGRAM);

			gwCacheKey = sendDcOverrideMessageVPP(esiEntry, dcTP, alarmId);
		}

	 

		logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointDC");
	}

	/**
	 * @param esi
	 * @param tsTP
	 * @param alarmId
	 */
	private String sendDcOverrideMessageVPP(Esi esiEntry, DcTransitionPoint dcTP,
			int alarmId) throws TransitionPointDBUpdateFailed
	{
		logger.info("[ENTER] String UserProgramBean.sendDcOverrideMessageVPP(...)");

		TemporaryOverrideDataMessage ovrMsg = new TemporaryOverrideDataMessage();

		ovrMsg.setEsi_id(esiEntry.getEsiMqId()); // Use MQ_ID for messaging to
													// GW
		// ovrMsg.setEventId(new Long(gatewayMqId)); // Use MQ_ID for messaging
		// to GW
		DCTransitionPointDev dc = new DCTransitionPointDev();
		dc.setActiveFlag(dcTP.getActiveFlag());
		dc.setDeleteFlag(dcTP.getDeleteFlag());
		dc.setPowerStatusFlag(dcTP.getPowerStatusFlag());
		dc.setTemporaryFlag(dcTP.getTemporaryFlag());
		dc.setTpStartTime(dcTP.getTpTime());
		dc.setActiveFlag(dcTP.getActiveFlag());
		
		ovrMsg.setDcTransitionPointDev(dc);
		// ovrMsg.setProgramType(OpsCenterConstants.PROGRAM_TYPE_OVERRIDE);
		ovrMsg.setDeviceId(dcTP.getEsiDcId().getDeviceMqId());
		ovrMsg.setCorrelationId(alarmId);

		EndpointIdentifier endpointIdentifier = esiEntry.getEndpointIdentifierVPP();

		try
		{
			publisher.publish(endpointIdentifier, ovrMsg.getPayload());

			logger.debug("Override message sent for DC ts and GW MQ id  "
					+ endpointIdentifier.toString());
		}

		catch (PayloadAddException pae)
		{
			logger.info("[ EXIT] UserProgramBean.sendDcOverrideMessageVPP");

			throw new TransitionPointDBUpdateFailed(
					DefaultResources.PRG_ERR_CODE_TP_MESSAGE_CREATION_FAILED,
					"Failed to create DC TP message to send to gateway for DC TP = "
							+ dcTP.getDcTransitionPointId(), pae);
		}

		logger.info("[ EXIT] UserProgramBean.sendDcOverrideMessageVPP");

		return endpointIdentifier.toString();
	}

	/**
	 * @param esi
	 * @param tsTP
	 * @param alarmId
	 */
	private String sendDcOverrideMessageGS(
			GSProgramOverrideDcMessage gsProgramOverrideMessage, DcTransitionPoint dcTP)
			throws TransitionPointDBUpdateFailed
	{
		logger.info("[ENTER] String UserProgramBean.sendDcOverrideMessageGS(...)");

		EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
		try
		{
			endpointIdentifier.setMacId(gsProgramOverrideMessage.getDeviceMacAddress());

			publisher.publish(endpointIdentifier, gsProgramOverrideMessage.getPayload());

			genericBean.createMessageResponse(
					gsProgramOverrideMessage.getMessageIdInUtcSecs(),
					gsProgramOverrideMessage.getDeviceMacAddress(), dcTP.getEsiDcId().getEsiId()
							.getEsiId(), gsProgramOverrideMessage.getOpCode(), new DateTime(), null);

			logger.debug("Override message sent for LCS ts and Mac Addr =  "
					+ endpointIdentifier.toString());
		}

		catch (Exception exp)
		{
			logger.info("[ EXIT] UserProgramBean.sendDcOverrideMessageGS");

			throw new TransitionPointDBUpdateFailed(
					DefaultResources.PRG_ERR_CODE_TP_MESSAGE_CREATION_FAILED,
					"Failed to create TP message for gateway for Prog ID = "
							+ dcTP.getDcTransitionPointId(), exp);
		}

		return endpointIdentifier.toString();
	}

	/**
	 * @param userPgmModel
	 * @throws ProgramNotFoundException
	 * @throws TransitionPointDBUpdateFailed
	 */
	private void overrideTransitionPointTstat(TransitionPointModel userPgmModel)
			throws ProgramNotFoundException, TransitionPointDBUpdateFailed
	{
		logger.debug("[ENTER] void UserProgramBean.overrideTransitionPointTstat(...)");

		boolean newTP = false;
		Esi esiEntry = null;
		TstatTransitionPoint tsTP = null;
		OpMode opMode = null;
		String gwCacheKey = "";

		String userModified = userPgmModel.getUserModified();
		DateTime now = new DateTime();

		// could be updating a TP which already exist in DB

		// no valid temp DC tp in list now check tstat tp list
		TstatTransitionPointModel tstpt = userPgmModel.getTstatTransitionPoint();
		TstatTransitionPointAttHistory tsTPHist = new TstatTransitionPointAttHistory();

		if (tstpt != null)
		{
			Program program = progFacade.findProgramByProgramId(tstpt.getProgramId());

			if (program == null)
			{
				logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointTstat");
				throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
						"Program not found for program ID =  " + tstpt.getProgramId());
			}

            logger.debug(" Temp TSTAT - hold status passed in = " + tstpt.getHoldStatus());

            tsTP = progFacade.findTstatTransitionPointByTpId(tstpt.getTpId());
			if (tsTP == null)
			{
				tsTP = new TstatTransitionPoint();
				tsTP.setTpTime(tstpt.getTpTime());
				tsTP.setMaxTemp(tstpt.getMaxTemp());
				tsTP.setMinTemp(tstpt.getMinTemp());
				tsTP.setPrefCoolTemp(tstpt.getPrefCoolTemp());
				tsTP.setPrefHeatTemp(tstpt.getPrefHeatTemp());
				tsTP.setOpModeId(progFacade
						.findOpModeByOpModeId(OpsCenterConstants.opModeNameToIdMap.get(
								OpsCenterConstants.TSTAT_UNAVAIL).intValue()));
				//this ensures we set a value for DB column when inserting TP into DB
				if (tstpt.getHoldStatus() == null)
					tstpt.setHoldStatus(OpsCenterConstants.FALSE);

				tsTP.setHoldStatus(tstpt.getHoldStatus());

				newTP = true;
			}

			// fill in ts transistion point history info
			try
			{
				tsTPHist.setActionUserId(userAccountFacade.findUserByUsername(userModified));
			}
			catch (UserNotUniqueException e)
			{
				tsTPHist.setActionUserId(null);
			}

			tsTPHist.setActionDate(now);
			tsTPHist.setMaxTempBefore(tsTP.getMaxTemp());
			tsTPHist.setMaxTempAfter(tstpt.getMaxTemp());
			tsTPHist.setMinTempBefore(tsTP.getMinTemp());
			tsTPHist.setMinTempAfter(tstpt.getMinTemp());
			tsTPHist.setPrefCoolTempBefore(tsTP.getPrefCoolTemp());
			tsTPHist.setPrefCoolTempAfter(tstpt.getPrefCoolTemp());
			tsTPHist.setPrefHeatTempBefore(tsTP.getPrefHeatTemp());
			tsTPHist.setPrefHeatTempAfter(tstpt.getPrefHeatTemp());
			tsTPHist.setTemporaryFlag(newTP ? OpsCenterConstants.TRUE : OpsCenterConstants.FALSE);
			tsTPHist.setTpTimeBefore(tsTP.getTpTime());
			tsTPHist.setTpTimeAfter(tstpt.getTpTime());
			tsTPHist.setHoldStatus(tstpt.getHoldStatus());

			// fill in TSTAT transition point info
			tsTP.setProgramId(program);
			tsTP.setEsiTstatId(esiFacade.findEsiTstatByEsiTstatId(tstpt.getEsiTstatId()));
			tsTP.setTpTime(tstpt.getTpTime());
			tsTP.setTemporaryFlag(newTP ? OpsCenterConstants.TRUE : OpsCenterConstants.FALSE);
			tsTP.setDeleteFlag(OpsCenterConstants.FALSE);
			tsTP.setActiveFlag(OpsCenterConstants.TRUE);
			tsTP.setMaxTemp(tstpt.getMaxTemp());
			tsTP.setMinTemp(tstpt.getMinTemp());
			tsTP.setPrefCoolTemp(tstpt.getPrefCoolTemp());
			tsTP.setPrefHeatTemp(tstpt.getPrefHeatTemp());
			tsTP.setTpTime(tstpt.getTpTime());
			tsTP.setDateCreated(now);
			tsTP.setUserModified(userModified);
			tsTP.setDateModified(now);
			tsTP.setUserCreated(userModified);
			tsTP.setHoldStatus(tstpt.getHoldStatus());

			try
			{
				// mode is auto, cool, heat, off
				opMode = deviceFacade.findOpModeByOpModeId(tsTP.getOpModeId().getOpModeId());
				tsTPHist.setOpModeBefore(opMode);
				opMode = deviceFacade.findOpModeByOpModeId(tstpt.getOpModeId());
				tsTP.setOpModeId(opMode);
				tsTPHist.setOpModeAfter(opMode);
			}
			catch (Exception e1)
			{
				e1.printStackTrace();
			}

			if (newTP)
			{
				// requested TP not found in DB create it now!!
				try
				{
					progFacade.createTstatTransitionPoint(tsTP);

					int tstpid = tsTP.getTstatTransitionPointId();
					if (tstpid == 0)
					{

						// TODO: this is temp fix for now... fix error
						if (logger.isErrorEnabled())
						{
							logger.error("Failed to retrieve TS TP ID after creation of TP for EsiTstatcId =  "
									+ tsTP.getEsiTstatId());
						}
						TstatTransitionPoint nts = progFacade
								.getTstatTransitionPointByEsiTstatId(
										tsTP.getEsiTstatId().getEsiTstatId()).get(0);
						tsTPHist.setTstatTransitionPointId(nts);
					}
					else
					{
						tsTPHist.setTstatTransitionPointId(tsTP);
					}

					progFacade.createTstatTransitionPointAttHistory(tsTPHist);
				}
				catch (Exception e)
				{
					if (logger.isErrorEnabled())
					{
						logger.error("Failed to insert Tstat TP in DB for Prog ID = "
								+ tsTP.getProgramId());
					}

					logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointTstat");

					throw new TransitionPointDBUpdateFailed(
							DefaultResources.PRG_ERR_CODE_TP_CREATE_FAILED,
							"Failed to create Tstat TP in DB for Prog ID = " + tsTP.getProgramId(),
							e);
				}
			}
			else
			{
				// tp already exist in db, just updated
				try
				{
					progFacade.updateTstatTransitionPoint(tsTP);
					tsTPHist.setTstatTransitionPointId(tsTP);
					progFacade.createTstatTransitionPointAttHistory(tsTPHist);
				}
				catch (Exception e)
				{
					if (logger.isErrorEnabled())
					{
						logger.error("Failed to update tstat TP in DB for Prog ID = "
								+ tsTP.getProgramId());
					}

					logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointTstat");

					throw new TransitionPointDBUpdateFailed(
							DefaultResources.PRG_ERR_CODE_TP_UPDATE_FAILED,
							"Failed to update Tstat TP in DB for Prog ID = " + tsTP.getProgramId(),
							e);
				}
			}
			// now send the override message
			esiEntry = getEsiForAccountId(tsTP.getProgramId().getAccountId().getAccountId());

			// Set the alarm. It gets cleared in OperationalMessagesGroupBean
			// when the ack (0x43) is received.
			Set<Integer> programs = new HashSet<Integer>();
			programs.add(program.getProgramId());

			if (esiEntry.getHardwareType().equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
			{
				GridStreamTstatProgramOverrideHandler gsProgramOverrideHandler = new GridStreamTstatProgramOverrideHandler();

				GSProgramOverrideTstatMessage gsProgramOverrideMessage = gsProgramOverrideHandler
						.getProgramPush(esiEntry, tsTP);

				gsProgramOverrideMessage.dump();

				// Set the alarm. It gets cleared in GridStreamMessagesGroupBean
				// when the ack (0xF2) is received.
				setProgPushAlarm(programs, esiEntry.getEsiId(),
						gsProgramOverrideMessage.getDeviceMacAddress(), null,
						gsProgramOverrideMessage.getOpCode());

				gwCacheKey = sendTstatOverrideMessageGS(gsProgramOverrideMessage, tsTP);
				logger.debug("***overrideTransitionPointTstat for GS Mac ID = "+ gwCacheKey);

				// DEV-1524
				// For GridStream we have to set program push time at a device level
				if (cacheManager.getGsTstatCache().isKeyInCache(gwCacheKey))
				{
					Element gsTstatElement = cacheManager.getGsTstatCache().get(gwCacheKey);
					GridStreamTstatCacheData gsTstatCache = null;
					gsTstatCache = (GridStreamTstatCacheData) gsTstatElement.getObjectValue();
					gsTstatCache.setPgrmRequestTime(new DateTime().getMillis());
					logger.debug("setPgrmRequestTime = "+ gsTstatCache.getPgrmRequestTime());
					cacheManager.getGsTstatCache().put(gsTstatElement);
				} else {
					logger.debug("Key not in cache for GS Mac ID = "+ gwCacheKey);
				}		
			}
			else
			{
				// Set the alarm. It gets cleared in
				// OperationalMessagesGroupBean when the ack (0x43) is received.
				int alarmId = setProgPushAlarm(programs, esiEntry.getEsiId(), null, null,
						OpsCenterConstants.OPCODE_SEND_OVERRIDE_PROGRAM);
				gwCacheKey = sendTstatOverrideMessageVPP(esiEntry, tsTP, alarmId);
			}

		}

		logger.debug("[ EXIT] UserProgramBean.overrideTransitionPointTstat");
	}

	/**
	 * @param esi
	 * @param tsTP
	 * @param alarmId
	 */
	private String sendTstatOverrideMessageVPP(Esi esi, TstatTransitionPoint tsTP,
			int alarmId) throws TransitionPointDBUpdateFailed
	{
		logger.info("[ENTER] String UserProgramBean.sendTstatOverrideMessageVPP(...)");

		TemporaryOverrideDataMessage ovrMsg = new TemporaryOverrideDataMessage();
		// ovrMsg.setProgramType(OpsCenterConstants.PROGRAM_TYPE_OVERRIDE);
		ovrMsg.setEsi_id(esi.getEsiMqId()); // Use MQ_ID for
											// messaging to GW
		// ovrMsg.setEventId(new
		// Long(gatewayMqId)); // Use MQ_ID
		// for
		// messaging to GW
		ovrMsg.setDeviceId(tsTP.getEsiTstatId().getDeviceMqId());
		ovrMsg.setCorrelationId(alarmId);

		// now set the client passed in op mode to new object to send to
		// GW
		TstatTransitionPointDev tstatDev = new TstatTransitionPointDev(tsTP);
		logger.debug("Pref Heating, Pref Cooling in centidegrees C =  "
				+ tstatDev.getPrefCoolTemp() + " " + tstatDev.getPrefHeatTemp());
		logger.debug("Tstat mode = " + tstatDev.getTstatMode());
		ovrMsg.setTstatTransitionPointDev(tstatDev);
		// ovrMsg.setCoRelationid(alarmId);

		EndpointIdentifier endpointIdentifier = esi.getEndpointIdentifierVPP();

		try
		{
			publisher.publish(endpointIdentifier, ovrMsg.getPayload());

			logger.debug("Override message sent for TSTAT ts and GW MQ id =  "
					+ endpointIdentifier.toString());
		}

		catch (PayloadAddException pae)
		{
			logger.info("[ EXIT] UserProgramBean.sendTstatOverrideMessageVPP");

			throw new TransitionPointDBUpdateFailed(
					DefaultResources.PRG_ERR_CODE_TP_MESSAGE_CREATION_FAILED,
					"Failed to create TP message for gateway for Prog ID = " + tsTP.getProgramId(),
					pae);
		}

		logger.info("[ EXIT] UserProgramBean.sendTstatOverrideMessageVPP");

		return endpointIdentifier.toString();
	}

	/**
	 * @param esi
	 * @param tsTP
	 * @param alarmId
	 */
	private String sendTstatOverrideMessageGS(
			GSProgramOverrideTstatMessage gsProgramOverrideMessage,
			TstatTransitionPoint tsTP) throws TransitionPointDBUpdateFailed
	{
		logger.info("[ENTER] String UserProgramBean.sendTstatOverrideMessageGS(...)");

		EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
		try
		{
			endpointIdentifier.setMacId(gsProgramOverrideMessage.getDeviceMacAddress());

			publisher.publish(endpointIdentifier, gsProgramOverrideMessage.getPayload());

			genericBean.createMessageResponse(
					gsProgramOverrideMessage.getMessageIdInUtcSecs(),
					gsProgramOverrideMessage.getDeviceMacAddress(), tsTP.getEsiTstatId().getEsiId()
							.getEsiId(), gsProgramOverrideMessage.getOpCode(), new DateTime(), null);

			logger.debug("Override message sent for TSTAT ts and Mac Addr =  "
					+ endpointIdentifier.toString());
		}
		catch (Exception exp)
		{
			logger.info("[ EXIT] UserProgramBean.sendTstatOverrideMessageGS");
			throw new TransitionPointDBUpdateFailed(
					DefaultResources.PRG_ERR_CODE_TP_MESSAGE_CREATION_FAILED,
					"Failed to create TP message for gateway for Prog ID = " + tsTP.getProgramId(),
					exp);
		}

		logger.info("[ EXIT] UserProgramBean.sendTstatOverrideMessageGS");

		return endpointIdentifier.toString();
	}

	/**
	 * Processes and builds the list of ProgramDayData for this account/esi.
	 *
	 * @param account
	 * @param esiId
	 * @param dateTimeZone
	 * @return List<ProgramDayData>
	 * @throws ProgramNotFoundException 
	 * @throws SchedulesNotFoundException 
	 */
	private ArrayList<ProgramDayData> processProgramData(Account account, int esiId,
			DateTimeZone dateTimeZone, boolean offsetForGW)
			throws AbstractOpsCenterException
	{
		List<Program> programList = progFacade.getProgramByAccountId(account.getAccountId());
		if (programList == null || programList.isEmpty())
		{
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"No Programs found for ESI=" + esiId);
		}

		ArrayList<ProgramDayData> programDayDataList = new ArrayList<ProgramDayData>();
		ProgramDaySchedule programDaySchedule = new ProgramDaySchedule(dateTimeZone,
				offsetForGW);

		// process the schedule of the currently active programs
		programDaySchedule.processAllPrograms(programList);

		// set transition point data
		for (ProgramDayData programDayData : programDaySchedule.getScheduledPrograms())
		{
			int programId = (int) programDayData.getPrgrmId();

			logger.debug("Processing programId " + programId);

			// now get the tstat transition point data from DB and move into
			// target object list
			TreeSet<TstatTransitionPointData> tstatTransPointSet = getTstatTransPoint(esiId,
					programId);
			programDayData.setTsatTransPoint(tstatTransPointSet);

			// now get the DC transition point data from DB and move into target
			// object list
			TreeSet<DcTransitionPointData> dcTransPointSet = getDcTransPoint(esiId, programId);
			programDayData.setDcTransPoint(dcTransPointSet);

			/*if (tstatTransPointSet.isEmpty() && dcTransPointSet.isEmpty())
			{
				throw new TransitionPointNotFoundException(
						"No TSTAT/DC Transition Points found for Program=" + programId);
			}*/

			logger.debug("Adding programId " + programDayData.getPrgrmId()
					+ " programDayData to list");
			programDayDataList.add(programDayData);
		}

		return programDayDataList;
	}

	private TreeSet<TstatTransitionPointData> getTstatTransPoint(int esiId,
			int programId) throws TransitionPointNotFoundException
	{

		TreeSet<TstatTransitionPointData> tpDataSet = new TreeSet<TstatTransitionPointData>();

		try
		{
			boolean foundInCache = true;
			List<EsiTstat> tstatList = null;
			List<?> resultList = null;
			// Using cache for DEV-165
			Results tstatResults = cacheManager.getCacheDataByEsiId(
					cacheManager.getGwTstatCache(), esiId);

			if (tstatResults == null || tstatResults.size() == 0)
			{
				foundInCache = false;
				tstatList = esiFacade.getEsiTstatByEsiId(esiId);
				if (tstatList == null || tstatList.isEmpty())
				{
					if (logger.isErrorEnabled())
					{
						logger.info("No ESI_TSTATs found for ESI=" + esiId);
					}
					return tpDataSet;
				}
			}

			if (foundInCache && tstatResults != null)
			{
				resultList = tstatResults.all();
			}
			else
			{
				resultList = tstatList;
			}

			if (resultList == null)
			{
				logger.error("resultList returned null in getTstatTransPoint()");
				return null;
			}

			for (Object tstatResult : resultList)
			{
				TreeSet<TstatTransitionPointDev> tpDevSet = new TreeSet<TstatTransitionPointDev>();
				int esiTstatId = -1;
				if (foundInCache)
				{
					Result result = (Result) tstatResult;
					esiTstatId = ((EsiTstatCacheData) result.getValue()).getEsiTstatId();
					logger.debug("getTstatTransPoint(): getting tstatResults from cache; id = "
							+ esiTstatId);
				}
				else
				{
					esiTstatId = ((EsiTstat) tstatResult).getEsiTstatId();
					logger.debug("getTstatTransPoint(): getting tstatResults from DB; id = "
							+ esiTstatId);
				}

				TstatTransitionPointData tstat = new TstatTransitionPointData();
				List<TstatTransitionPoint> sameTP = progFacade
						.getTstatTransitionPointByEsiTstatIdProgramId(esiTstatId, programId);

				if (sameTP == null || sameTP.isEmpty())
				{
					logger.info("NO TstatTransitionPoint ESI_TSTAT=" + esiTstatId);
					continue;
				}

				List<TstatTransitionPoint> programTransPoints = new ArrayList<TstatTransitionPoint>();
				for (TstatTransitionPoint tp : sameTP)
				{
					// filter out temporary or inactive Transition Points
					if (OpsCenterConstants.TRUE.equals(tp.getTemporaryFlag())
							|| !OpsCenterConstants.TRUE.equals(tp.getActiveFlag())
							|| tp.getProgramId().getProgramId() != programId)
					{
						continue;
					}
					programTransPoints.add(tp);
				}

				if (programTransPoints.isEmpty())
				{
					logger.info("NO TstatTransitionPoint for ESI_TSTAT=" + esiTstatId
							+ ", Program=" + programId);
					continue;
				}
				// logger.debug("\n\tESI_TSTAT="+esiTstatId
				// +", Program="+programId
				// +" has " +programTransPoints.size() +" Tstat TPs");

				TstatTransitionPoint t0 = programTransPoints.get(0);

				tstat.setProgramId(t0.getProgramId()); // NOTE: programId is
														// actually a Program
														// object
				tstat.setDeviceId(t0.getEsiTstatId().getDeviceMqId()); // Use
																		// MQ_ID
																		// for
																		// messaging
																		// to GW
				tstat.setTstatId(t0.getEsiTstatId().getTstatId().getTstatId()); // Set
																				// the
																				// actualTstat
																				// Is
				for (TstatTransitionPoint tp : programTransPoints)
				{

					TstatTransitionPointDev tsDev = new TstatTransitionPointDev(tp);
					tpDevSet.add(tsDev);
				}

				tstat.setTstatTransPointDev(tpDevSet);
				tpDataSet.add(tstat);
			}

			return tpDataSet;
		}
		catch (Exception e)
		{
			String errMsg = " Failed retrieving TSTAT Transition Points for ESI=" + esiId
					+ ": " + e;
			logger.error(errMsg);
			e.printStackTrace();
			throw new TransitionPointNotFoundException(errMsg);
		}
	}

	private TreeSet<DcTransitionPointData> getDcTransPoint(int esiId, int programId)
			throws TransitionPointNotFoundException
	{

		TreeSet<DcTransitionPointData> dcDataSet = new TreeSet<DcTransitionPointData>();

		try
		{
			boolean foundInCache = true;
			List<EsiDc> dcList = null;
			List<?> resultList = null;
			// Using cache for DEV-166
			Results dcResults = cacheManager.getCacheDataByEsiId(cacheManager.getGwDCCache(),
					esiId);

			if (dcResults == null || dcResults.size() == 0)
			{
				foundInCache = false;
				if (logger.isDebugEnabled())
				{
					logger.debug("No ESI_DCs found in cache for ESI=" + esiId);
				}
				dcList = esiFacade.getEsiDcByEsiId(esiId);
				if (dcList == null || dcList.isEmpty())
				{
					if (logger.isErrorEnabled())
					{
						logger.error("No ESI_DCs found for ESI=" + esiId);
					}
					return dcDataSet;
				}
			}

			if (foundInCache && dcResults != null)
			{
				resultList = dcResults.all();
			}
			else
			{
				resultList = dcList;
			}

			if (resultList == null)
			{
				logger.error("resultList returned null in getDcTransPoint()");
				return null;
			}

			for (Object dcResult : resultList)
			{
				// KRMT-3016 Move this inside loop so it is reset each time,
				// otherwise each DC gets all DC TP's
				TreeSet<DCTransitionPointDev> dcDevSet = new TreeSet<DCTransitionPointDev>();

				int esiDcId = -1;
				String deviceType = "";

				if (foundInCache)
				{
					Result result = (Result) dcResult;
					esiDcId = ((EsiDcCacheData) result.getValue()).getEsiDcId();
					deviceType = ((EsiDcCacheData) result.getValue()).getDeviceType();
					logger.debug("getDcTransPoint(): getting dcResults from cache, devType; esiDcId = " + deviceType);

				}
				else
				{
					esiDcId = ((EsiDc) dcResult).getEsiDcId();
					deviceType = ((EsiDc) dcResult).getDeviceTypeId().getDeviceTypeName();
					logger.debug("getDcTransPoint(): getting dcResults from DB; esiDcId = "
							+ esiDcId);
				}

				// filter out any DC other than WaterHeater, PoolPump and
				// Irrigation Pump and AC_SWITCH
				if (!OpsCenterConstants.DC_WATER_HEATER.equals(deviceType)
						&& !OpsCenterConstants.DC_POOL_PUMP.equals(deviceType)
						&& !OpsCenterConstants.DC_IRRIGATION_PUMP.equals(deviceType)
						&& !OpsCenterConstants.DC_CROP_HEAT.equals(deviceType)
						&& !OpsCenterConstants.DC_GENERATOR.equals(deviceType)
						&& !OpsCenterConstants.DC_STORAGE_WATER_HEATER.equals(deviceType)
						&& !OpsCenterConstants.DC_STORAGE_HEAT.equals(deviceType)
						&& !OpsCenterConstants.DC_ELECTRIC_VEHICLE_CHARGER.equals(deviceType)
						&& !OpsCenterConstants.DC_ELECTRIC_VEHICLE_CHARGER_STORAGE.equals(deviceType))
				{
					continue;
				}

				DcTransitionPointData dc = new DcTransitionPointData();
				List<DcTransitionPoint> sameDC = progFacade
						.getDcTransitionPointByEsiDcId(esiDcId);

				if (sameDC == null || sameDC.isEmpty())
				{
					continue;
				}

				List<DcTransitionPoint> programTransPoints = new ArrayList<DcTransitionPoint>();
				for (DcTransitionPoint tp : sameDC)
				{
					// filter out temporary or inactive Transition Points
					// as well as points that aren't in the current program
					if (OpsCenterConstants.TRUE.equals(tp.getTemporaryFlag())
							|| OpsCenterConstants.FALSE.equals(tp.getActiveFlag())
							|| tp.getProgramId().getProgramId() != programId)
					{
						continue;
					}

					programTransPoints.add(tp);
				}

				if (programTransPoints.isEmpty())
				{
					continue;
				}
				// logger.debug("\n\tESI_DC="+esiDcId +", Program="+programId
				// +" has " +programTransPoints.size() +" DC TPs");

				DcTransitionPoint d0 = programTransPoints.get(0);

				dc.setProgramId(d0.getProgramId()); // NOTE: programId is
													// actually a Program object
				dc.setDeviceId(d0.getEsiDcId().getDeviceMqId()); // Use MQ_ID
																	// for
																	// messaging
																	// to GW
				dc.setDcId(d0.getEsiDcId().getDcId().getDcId()); // The actual
																	// device id

				for (DcTransitionPoint newDc : programTransPoints)
				{
					DCTransitionPointDev dcDev = new DCTransitionPointDev();
					dcDev.setActiveFlag(newDc.getActiveFlag());
					dcDev.setDeleteFlag(newDc.getDeleteFlag());
					dcDev.setPowerStatusFlag(newDc.getPowerStatusFlag());
					dcDev.setTemporaryFlag(newDc.getTemporaryFlag());
					dcDev.setTpStartTime(newDc.getTpTime());
					dcDev.setActiveFlag(newDc.getActiveFlag());

					dcDevSet.add(dcDev);
				}
				dc.setDcTransPointDev(dcDevSet);
				dcDataSet.add(dc);
			}

			return dcDataSet;
		}
		catch (Exception e)
		{
			String errMsg = " Failed retrieving ESI_DCs for ESI=" + esiId + ": " + e;
			logger.error(errMsg);
			e.printStackTrace();
			throw new TransitionPointNotFoundException(errMsg);
		}
	}

	/**
	 * Converts UTC <code>localDate</code> midnight to the timestamp as shown by a user's wall clock,
	 * changing between the Daylight Saving Time and Standard Time depending on the time of the year
	 * and user's location, <code>userDateTimeZone</code>
	 * 
	 * @param localDate LocalDate
	 * @param userDateTimeZone DateTimeZone
	 * @return  long millisecs
	 */
	private long toUserWallTime(LocalDate localDate, DateTimeZone userDateTimeZone)
	{

		// NOTE: per Dr.Bill, startTime=Wed Feb 2 00:00:00 2011 is in the future
		// and
		// should be a UTC encoding of midnight local time: Tue Feb 1 00:05:00
		// 2011
		DateTime startOfLocalDay = localDate.toDateTimeAtStartOfDay(userDateTimeZone);
		long localWallTime = startOfLocalDay.getMillis();

		logger.debug("LocalDateTime: " + startOfLocalDay + ", in DateTimeZone: "
				+ userDateTimeZone.getID() + ", localWallTime=" + localWallTime);

		return localWallTime;
	}

	/**
	 * Converts farenheit temp value provided to celcius and returns value in
	 * centidegrees (*100)   (was decigrees (*10))
	 * 
	 * @author Bill Rodriguez
	 */
	public static int convertTempForGW(int farenheitTemp)
	{
		return Math.round(5f / 9 * (farenheitTemp - 32) * 100);
	}

	/**
	 * 
	 * @param accId
	 * @return
	 */
	private Esi getEsiForAccountId(int accId)
	{
		List<Esi> esiList = esiFacade.getEsiByAccountId(accId);
		if (esiList == null)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("No ESI configured for Account Id : " + accId);
				return null;
			}

			return null;
		}
		// must be at least 1 esi in list poonam??(all esi for acc must have
		// same GW id??)
		return esiList.get(0);
	}

	/**
	 * Overwrite device settings for a given Program with values provided in
	 * model object. deviceId can be either TSTAT or DC device and programID
	 * must correspond to that deviceID
	 * 
	 * @param int- esiID
	 * @param int - programID
	 * @returns ProgramDeviceSettingModel an object containg the DC settings or
	 *          Tstat settings
	 * @throws InvalidDeviceProgIDException
	 */

	
	public void copyDeviceProgramSettings(int esiID, int programID,
			ProgramDeviceSettingModel pgmModel) throws AbstractOpsCenterException
	{

		logger.info("Entering copyDeviceProgramSettings()");

		if (esiID == 0 || programID == 0)
		{

			logger.debug("Null dev or prog id received " + esiID + " " + programID);

			if (esiID == 0)
			{
				throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"ESI not found for id " + esiID);
			}
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"Program not found for id " + programID);

		}
		progFacade.findProgramByProgramId(programID);

		DateTime now = new DateTime();
		String userModified = userLoginBean.whoAmI();

		if (pgmModel.getDcTransitionPointCollection() != null
				&& pgmModel.getDcTransitionPointCollection().size() > 0)
		{

			EsiDc devdc = esiFacade.findEsiDcByEsiDcId(esiID);
			if (devdc == null)
			{
				logger.debug("No DC device found in DB for device Id :  " + esiID);
				throw new InvalidDeviceProgIDException(DefaultResources.ACC_ERR_CODE_DC_NOT_FOUND,
						"No DC device found in DB for device Id :  " + esiID);
			}
			// passed in device id is a DC --go ahead
			// DC device requested for copy
			List<DcTransitionPoint> devtp = progFacade.getDcTransitionPointByEsiDcId(devdc
					.getEsiDcId());
			List<DCTransitionPointModel> dcList = pgmModel.getDcTransitionPointCollection();
			for (DCTransitionPointModel dc : dcList)
			{
				for (DcTransitionPoint tpdb : devtp)
				{
					tpdb.setPowerStatusFlag(dc.getPowerStatusFlag());
					tpdb.setTemporaryFlag(OpsCenterConstants.FALSE);
					tpdb.setTpTime(dc.getTpTime());
					tpdb.setDateModified(now);
					tpdb.setUserModified(userModified);
					try
					{
						progFacade.updateDcTransitionPoint(tpdb);
					}
					catch (Exception e)
					{
						e.printStackTrace();
					}
				}
			}
		}
		else
		{
			if (pgmModel.getTstatTransitionPointCollection() == null
					|| pgmModel.getTstatTransitionPointCollection().size() == 0)
			{
				// now this is not good, we have no DCs and no Tstat TP set in
				// object-- bad client..get out...
				logger.debug("No Valid TPs received from client for ESI id = " + esiID);
				throw new InvalidDeviceProgIDException(DefaultResources.ACC_ERR_CODE_TP_NOT_FOUND,
						"No Valid TPs received from client for ESI id = " + esiID);
			}
			// this is for Tstats
			EsiTstat devtstat = esiFacade.findEsiTstatByEsiTstatId(esiID);
			if (devtstat == null)
			{
				logger.debug("No Tstat found in DB for ESI id :  " + esiID);
				throw new InvalidDeviceProgIDException(
						DefaultResources.ACC_ERR_CODE_TSTAT_NOT_FOUND,
						"No Tstat found in DB for ESI id = " + esiID);
			}
			// passed in device id is a Tstat --go ahead
			// Tstat device requested for copy
			List<TstatTransitionPoint> devtp = progFacade
					.getTstatTransitionPointByEsiTstatId(devtstat.getEsiTstatId());
			List<TstatTransitionPointModel> TstatList = pgmModel
					.getTstatTransitionPointCollection();

			for (TstatTransitionPointModel dc : TstatList)
			{
				for (TstatTransitionPoint tstatDB : devtp)
				{

					tstatDB.setTpTime(dc.getTpTime());
					tstatDB.setMaxTemp(dc.getMaxTemp());
					tstatDB.setMinTemp(dc.getMinTemp());
					tstatDB.setPrefCoolTemp(dc.getPrefCoolTemp());
					tstatDB.setPrefHeatTemp(dc.getPrefHeatTemp());
					tstatDB.setDateModified(now);
					tstatDB.setUserModified(userModified);
					OpMode mode = progFacade.findOpModeByOpModeId(dc.getOpModeId());
					// mode.setOpModeName(dc.getOpModeName());
					tstatDB.setOpModeId(mode);
					//TP that are not Override must not have HOLD set
					tstatDB.setHoldStatus(OpsCenterConstants.FALSE);
					try
					{
						progFacade.updateTstatTransitionPoint(tstatDB);
					}
					catch (Exception e)
					{
						e.printStackTrace();
					}
				}
			}

		}

		logger.info("Exiting copyDeviceProgramSettings()");
	}

	/**
	 * Retrieves programs device setting for current time using the requested
	 * device and program id. deviceId can be either TSTAT or DC device and
	 * programID must correspond to that deviceID
	 * 
	 * @param int- deviceID
	 * @param int - programID
	 * @returns ProgramDeviceSettingModel an object containg the account ID for
	 *          the program and DC settings or Tstat settings
	 * @throws InvalidDeviceProgIDException
	*/

	// TODO: Only works if Program.schedByRangeFlag is True, should it work for
	// ProgramScheduleDayMap too?
	
	public ProgramDeviceSettingModel getDeviceProgramSettings(int esiId, int programID)
			throws AbstractOpsCenterException
	{

		logger.info("Entering getDeviceProgramSettings()");
		List<DCTransitionPointModel> dcList = new ArrayList<DCTransitionPointModel>();
		List<TstatTransitionPointModel> tstatList = new ArrayList<TstatTransitionPointModel>();

		if (esiId == 0 || programID == 0)
		{

			logger.debug("Null dev or prog id received " + esiId + " " + programID);
			if (esiId == 0)
			{
				throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"ESI not found for id " + esiId);
			}
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"Program not found for id " + programID);
		}

		EsiDc dc = esiFacade.findEsiDcByEsiDcId(esiId);
		EsiTstat tstat = esiFacade.findEsiTstatByEsiTstatId(esiId);

		if (dc == null && tstat == null)
		{
			// passed in devid is not dc and not tstat-- stop--throw exception
			logger.debug("deviceId received is not DC and not Tstat, not allowed");
			// need to release tmpl object--how to do??
			throw new InvalidDeviceProgIDException(DefaultResources.ACC_ERR_CODE_INVALID_TYPE,
					"DeviceId received is not DC and not Tstat, not allowed");
		}

		Program program = progFacade.findProgramByProgramId(programID);
		ProgramDeviceSettingModel tmpl = new ProgramDeviceSettingModel();
		Account account = program.getAccountId();
		tmpl.setAccountId(account.getAccountId());

		DateTimeZone tz = DateTimeZone.getDefault(); // TODO: FIX?
		LocalDate date = new LocalDate(tz);

		if (dc != null)
		{
			// dev requested is not tstat, must be DC
			List<DcTransitionPoint> dcTp = progFacade.getDcTransitionPointByEsiDcIdDateRange(
					dc.getEsiDcId(), programID, date);

			if (dcTp != null && dcTp.size() != 0)
			{

				for (DcTransitionPoint tp : dcTp)
				{

					if (!tp.getEsiDcId().getDeviceTypeId().getDeviceTypeName()
							.equals(OpsCenterConstants.DC_HVAC))
					{

						DCTransitionPointModel newDc = new DCTransitionPointModel();
                        newDc.setPowerStatusFlag(tp.getPowerStatusFlag());
                        newDc.setProgramId(tp.getProgramId().getProgramId());
                        newDc.setEsiDcId(tp.getEsiDcId().getEsiDcId());
                        newDc.setTpTime(tp.getTpTime());
                        newDc.setDeviceType(tp.getEsiDcId().getDeviceTypeId().getDeviceTypeName());
                        newDc.setActiveFlag(tp.getActiveFlag());
                        newDc.setDeleteFlag(tp.getDeleteFlag());
                        
						dcList.add(newDc);
					}
				}
				tmpl.setDcTransitionPointCollection(dcList);
			}
		}

		// now lets see if requested device is Tstat TODO: could be both?
		if (tstat != null)
		{
			// dev requested is tstat
			List<TstatTransitionPoint> tstatTp = progFacade
					.getTstatTransitionPointByEsiTstatIdDateRange(tstat.getEsiTstatId(), programID,
							date);
			if (tstatTp != null && tstatTp.size() != 0)
			{

				for (TstatTransitionPoint tp : tstatTp)
				{
					OpMode mode = progFacade.findOpModeByOpModeId(tp.getOpModeId()
							.getOpModeId());
					TstatTransitionPointModel newTstat = new TstatTransitionPointModel();
					newTstat = setTPModelData(newTstat, tp, mode);

					tstatList.add(newTstat);
				}
				tmpl.setTstatTransitionPointCollection(tstatList);
			}

		}

		logger.info("Exitng getDeviceProgramSettings()");

		return tmpl;

	}
	
	private TstatTransitionPointModel setTPModelData (TstatTransitionPointModel newTstat, TstatTransitionPoint tstat, OpMode mode) {

		newTstat.setTpId(tstat.getTstatTransitionPointId());
		newTstat.setProgramId(tstat.getProgramId().getProgramId());
		newTstat.setTpTime(tstat.getTpTime());
		newTstat.setMaxTemp(tstat.getMaxTemp());
		newTstat.setMinTemp(tstat.getMinTemp());
		newTstat.setPrefCoolTemp(tstat.getPrefCoolTemp());
		newTstat.setPrefHeatTemp(tstat.getPrefHeatTemp());
		newTstat.setEsiTstatId(tstat.getEsiTstatId().getEsiTstatId());
		newTstat.setOpModeId(mode.getOpModeId());
		newTstat.setOpModeName(mode.getOpModeName());
		newTstat.setActiveFlag(tstat.getActiveFlag());
		newTstat.setDeleteFlag(tstat.getDeleteFlag());
		newTstat.setTempFlag(tstat.getTemporaryFlag());
		return newTstat;
	}
	
	

	/**
	 * Updates a programs device setting as requested by the client. It could be
	 * either a DC device or a Tstat device but never both.
	 * 
	 * @param int- deviceID
	 * @param int - programID
	 * @returns ProgramDeviceSettingModel an object containg the account ID for
	 *          the program and DC settings or Tstat settings
	 * @throws InvalidDeviceProgIDException
	 */
	
	public void updateDeviceProgramSettings(int esiID, int programID,
			ProgramDeviceSettingModel pgmModel) throws AbstractOpsCenterException
	{

		logger.info("Entering updateDeviceProgramSettings()");

		if (esiID == 0 || programID == 0)
		{

			logger.debug("Null dev or prog id received " + esiID + " " + programID);

			if (esiID == 0)
			{
				throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"ESI not found for id " + esiID);
			}
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"Program not found for id " + programID);
		}

		DcTransitionPoint tp = null;
		String userModified = userLoginBean.whoAmI();
		DateTime now = new DateTime();

		if (pgmModel.getDcTransitionPointCollection() != null
				&& pgmModel.getDcTransitionPointCollection().size() > 0)
		{
			// DC device requested
			List<DCTransitionPointModel> dcList = pgmModel.getDcTransitionPointCollection();
			for (DCTransitionPointModel dc : dcList)
			{

				tp = progFacade.findDcTransitionPointByTpId(dc.getTpId());
				tp.setPowerStatusFlag(dc.getPowerStatusFlag());
				tp.setTpTime(dc.getTpTime());
				// tp.setProgramId(dc.getProgramId());
				tp.setProgramId(progFacade.findProgramByProgramId(dc.getProgramId()));
				tp.setUserModified(userModified);
				tp.setDateModified(now);
			}
			try
			{
				progFacade.updateDcTransitionPoint(tp);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}
		else
		{
			if (pgmModel.getTstatTransitionPointCollection() == null
					|| pgmModel.getTstatTransitionPointCollection().size() == 0)
			{
				// now this is not good, we have no DCs and no Tstat TP set in
				// object-- bad client..get out...
				logger.debug("No Valid TPs received from client for deviceId = " + esiID);
				throw new InvalidDeviceProgIDException(DefaultResources.ACC_ERR_CODE_TP_NOT_FOUND,
						"No Valid TPs received from client for ESI id = " + esiID);
			}
			// this is for Tstats
			TstatTransitionPoint tpt = null;

			List<TstatTransitionPointModel> TstatList = pgmModel
					.getTstatTransitionPointCollection();
			for (TstatTransitionPointModel dc : TstatList)
			{

				tpt = progFacade.findTstatTransitionPointByTpId(dc.getTpId());
				tpt.setTpTime(dc.getTpTime());
				tpt.setMaxTemp(dc.getMaxTemp());
				tpt.setMinTemp(dc.getMinTemp());
				tpt.setPrefCoolTemp(dc.getPrefCoolTemp());
				tpt.setPrefHeatTemp(dc.getPrefHeatTemp());
				OpMode mode = progFacade.findOpModeByOpModeId(dc.getOpModeId());
				// mode.setOpModeName(dc.getOpModeName());
				tpt.setOpModeId(mode);
				tpt.setUserModified(userModified);
				tpt.setDateModified(now);
				tpt.setHoldStatus(OpsCenterConstants.FALSE);
			}
			try
			{
				progFacade.updateTstatTransitionPoint(tpt);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
			logger.info("Exiting updateDeviceProgramSettings()");
		}

	}

	/**
	 * Retrieves the default values used during new user program creation so
	 * client can fill in default values to the prompts user sees during
	 * creation. The values are hard coded in the DB.
	 * 
	 * @returns HashMap<String, String> containing the property name and
	 *          property value
	 */

	
	public HashMap<String, String> getProgramDefaultSettings()
	{

		logger.info("Entering getProgramDefaultSettings()");

		HashMap<String, String> prgMap = new HashMap<String, String>();

		List<UtilityProperty> prop = new ArrayList<UtilityProperty>();

		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.ALL_SLEEPING_COOLING_TEMP);
		prgMap.put(OpsCenterConstants.ALL_SLEEPING_COOLING_TEMP, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.COMFORTABLE_COOLING_TEMP);
		prgMap.put(OpsCenterConstants.COMFORTABLE_COOLING_TEMP, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.NOONE_HOME_COOLING_TEMP);
		prgMap.put(OpsCenterConstants.NOONE_HOME_COOLING_TEMP, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.ALL_SLEEPING_HEATING_TEMP);
		prgMap.put(OpsCenterConstants.ALL_SLEEPING_HEATING_TEMP, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.COMFORTABLE_HEATING_TEMP);
		prgMap.put(OpsCenterConstants.COMFORTABLE_HEATING_TEMP, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.MAX_TOLERABLE_TEMP);
		prgMap.put(OpsCenterConstants.MAX_TOLERABLE_TEMP, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.BINARY_DEV_ALL_SLEEP_STATE);
		prgMap.put(OpsCenterConstants.BINARY_DEV_ALL_SLEEP_STATE, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.MIN_TOLERABLE_TEMP);
		prgMap.put(OpsCenterConstants.MIN_TOLERABLE_TEMP, prop.get(0).getValue());
		prop = genericFacade
				.getUtilityPropertyByKey(OpsCenterConstants.BINARY_DEV_NOONE_HOME_STATE);
		prgMap.put(OpsCenterConstants.BINARY_DEV_NOONE_HOME_STATE, prop.get(0).getValue());
		prop = genericFacade
				.getUtilityPropertyByKey(OpsCenterConstants.BINARY_DEV_RETURN_HOME_STATE);
		prgMap.put(OpsCenterConstants.BINARY_DEV_RETURN_HOME_STATE, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.BINARY_DEV_WAKEUP_STATE);
		prgMap.put(OpsCenterConstants.BINARY_DEV_WAKEUP_STATE, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.FIRST_PERSON_AWAKEN);
		prgMap.put(OpsCenterConstants.FIRST_PERSON_AWAKEN, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.LAST_PERSON_LEAVE);
		prgMap.put(OpsCenterConstants.LAST_PERSON_LEAVE, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.LAST_PERSON_LEAVE);
		prgMap.put(OpsCenterConstants.LAST_PERSON_LEAVE, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.FIRST_PERSON_RETURN);
		prgMap.put(OpsCenterConstants.FIRST_PERSON_RETURN, prop.get(0).getValue());
		prop = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.LAST_PERSON_SLEEP);
		prgMap.put(OpsCenterConstants.LAST_PERSON_SLEEP, prop.get(0).getValue());

		logger.info("Exiting getProgramDefaultSettings()");

		return prgMap;

	}

	/**
	 * Retrieves from the DB the user program dc and tstat transition points and
	 * schedules associated with requested program id
	 * 
	 * @returns UserProgramModel object containing all of the program data
	 * @throws ProgramNotFoundException
	 */
	
	@Override
	public UserProgramModel getProgram(int programId, Integer tenantId) throws ProgramNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering getProgram()");

		Program prog = progFacade.findProgramByProgramId(programId);

		if (prog == null)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("No valid program found in DB for program id : " + programId);
			}
			throw new ProgramNotFoundException(DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND,
					"No programs found for ID =  " + programId);
		}

		// KRMT-3552
		expireTempTransitionPoints(prog);

		UserProgramModel pm = Program2ProgramModel.transformProgramEntityToModel(prog,
				progFacade);

		logger.info("Exiting getProgram()");

		return pm;
	}

	/**
	 * Retrieves from the DB all of the currently active TP for tstats for the
	 * account number requested. Gets the currentl active program from the DB
	 * 
	 * @returns -List TstatTransitionPointModel object containing all of tstat
	 *          TP data
	 * @throws ProgramNotFoundException
	 */
	
	public List<Tstat> getAllActiveTsatSettings(String accountNumber)
			throws ProgramNotFoundException, AccountNumberNotFoundException
	{

		logger.info("Entering getAllActiveTsatSettings");

		List<Tstat> deviceTstatList = new ArrayList<Tstat>();

		Program program = null;

		List<Account> acc = userAccountFacade.getAccountByAccountNumber(accountNumber);
		if (acc == null || acc.size() == 0)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Error:  No valid account found in DB for account number  "
						+ accountNumber);
			}
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No account found for account # " + accountNumber);
		}
		if (acc.size() > 1)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Error:  More than 1 account found in DB for acc # :  "
						+ accountNumber);
			}
			return null;

		}
		Account account = acc.get(0);
		int accountId = account.getAccountId();
		logger.debug("account Id = " + accountId);

		// DateTimeZone dateTimeZone =
		// account.getTimezoneId().getDateTimeZone();
		DateTimeZone tz = DateTimeZone.getDefault(); // DODO: FIX?
		LocalDate currentDate = new LocalDate(tz);

		// get the current active program id
		List<Program> programList = progFacade.getActiveProgramByDateAccountId(accountId,
				currentDate);

		// get the default program if program list is empty
		if (programList.isEmpty())
		{
			program = progFacade.getDefaultProgram(accountId);
			// ///////////////////////////////////FIXME
			if (program == null)
			{
				throw new ProgramNotFoundException(
						DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
						"Default program not found for account # =  " + accountNumber);
			}
		}
		// the program list is not empty and there is an actie program
		else
		{
			program = programList.get(0);
		}

		int programId = program.getProgramId();

		List<TstatTransitionPoint> tstatTransitionPointList = progFacade
				.getTstatTransitionPointByProgramId(programId);

		Map<String, String> tstatIdTpIdMap = new HashMap<String, String>();

		if (!tstatTransitionPointList.isEmpty())
		{
			for (TstatTransitionPoint tstatTransitionPoint : tstatTransitionPointList)
			{
				tstatIdTpIdMap.put(tstatTransitionPoint.getEsiTstatId().getTstatId() + "",
						tstatTransitionPoint.getTstatTransitionPointId() + "");
			}
			// use the map above to populate the deviceTSTAT object list
			Iterator<String> mapIterator = tstatIdTpIdMap.keySet().iterator();
			while (mapIterator.hasNext())
			{
				int tstatId = Integer.parseInt(mapIterator.next());
				Tstat deviceTstat = deviceFacade.findTstatByTstatId(tstatId);
				deviceTstatList.add(deviceTstat);
			}
		}
		else
		{
			logger.debug("No TP found for DCs on programId = " + programId);
			return null;
		}

		return deviceTstatList;
	}

	/**
	 * Retrieves from the DB all of the currently active, non-deleted DCs
	 * excluding HVACs for the account number requested.
	 * 
	 * @returns -List EsiDcModel object containing all of EsiDc's
	 * @throws EsiNotFoundException
	 */

	
	public List<EsiDcModel> getDcDeviceListForAccount(int accountId, Integer tenantId)
			throws EsiNotUniqueException, EsiNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] List<EsiDcModel> UserProgramBean.getDcDeviceListForAccount(accountId = " + accountId + ")");

		List<EsiDc> listOfEsiDcDevicesForAccount = null;
		List<EsiDcModel> esiDcList = new ArrayList<EsiDcModel>();

		// get the esi id for account number..make sure there is only one esi
		// for an account
		List<Esi> esiList = esiFacade.getEsiByAccountId(accountId);
		boolean isAcctGS = true;
		if (!esiList.isEmpty() && esiList.size() == 1)
		{

			
			if (OpsCenterConstants.VERIZON_CELLULAR_DELIVERY_ID == esiList.get(0).getNetworkDeliveryId())
			{
				//this account is not gridstream.
				isAcctGS = false;
			}
			int esiId = esiList.get(0).getEsiId();

			// get the device list for the esi
			listOfEsiDcDevicesForAccount = esiFacade.getEsiDcByEsiId(esiId);
		}
		else

		{
			logger.error("No ESI found in DB for accountId = " + accountId);
			throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"ESI not found for account " + accountId);
		}

		logger.debug("Size of listOfEsiDc = " + listOfEsiDcDevicesForAccount.size());

		for (EsiDc esiDc : listOfEsiDcDevicesForAccount)
		{
			// only return DC's that are not an HVAC, are not virtual, are
			// Active, and not Deleted
			String deviceTypeName = esiDc.getDeviceTypeId().getDeviceTypeName();
			String virtual = esiDc.getVirtualFlag();
			if (!deviceTypeName.equals(OpsCenterConstants.DC_HVAC)
					&& !virtual.equals(OpsCenterConstants.ACTIVE_IND))
			{
				if (esiDc.isActive() && !esiDc.isDeleted())
				{
					EsiDcModel esiDcModel = createEsiDcModel(esiDc);
					retrieveRelayStatusFromCache(esiDcModel);
					
					logger.debug("mac address for esi dc id " + esiDcModel.getEsiDcId() + " is: " + esiDcModel.getDeviceMacId());
					
					//Don't bother getting the mac address if the account is not gridstream
					//HMBRD-339 No longer a need to do this since the createEsiDcModel will populate the mac address from the entity
					
//					if (isAcctGS)
//					{
//						// DEV-1582 Store the deviceMacId in the EsiDcModel now
//						Long devMac = retrieveDeviceMacIdForEsiDcId(esiDc.getEsiDcId());
//						if (devMac != null)
//						{
//							esiDcModel.setDeviceMacId(devMac);
//							logger.debug("found esiDc in DB esiDcId =  " + esiDc.getEsiDcId());
//
//						else
//						{
//							logger.error("MAC address not found in cache for ESI DC with esiDcId: "
//									+ esiDc.getEsiDcId());
//						}
//					}

					// DEV-1641 Check to see if this device is in an active
					// event
					esiDcModel.setInActiveCe(isDeviceInActiveEvent(esiDc.getEsiDcId()));
					esiDcModel.setInCeRequestedState(isDeviceInRequestedCeState(esiDc.getEsiDcId()));
					esiDcModel.setOptOutWindowStarttime(esiDc.getOptOutWindowStarttime());
					esiDcModel.setOptOutWindowEndtime(esiDc.getOptOutWindowEndtime());

					esiDcList.add(esiDcModel);
				}
			}
		}

		logger.info("[ EXIT] UserProgramBean.getDcDeviceListForAccount");

		return esiDcList;
	}
	
	public EsiDcModel createEsiDcModel(EsiDc esiDc)
	{
		EsiDcModel model = new EsiDcModel();
		model.setEsiDcId(esiDc.getEsiDcId());
		model.setEsiId(esiDc.getEsiId().getEsiId());
		model.setDcId(esiDc.getDcId().getDcId());
		model.setDeviceMacId(esiDc.getDeviceMacId());
		model.setName(esiDc.getName());
		model.setDeviceTypeId(esiDc.getDeviceTypeId().getDeviceTypeId());
		model.setDeviceTypeName(esiDc.getDeviceTypeId().getDeviceTypeName());
		model.setRelayId(esiDc.getRelayId());
		return model;
	}
	
	private EsiTstatModel createEsiTstatModel(EsiTstat esiTstat)
	{
		EsiTstatModel model = new EsiTstatModel();
		model.setEsiTstatId(esiTstat.getEsiTstatId());
		model.setName(esiTstat.getName());
		model.setDeviceMacId(esiTstat.getDeviceMacId());
		model.setEsiDcId(esiTstat.getEsiDcId().getEsiDcId());
		return model;
	}

	/**
	 * @param esiDcId
	 * @return
	 */
	 
	/**
	 * Fetches and updates the status of the relay in the cache for this esiDcModel,
	 * along with the timestamp for the latest read
	 *
	 * @param esiDcModel
	 * @throws EsiDcNotFoundException
	 */
	private void retrieveRelayStatusFromCache(EsiDcModel esiDcModel)
	{
		logger.info("[ENTER] void UserProgramBean.retrieveRelayStatusFromCache(esiDcId = " + esiDcModel.getEsiDcId() + ")");

		EsiDcCacheData esiDcCache = null;
		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), esiDcModel.getEsiDcId());

		if (esiDcResults == null || esiDcResults.size() == 0)
		{
			logger.error("No EsiDcCacheData found in cache for esiDcId = " + esiDcModel.getEsiDcId());
			logger.info("[ EXIT] UserProgramBean.retrieveRelayStatusFromCache");
			return;
		}

		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCache = (EsiDcCacheData)esiDcResult.getValue();
			esiDcModel.setRelayStatus((byte)esiDcCache.getRelayStatus());
			esiDcModel.setLatestReadingTimeStamp(new DateTime(esiDcCache.getReadingTime()));
		}
		esiDcResults.discard();
		logger.info("[ EXIT] UserProgramBean.retrieveRelayStatusFromCache");
	}
	
	public boolean isDeviceInRequestedCeState(int esiDcId)
	{
		EsiDcCacheData esiDcCache = null;

		logger.info("[ENTER] boolean UserProgramBean.isDeviceInRequestedCeState( " + esiDcId + " )");

		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(
				cacheManager.getGwDCCache(), esiDcId);

		if (esiDcResults.size() == 0)
		{
			logger.info("esiDcResults.size() = " + esiDcResults.size() +
					", not found in Cache, return false");
			logger.info("[ EXIT] UserProgramBean.isDeviceInRequestedCeState( " + esiDcId + " ) = false");
			return false;
		}

		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCache = (EsiDcCacheData) esiDcResult.getValue();
			// the device is in an active event if the endTime is still 0 (event
			// still going) and the ceId isn't 0

			if (esiDcCache.getDcMode() == 9 &&
					OpsCenterConstants.FALSE.equals(esiDcCache.getOptOutFlag()))
			{
				// dev has not opted out, no need to try and add it back, just
				// return here...

				logger.debug("this dev is in requested CE state, returning true");
				logger.info("[ EXIT] UserProgramBean.isDeviceInRequestedCeState( " + esiDcId + " ) = true");
				return true;
			}
		}
		esiDcResults.discard();
		logger.info("[ EXIT] UserProgramBean.isDeviceInRequestedCeState( " + esiDcId + " ) = false");
		return false;
	}
	
	public boolean isDeviceInActiveEvent(int esiDcId)
	{
		EsiDcCacheData esiDcCache = null;

		logger.info("[ENTER] boolean UserProgramBean.isDeviceInActiveEvent( " + esiDcId + " )");

		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(
				cacheManager.getGwDCCache(), esiDcId);

		if (esiDcResults.size() == 0)
		{
			logger.info("esiDcResults.size() = " + esiDcResults.size() +
					", not found in CeDeviceCache, return false");
			logger.info("[ EXIT] UserProgramBean.isDeviceInActiveEvent( " + esiDcId + " ) = false");
			return false;
		}

		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCache = (EsiDcCacheData) esiDcResult.getValue();
			// the device is in an active event if the endTime is still 0 (event
			// still going) and the ceId isn't 0

			if (esiDcCache.getCeId() != 0 &&
					OpsCenterConstants.FALSE.equals(esiDcCache.getOptOutFlag()))
			{
				// dev has not opted out, no need to try and add it back, just
				// return here...

				logger.debug("this dev still in CE, returning true");
				logger.info("[ EXIT] UserProgramBean.isDeviceInActiveEvent( " + esiDcId + " ) = true");
				return true;
			}
		}
		esiDcResults.discard();
		logger.info("[ EXIT] UserProgramBean.isDeviceInActiveEvent( " + esiDcId + " ) = false");
		return false;
	}

	/**
	 * Retrieves from the DB all of the currently active, non-deleted TSTATs for
	 * the account number requested.
	 * 
	 * @returns -List EsiDcModel object containing all of EsiDc's
	 * @throws EsiNotFoundException
	 */

	@Override
	public List<EsiTstatModel> getTstatDeviceListForAccount(int accountId, Integer tenantId)
			throws EsiNotUniqueException, EsiNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] List<EsiTstatModel> UserProgramBean.getTstatDeviceListForAccount(" + accountId + ")");

		List<EsiTstat> listOfEsiTstatDevicesForAccount = null;
		List<EsiTstatModel> esiTstatList = new ArrayList<EsiTstatModel>();

		// get the esi id for account number..make sure there is only one esi
		// for an account
		List<Esi> esiList = esiFacade.getEsiByAccountId(accountId);
		boolean isAcctGS = true;
		if (!esiList.isEmpty() && esiList.size() == 1)
		{
			if (OpsCenterConstants.VERIZON_CELLULAR_DELIVERY_ID == esiList.get(0).getNetworkDeliveryId())
			{
				//this account is not gridstream.
				isAcctGS = false;
			}
			int esiId = esiList.get(0).getEsiId();

			// get the device list for the esi
			listOfEsiTstatDevicesForAccount = esiFacade.getEsiTstatByEsiId(esiId);
		}
		else
		{
			logger.error("No ESI found  for accountId = " + accountId);
			throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"ESI not found for account " + accountId);
		}

		for (EsiTstat esiTstat : listOfEsiTstatDevicesForAccount)
		{
			// only return DC's that are not an HVAC, are Active, and not
			// deleted
			if (esiTstat.isActive() && !esiTstat.isDeleted())
			{
				EsiTstatModel esiTstatModel = new EsiTstatModel();
 				esiTstatModel.setEsiTstatId(esiTstat.getEsiTstatId());
				esiTstatModel.setName(esiTstat.getName());
				esiTstatModel.setEsiDcId(esiTstat.getEsiDcId().getEsiDcId());


				Long devMacId = retrieveDeviceMacIdForEsiDcId(esiTstat.getEsiDcId()
						.getEsiDcId());
				
				//Don't bother getting the mac address if the account is not gridstream
				if (isAcctGS)
				{
					devMacId = retrieveDeviceMacIdForEsiDcId(esiTstat.getEsiDcId()
							.getEsiDcId());

					if (devMacId != null)
					{
						// DEV-1582 Store the deviceMacId in the EsiTstatModel now
						esiTstatModel.setDeviceMacId(devMacId);
	
					}
					else
					{
						logger.error("MAC address not found in cache for ESI TSTAT with esiDcId: "
								+ esiTstat.getEsiDcId());
					}
				}

				// DEV-2427 Check to see if this TSTAT is in an active CE
				esiTstatModel.setInActiveCe(isDeviceInActiveEvent(esiTstat.getEsiDcId().getEsiDcId()));
				esiTstatModel.setInCeRequestedState(isDeviceInRequestedCeState(esiTstat.getEsiDcId().getEsiDcId()));
				esiTstatModel.setOptOutWindowStartTime(esiTstat.getEsiDcId().getOptOutWindowStarttime());
				esiTstatModel.setOptOutWindowEndTime(esiTstat.getEsiDcId().getOptOutWindowEndtime());
				esiTstatModel.setDeviceTypeId(esiTstat.getEsiDcId().getDeviceTypeId().getDeviceTypeId());

				esiTstatList.add(esiTstatModel);
			}
		}

		logger.info("[ EXIT] UserProgramBean.getTstatDeviceListForAccount");

		return esiTstatList;
	}

	/**
	 * Retrieves from the DB all of the currently active DCs excluding HVACs for
	 * the account number requested.
	 * 
	 * @returns -List EsiDcModel object containing all of EsiDc's
	 * @throws ProgramNotFoundException
	 */
	
	public List<Dc> getAllActiveDCSettings(String accountNumber)
			throws ProgramNotFoundException, AccountNumberNotFoundException
	{

		return null;

	}

	/**
	 * @author David Conklin this method is used to return a list of all the
	 *         dates for the month day schedule passed in the maps for month and
	 *         day
	 * 
	 * @param Map
	 *            monthScheduleMap
	 * @param Map
	 *            dayScheduleMap
	 * 
	 * @return List<Calendar>
	 * 
	 * 
	 */
	
	public List<Calendar> getDatesForDaysFromMap(Map<String, String> monthScheduleMap,
			Map<String, String> dayScheduleMap, int year)
			throws SchedulesNotFoundException
	{

		List<Calendar> listOfAllDates = null;

		if (!monthScheduleMap.isEmpty() && !dayScheduleMap.isEmpty())
		{

			listOfAllDates = new ArrayList<Calendar>();

			Iterator<String> monthIterator = monthScheduleMap.keySet().iterator();

			while (monthIterator.hasNext())
			{
				String month = monthIterator.next();
				Iterator<String> dayIterator = dayScheduleMap.keySet().iterator();

				while (dayIterator.hasNext())
				{
					String day = dayIterator.next();

					listOfAllDates = Day.getAllDatesForDayInMonthYear(Integer.parseInt(day),
							Integer.parseInt(month), year, listOfAllDates);
				}
			}
		}
		else
		{
			throw new SchedulesNotFoundException(DefaultResources.PRG_ERR_CODE_SCHEDULE_MAP_EMPTY,
					"The Month schedule map or day schedule Map has not entries");
		}

		return listOfAllDates;
	}

	

	/**
	 * Return the Name and the ID of the Default program set for the account
	 * Throw an exception if there is not default program set for the account
	 * 
	 * @param accountId
	 * @return
	 * @throws ProgramNotFoundException
	 */

	@Override
	public UserProgramModel getDefaultProgramForAccount(int accountId, Integer tenantId)
			throws ProgramNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		Program program = progFacade.getDefaultProgram(accountId);

		if (program == null)
		{
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
					"Default program not found for account ID =  " + accountId);
		}

		// 2011-Mar-03 Brockman - Previously the default program was returning a
		// half-populated model.
		return getProgram(program.getProgramId(), tenantId);
	}

	/**
	 * Retrieves tstat reading for current time using the requested tstat id.
	 * 
	 * @param int- deviceID
	 * @returns TstatCurrentReadingModel an object containg the current reading
	 *          data for the tstat
	 * @throws AbstractOpsCenterException
	 */

	private void checkCellularTstatTime2(DateTime tstatReadingDateTime, DateTime lastPeriodicReadDateTime,DateTime tstatReadingResponseDateTime,
											DateTime messageOutgoingDateTime, DateTime pushDateTime, DateTime messageOutgoingSndLatestDateTime, TstatCurrentReadingModel newCRM,
											int accountId, int esiTstatId, Esi esi) throws AbstractOpsCenterException {
										
		
		// first check if latest reading is fresher than periodic read time
		if (tstatReadingDateTime.isAfter(lastPeriodicReadDateTime))
		{
			// reading is pretty fresh, now check if reading_response is
			// fresher
			if (tstatReadingResponseDateTime.isAfter(tstatReadingDateTime))
			{
				if (messageOutgoingDateTime.isAfter(tstatReadingResponseDateTime))
				{
					// logger.debug("Program Push Pending1. Unable to find fresh data for accountId: "+accountId+" esiTstatId: "+esiTstatId);
					// // There is a Program Push pending, so throw an error
					// that the data is not ready
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					// "Program Push Pending. Unable to find fresh data for accountId: "
					// + accountId +
					// " esiTstatId: " + esiTstatId);

					// KRMT-4068 Instead of just blindly sending back
					// DataNotAvailableException, determine if still
					// reasonable
					// to wait

					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiTstatId: " + esiTstatId);
						logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiTstatId: " + esiTstatId);
					}

					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					newCRM.setPendingStatus(OpsCenterConstants.TRUE);
					newCRM.setOpsDateCreated(tstatReadingResponseDateTime);
				}
				else
				{
					// No pending Program Push, so return the
					// reading_response
					newCRM.setOpsDateCreated(tstatReadingResponseDateTime);
				}
			}
			else
			{
				// reading is still fresher, but there could be a pending
				// Program Push

				// DEV-1524 did not handle equals case correctly. Show as
				// DataNotAvailableException.
				if (messageOutgoingDateTime.isAfter(tstatReadingDateTime)
						|| messageOutgoingDateTime.isEqual(tstatReadingDateTime))
				{
					// There is a Program Push pending, so throw an error
					// that
					// the data is not ready
					// logger.debug("Program Push Pending2. Unable to find fresh data for accountId: "+accountId+" esiTstatId: "+esiTstatId);
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					// "Program Push Pending. Unable to find fresh data for accountId: "
					// + accountId +
					// " esiTstatId: " + esiTstatId);

					// /KRMT-4068 Instead of just blindly sending back
					// DataNotAvailableException, determine if still
					// reasonable to wait

					logger.debug("getTstatCurrentReading - POSTPUSH READING ");
					logger.debug(" -" + tstatReadingDateTime);
					logger.debug(" -" + tstatReadingResponseDateTime);
					logger.debug(" -" + messageOutgoingDateTime);

					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiTstatId: " + esiTstatId);
						logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiTstatId: " + esiTstatId);
					}

					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					newCRM.setPendingStatus(OpsCenterConstants.TRUE);
					newCRM.setOpsDateCreated(tstatReadingDateTime);
				}
				else
				{
					// No pending Program Push, so return the reading
					logger.debug("getTstatCurrentReading - NORMAL READING ");
					logger.debug(" -" + tstatReadingDateTime);
					logger.debug(" -" + tstatReadingResponseDateTime);
					logger.debug(" -" + messageOutgoingDateTime);
					newCRM.setOpsDateCreated(tstatReadingDateTime);
				}
			}
		}
		else
		{
			// reading is pretty old, so see if reading_response is fresher
			// than
			// periodic read time
			if (tstatReadingResponseDateTime.isAfter(lastPeriodicReadDateTime))
			{
				if (messageOutgoingDateTime.isAfter(tstatReadingResponseDateTime))
				{
					// There is a Program Push pending, so throw an error
					// that
					// the data is not ready
					// logger.debug("Program Push Pending3. Unable to find fresh data for accountId: "+accountId+" esiTstatId: "+esiTstatId);
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					// "Program Push Pending. Unable to find fresh data for accountId: "
					// + accountId +
					// " esiTstatId: " + esiTstatId);
					// KRMT-4068 Instead of just blindly sending back
					// DataNotAvailableException, determine if still
					// reasonable
					// to wait

					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiTstatId: " + esiTstatId);
						logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiTstatId: " + esiTstatId);
					}
					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					newCRM.setPendingStatus(OpsCenterConstants.TRUE);
					newCRM.setOpsDateCreated(tstatReadingResponseDateTime);
				}
				else
				{
					// No pending Program Push, so return the
					// reading_response
					newCRM.setOpsDateCreated(tstatReadingResponseDateTime);
				}
			}
			else
			{
				// everything is older than periodic read time
				// there could be a pending Program Push
				if (messageOutgoingDateTime.isAfter(lastPeriodicReadDateTime))
				{
					// There is a Program Push pending, so determine if it
					// has
					// been long enough for response
					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiTstatId: " + esiTstatId);
						logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiTstatId: " + esiTstatId);
					}
					if (tstatReadingDateTime != OpsCenterConstants.REALLY_LONG_AGO_DATETIME)
					{
						newCRM.setPendingStatus(OpsCenterConstants.TRUE);
						newCRM.setOpsDateCreated(tstatReadingDateTime);
					}
					else
					{
						logger.debug("No Readings Exist. Unable to find data for accountId: "
								+ accountId + " esiTstatId: " + esiTstatId);
						logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
								"No Readings Exist. Unable to find data for accountId: "
										+ accountId + " esiTstatId: " + esiTstatId);
					}
				}
				// there could be a pending Send Latest

				if (messageOutgoingSndLatestDateTime.isAfter(lastPeriodicReadDateTime))
				{ // Should this be messageLastOpsReceivedDateTime instead
					// of
					// lastPeriodicReadDateTime??

					// There is a Send Latest pending, so throw an error
					// that
					// the data is not ready
					logger.debug("Send Latest Pending. Unable to find fresh data for accountId: "
							+ accountId + " esiTstatId: " + esiTstatId);
					logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
					throw new DataNotAvailableException(
							DefaultResources.ACC_ERR_CODE_NO_DATA_SEND_LATEST,
							"Send Latest Pending1. Unable to find fresh data for accountId: "
									+ accountId + " esiTstatId: " + esiTstatId);
				}
				// otherwise just give them the latest reading, no
				// matter how old
				if (tstatReadingDateTime != OpsCenterConstants.REALLY_LONG_AGO_DATETIME)
				{
					newCRM.setOpsDateCreated(tstatReadingDateTime);
				}
				else
				{
					logger.debug("No Readings Exist. Unable to find data for accountId: "
							+ accountId + " esiTstatId: " + esiTstatId);
					logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
					throw new DataNotAvailableException(
							DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
							"No Readings Exist. Unable to find data for accountId: "
									+ accountId
									+ " esiTstatId: " + esiTstatId);
				}
			}
		}
		// DEV-1524 end hard break here b/w normal gw flow and GS flow
	}
		
	private ReadingTimesData checkCellularTstatTime1(int esiTstatId, int accountId, long gwId, Esi esi,DateTime tstatReadingDateTime,  DateTime tstatReadingResponseDateTime,
										 DateTime messageOutgoingDateTime, DateTime messageOutgoingSndLatestDateTime, DateTime messageLastOpsReceivedDateTime,
										 TstatCurrentReadingModel newCRM,EsiTstat tstat) throws AbstractOpsCenterException{
										
		
		// start compute base timings for normal gw
			logger.debug("getTstatCurrentReading(): compute base timings for normal gw");
			String gwCacheKey = new Long(gwId).toString();
			String devKey = null;

			ReadingTimesData readingTimeData = new ReadingTimesData();
			int esiMQId = esi.getEsiMqId();
			//TODO-CR KRMT-6479
			String esiDevKey = getCacheKey(esiMQId, gwCacheKey);
			EsiCacheData esiCache = null;
			if (cacheManager.getGwEsiCache().isKeyInCache(esiDevKey))
			{
				Element esiElement = cacheManager.getGwEsiCache().get(esiDevKey);
				esiCache = (EsiCacheData) esiElement.getObjectValue();
				if (esiCache.getGwReadingTime() > 0)
				{
					readingTimeData.setTstatReadingDateTime(new DateTime(esiCache.getGwReadingTime()));
				}
				if (esiCache.getPgrmResponseTime() > 0)
				{
					readingTimeData.setTstatReadingResponseDateTime(new DateTime(esiCache.getPgrmResponseTime()));
				}
				if (esiCache.getPgrmRequestTime() > 0)
				{
					readingTimeData.setMessageOutgoingDateTime(new DateTime(esiCache.getPgrmRequestTime()));
				}
				if (esiCache.getSndLatestRequestTime() > 0)
				{
					readingTimeData.setMessageOutgoingSndLatestDateTime(new DateTime(
							esiCache.getSndLatestRequestTime()));
				}
				if (esiCache.getLastMqRecdTime() != null)
				{
					readingTimeData.setMessageLastOpsReceivedDateTime(esiCache.getLastMqRecdTime());
				}
			}
			else
			{
				logger.debug("getTstatCurrentReading - No Cache key for esiId ");
				logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
				throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
						"No Readings Exist. Unable to find data for accountId: " + accountId
								+ " esiTstatId: " + esiTstatId);
			}

			int deviceId = tstat.getDeviceMqId();
			//TODO-CR KRMT-6479
			devKey = getCacheKey(deviceId, gwCacheKey);
			// KRMT-1167 - Performance Optimizations. We should in most cases
			// find a value in the cache.
			if (cacheManager.getGwTstatCache().isKeyInCache(devKey))
			{
				Element element = cacheManager.getGwTstatCache().get(devKey);
				EsiTstatCacheData tstatCache = (EsiTstatCacheData) element.getObjectValue();
				logger.debug("getTstatCurrentReading(): Tstat: " + tstatCache);
				// Throw the exception with the new reason code here
				if (tstatCache == null || tstatCache.getTstatMode() == null
						|| tstatCache.getTstatMode().equals(OpsCenterConstants.TSTAT_UNAVAIL))
				{
					logger.debug("Tstat data unavailable for esiTstatId " + esiTstatId);
					throw new DataNotAvailableException(
							DefaultResources.ACC_ERR_CODE_NO_DATA_INVALID_DATA,
							"No valid data available for tstat. Unable to find data for accountId: "
									+ accountId + " esiTstatId: " + esiTstatId);
				}
				newCRM.setSetPoint(tstatCache.getSetPoint());
				newCRM.setRoomTemp(tstatCache.getRoomTemp());
				newCRM.setOpModeId(OpsCenterConstants.opModeNameToIdMap.get(
						tstatCache.getTstatMode()).intValue());
				newCRM.setOpModeName(tstatCache.getTstatMode());
			}

					// end compute base timings for normal gw
			return readingTimeData;
	}
	
	@Override
	public TstatCurrentReadingModel getTstatCurrentReading(int accountId, int esiTstatId, Integer tenantId)
			throws AbstractOpsCenterException
	{
		logger.info("[ENTER] TstatCurrentReadingModel UserProgramBean.getTstatCurrentReading(accountId = "
				+ accountId + ", esiTstatId = " + esiTstatId + ")");

		Account account;

		TstatCurrentReadingModel newCRM = new TstatCurrentReadingModel();
		String gatewayStatus = null;
		// DEV-282 add a GS flag
		boolean gs = false;

		// get account number
		try
		{
			account = userAccountFacade.findAccountByAccountId(accountId);
		}
		catch (Exception ex)
		{
			logger.error("No account found in DB for AccountId = " + accountId + ". Exception: "
					+ ex);
			logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
			throw new AccountNotFoundException(accountId);
		}

		// get the EsiTstatId
		if (esiTstatId == 0)
		{
			logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
			throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"ESI not found for id " + esiTstatId);
		}
		logger.debug(">>>>>>>>>>>>>>>>>>>>>>>> esiTstatId ----- "+esiTstatId);
		EsiTstat tstat = esiFacade.findEsiTstatByEsiTstatId(esiTstatId);
		logger.debug(">>>>>>>>>>>>>>>>>>>>>>>> tstat ----- "+tstat);
		if (tstat == null)
		{
			logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
			logger.debug(">>>>>>>>>>SAFWEAF>>>>>>>sdad>>>>>>>   EXCEPTION THROWING    ");
			throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"ESI not found for id " + esiTstatId);
		}
		// // get the Esi for the account
		// List<Esi> esiList = esiFacade.getEsiByAccountId(accountId);
		// if (esiList == null || esiList.size() == 0) {
		// throw new AccountNotFoundException(
		// DefaultResources.ACC_ERR_ESI_NOT_FOUND,
		// "Unable to find any ESI's associated with accountId: "
		// + accountId);
		// } else if (esiList.size() > 1) {
		// throw new AccountNotFoundException(
		// DefaultResources.ACC_ERR_ESI_NOT_FOUND,
		// "Unable to resolve account to a single ESI: count = "
		// + esiList.size());
		// }

		// KRMT-6401 simplified way to get ESI
		Esi esi = tstat.getEsiId();

		// get the EsiGateway and check status
		// Esi esi = esiFacade.findEsiByEsiId(esiId);
		long gwId = esi.getEsiGatewayId().getGatewayMqId();
		int esiId = esi.getEsiId();

		logger.debug("getTstatCurrentReading(): esiId: " + esiId + "; deliveryId: "
				+ esi.getNetworkDeliveryId());

		// DEV-282 check esi's NetworkDeliveryId to see if GRIDSTREAM; if so,
		// this is a GS device; set flag
		if (esi.getNetworkDeliveryId() == OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID)
		{
			gs = true;
			logger.info("Tstat is a GS device.");
		}

		// DEV-282 only check GW status if not a GS device
		if (!gs)
		{
			gatewayStatus = userLoginBean.getGatewayStatus(accountId);
			if (!gatewayStatus.equalsIgnoreCase(OpsCenterConstants.GATEWAY_STATUS_NORMAL))
			{
				logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
				throw new EsiGatewayNotNormalMode(DefaultResources.ACC_ERR_CODE_NOT_NORMAL_MODE,
						"Gateway not in normal mode for esi: " + esi.getEsiId());
			}
		}
		else
		{
			// TODO: what to do when GS is in manage mode?
			// bill says there will be a status at esi level
		}

		newCRM.setEsiTstatId(esiTstatId);

		// get current TP
		UserProgramNameModel upnm = getProgramsForDashBoard(account.getAccountId());
		DateTimeZone datetimeZone = account.getTimezoneId().getDateTimeZone();
		LocalTime accountLocalTime = new LocalTime(datetimeZone);
		// active program id
		int programId = upnm.getUserProgramNameCollection().get(0).getProgramId();

		TstatTransitionPoint tp = getCurrentTstatTransitionPoint(esiTstatId, programId,
				accountLocalTime);

		logger.debug(String.format("currently active TP for TSTAT %d: %d, programId : %d, tempTP: %s, holdStatus: %s",
				esiTstatId, tp.getTstatTransitionPointId(), tp.getProgramId().getProgramId(), tp.getTemporaryFlag(), tp.getHoldStatus()));
		// set temp boolean
		newCRM.setTempTP(tp.getTemporaryFlag());

		// KRMT-4068set Pending status
		newCRM.setPendingStatus(OpsCenterConstants.FALSE);

		// set up DateTime variables
		DateTime tstatReadingDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime tstatReadingResponseDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime messageOutgoingDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime messageOutgoingSndLatestDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime messageLastOpsReceivedDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		// DEV-282 hard break here b/w normal gw flow and GS flow
		ReadingTimesData readingTimeData;
		if (!gs)
		{
			//rdrn-244-reduce if complexity
			readingTimeData = checkCellularTstatTime1(esiTstatId, accountId, gwId, esi,tstatReadingDateTime, tstatReadingResponseDateTime,
					                messageOutgoingDateTime, messageOutgoingSndLatestDateTime, messageLastOpsReceivedDateTime,
					                newCRM,tstat);
			
			messageOutgoingDateTime = readingTimeData.getMessageOutgoingDateTime();
			tstatReadingDateTime = readingTimeData.getTstatReadingDateTime();
			tstatReadingResponseDateTime = readingTimeData.getTstatReadingResponseDateTime();
			messageOutgoingSndLatestDateTime = readingTimeData.getMessageOutgoingSndLatestDateTime();
			messageLastOpsReceivedDateTime = readingTimeData.getMessageLastOpsReceivedDateTime();
			
		}
		else
		{
			// start compute base timings for GS device
			logger.debug("getTstatCurrentReading(): compute base timings for GS device");
			// //DEV-282 get info from GS cache

			String devMac = Long.toString(tstat.getDeviceMacId());

			if (!cacheManager.getGsTstatCache().isKeyInCache(devMac))
			{
				logger.debug("Key not in cache for devMac = " + devMac);
				logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
				throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
						"No Readings Exist. Unable to find data for accountId: " + accountId
								+ " esiTstatId: " + esiTstatId + " devMac: " + devMac);
			}

			// DEV-282: methods added to GridStreamTstatCacheData to duplicate
			// those in EsiCacheData and EsiTstatCacheData
			if (cacheManager.getGsTstatCache().isKeyInCache(devMac))
			{
				Element gsTstatElement = cacheManager.getGsTstatCache().get(devMac);
				GridStreamTstatCacheData gsTstatCache = null;
				gsTstatCache = (GridStreamTstatCacheData) gsTstatElement.getObjectValue();
				logger.debug("getTstatCurrentReading(): GS esi_tstat_id: " + gsTstatCache.getEsiTstatId());

				if (gsTstatCache.getGwReadingTime() > 0)
				{
					tstatReadingDateTime = new DateTime(gsTstatCache.getGwReadingTime());
				}
				if (gsTstatCache.getPgrmResponseTime() > 0)
				{
					tstatReadingResponseDateTime = new DateTime(gsTstatCache.getPgrmResponseTime());
				}
				if (gsTstatCache.getPgrmRequestTime() > 0)
				{
					messageOutgoingDateTime = new DateTime(gsTstatCache.getPgrmRequestTime());
				}
				if (gsTstatCache.getSndLatestRequestTime() > 0)
				{
					messageOutgoingSndLatestDateTime = new DateTime(
							gsTstatCache.getSndLatestRequestTime());
				}
				if (gsTstatCache.getLastMqRecdTime() != null)
				{
					messageLastOpsReceivedDateTime = gsTstatCache.getLastMqRecdTime();
				}

				newCRM.setSetPoint(gsTstatCache.getSetPoint());
				newCRM.setRoomTemp(gsTstatCache.getRoomTemp());
				// must deliver hold status for each TP to UI
				newCRM.setHoldStatus(tp.getHoldStatus());

				String modeString = gsTstatCache.getTstatMode();
				if (modeString != null)
				{
					Long modeId = OpsCenterConstants.opModeNameToIdMap.get(modeString);
					if (modeId != null)
					{
						newCRM.setOpModeId(modeId.intValue());
						newCRM.setOpModeName(gsTstatCache.getTstatMode());
					}
					// Incorrect opmode string - set to unavail
					else
					{
						newCRM.setOpModeId(OpsCenterConstants.opModeNameToIdMap.get(
								OpsCenterConstants.TSTAT_UNAVAIL).intValue());
						newCRM.setOpModeName(OpsCenterConstants.TSTAT_UNAVAIL);
						logger.error("getTstatCurrentReading(): Invalid GridStream Tstat Opmode: "
								+ modeString);
					}
				}
				// No opmode string - set to unavail
				else
				{
					newCRM.setOpModeId(OpsCenterConstants.opModeNameToIdMap.get(
							OpsCenterConstants.TSTAT_UNAVAIL).intValue());
					newCRM.setOpModeName(OpsCenterConstants.TSTAT_UNAVAIL);
					logger.error("getTstatCurrentReading(): No GridStream Tstat Opmode");
				}
			}
			else
			{
				logger.debug("Key not in cache for devMac = " + devMac);
				logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
				throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
						"No Readings Exist. Unable to find data for accountId: " + accountId
								+ " esiTstatId: " + esiTstatId + " devMac: " + devMac);
			}
		}
		// end compute base timings for GS device

		if (tstatReadingDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME
				&& tstatReadingResponseDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME
				&& messageOutgoingDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME
				&& messageOutgoingSndLatestDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME)
		{
			logger.debug("getTstatCurrentReading - No valid Cached Data found for esiId " + esiId);
			logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
			throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
					"No Readings Exist. Unable to find data for accountId: " + accountId
							+ " esiTstatId: " + esiTstatId);
		}

		// handle bad data in setpoint, etc.

		DateTime lastPeriodicReadDateTime = new DateTime()
				.minusMinutes(OpsCenterConstants.PERIODIC_READ_MINUTES);
		// KRMT-1907 variable for round-trip time
		DateTime pushDateTime = new DateTime()
				.minusMinutes(OpsCenterConstants.PUSH_RESPONSE_MINUTES);

		// BEGIN PROCESSING
		// DEV-1524 hard break here b/w normal gw flow and GS flow
		if (!gs)
		{
			//rdrn-244 -- reduce if complexity
			checkCellularTstatTime2(tstatReadingDateTime,lastPeriodicReadDateTime,tstatReadingResponseDateTime,
					               messageOutgoingDateTime, pushDateTime, messageOutgoingSndLatestDateTime,newCRM,
					               accountId, esiTstatId,esi);
		}
		else
		{
			DateTime pushDateTimeGS = messageOutgoingDateTime
					.plusMinutes(OpsCenterConstants.PUSH_RESPONSE_MINUTES_GS);

			logger.debug("getTstatCurrentReading - GS READING : " + new DateTime());
			logger.debug("pushDateTimeGS : " + pushDateTimeGS);
			logger.debug("tstatReadingDateTime : " + tstatReadingDateTime);
			logger.debug("tstatReadingDateTime.isBefore(pushDateTimeGS) : "
					+ tstatReadingDateTime.isBefore(pushDateTimeGS));
			logger.debug("tstatReadingResponseDateTime : " + tstatReadingResponseDateTime);
			logger.debug("messageOutgoingDateTime : " + messageOutgoingDateTime);
			logger.debug("messageOutgoingSndLatestDateTime : " + messageOutgoingSndLatestDateTime);
			logger.debug("messageLastOpsReceivedDateTime : " + messageLastOpsReceivedDateTime);
			logger.debug("tstatReadingDateTime : " + tstatReadingDateTime);
			logger.debug("setPoint : " + newCRM.getSetPoint());
			logger.debug("roomTemp : " + newCRM.getRoomTemp());
			logger.debug("opModeId : " + newCRM.getOpModeId());
			logger.debug("opModeName : " + newCRM.getOpModeName());
			logger.debug("holdStatus : " + newCRM.getHoldStatus());

			// if the response is before the request time and the request was
			// pushed within the last five mins then display the pending push
			// message
			if (tstatReadingResponseDateTime.isBefore(messageOutgoingDateTime)
					&& (new DateTime()).isBefore(pushDateTimeGS))
			{
				logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
						+ accountId + " esiTstatId: " + esiTstatId);
				throw new DataNotAvailableException(
						DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
						"Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId +
								" esiTstatId: " + esiTstatId);
				//dev-2688-- do not throw exception here-- the prog push response
				//has taken longer than allowed to land-- so set the time value such that
				//the UI will put up generic "no data" message and begin polling"
			}
			else
			{
				newCRM.setOpsDateCreated(tstatReadingDateTime);
			}
			

			newCRM.setOpsDateCreated(tstatReadingDateTime);
		}
		// END PROCESSING

		// KRMT-3488 Check set point for really large number (ie bad read from
		// comp delay)
		// leveraging Program Push message
		if (newCRM.getSetPoint() > UserProgramBean.MAXIMUM_REALISTIC_TEMP)
		{
			logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");
			throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					"Compressor Delay. Unable to find fresh data for accountId: " + accountId
							+ " esiTstatId: " + esiTstatId);
		}

		logger.debug("newCRM for esiTstatId " + esiTstatId + " : " + newCRM);

		logger.info("[ EXIT] UserProgramBean.getTstatCurrentReading");

		return newCRM;
	}

	/**
	 * Retrieves dc reading for current time using the requested dc id.
	 * 
	 * @param int- deviceID
	 * @returns DcCurrentReadingModel an object containg the current reading
	 *          data for the dc
	 * @throws AbstractOpsCenterException
	 */

	private void processCellularDcReading(DateTime dcReadingDateTime, DateTime lastPeriodicReadDateTime, DateTime dcReadingResponseDateTime,DateTime messageOutgoingSndLatestDateTime,
										  DateTime messageOutgoingDateTime, DateTime pushDateTime, int accountId, int esiDcId, DcCurrentReadingModel newCRM,
										  Esi esi) throws AbstractOpsCenterException{
		

		// first check if latest reading is fresher than periodic read time
		if (dcReadingDateTime.isAfter(lastPeriodicReadDateTime))
		{
			// reading is pretty fresh, now check if reading_response is
			// fresher
			if (dcReadingResponseDateTime.isAfter(dcReadingDateTime))
			{
				// reading_response is fresher, but could still be pending
				// Program Push

				if (messageOutgoingDateTime.isAfter(dcReadingResponseDateTime))
				{
					// There is a Program Push pending, so throw an error
					// that
					// the data is not ready
					// logger.debug("Program Push Pending1. Unable to find fresh data for esiDcId: "
					// + esiDcId);
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					// "Program Push Pending. Unable to find fresh data for esiDcId: "
					// + esiDcId);
					// KRMT-4068 Instead of just blindly sending back
					// DataNotAvailableException, determine if still
					// reasonable
					// to wait

					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiDcId: " + esiDcId);
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiDcId: " + esiDcId);
					}
					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					newCRM.setPendingStatus(OpsCenterConstants.TRUE);
					newCRM.setOpsDateCreated(dcReadingResponseDateTime);
				}
				else
				{
					// No pending Program Push, so return the
					// reading_response
					newCRM.setOpsDateCreated(dcReadingResponseDateTime);
				}
			}
			else
			{
				// reading is still fresher, but there could be a pending
				// Program Push

				if (messageOutgoingDateTime.isAfter(dcReadingDateTime))
				{
					// There is a Program Push pending, so throw an error
					// that
					// the data is not ready
					// logger.debug("Program Push Pending2. Unable to find fresh data for esiDcId: "
					// + esiDcId);
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					// "Program Push Pending. Unable to find fresh data for esiDcId: "
					// + esiDcId);
					// KRMT-4068 Instead of just blindly sending back
					// DataNotAvailableException, determine if still
					// reasonable
					// to wait

					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiDcId: " + esiDcId);
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiDcId: " + esiDcId);
					}
					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					newCRM.setPendingStatus(OpsCenterConstants.TRUE);
					newCRM.setOpsDateCreated(dcReadingDateTime);
				}
				else
				{
					// No pending Program Push, so return the reading
					newCRM.setOpsDateCreated(dcReadingDateTime);
				}
			}
		}
		else
		{
			// reading is pretty old, so see if reading_response is fresher
			// than periodic read time
			if (dcReadingResponseDateTime.isAfter(lastPeriodicReadDateTime))
			{
				if (messageOutgoingDateTime.isAfter(dcReadingResponseDateTime))
				{
					// There is a Program Push pending, so throw an error
					// that
					// the data is not ready
					// logger.debug("Program Push Pending3. Unable to find fresh data for esiDcId: "
					// + esiDcId);
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
					// "Program Push Pending. Unable to find fresh data for esiDcId: "
					// + esiDcId);
					// KRMT-4068 Instead of just blindly sending back
					// DataNotAvailableException, determine if still
					// reasonable
					// to wait

					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{
						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending4. Unable to find fresh data for accountId: "
								+ accountId + " esiDcId: " + esiDcId);
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for accountId: "
										+ accountId + " esiDcId: " + esiDcId);
					}
					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					newCRM.setPendingStatus(OpsCenterConstants.TRUE);
					newCRM.setOpsDateCreated(dcReadingResponseDateTime);
				}
				else
				{
					// No pending Program Push, so return the
					// reading_response
					newCRM.setOpsDateCreated(dcReadingResponseDateTime);
				}
			}
			else
			{
				// everything is older than periodic read time
				if (messageOutgoingDateTime.isAfter(lastPeriodicReadDateTime))
				{
					// There is a Program Push pending, so determine if it
					// has been long enough for response
					if (messageOutgoingDateTime.isAfter(pushDateTime))
					{

						// still reasonable that response hasn't come back
						// yet
						// so throw an error that the data is not ready
						logger.debug("Program Push Pending4. Unable to find fresh data for esiDcId: "
								+ esiDcId);
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
								"Program Push Pending. Unable to find fresh data for esiDcId: "
										+ esiDcId);
					}
					// been too long, so either a failed response or comm
					// issues
					// throw new DataNotAvailableException(
					// DefaultResources.ACC_ERR_CODE_NO_DATA_FAILED_RESPONSE,
					// "Program Push Response Failed. Unable to verify Program Push for esiDcId: "
					// + esiDcId);
					// been too long, so either a failed response or comm
					// issues... send back the most recent with pending flag
					// set
					if (dcReadingDateTime != OpsCenterConstants.REALLY_LONG_AGO_DATETIME)
					{
						newCRM.setPendingStatus(OpsCenterConstants.TRUE);
						newCRM.setOpsDateCreated(dcReadingDateTime);
					}
					else
					{
						logger.debug("No Readings Exist. Unable to find fresh data for esiDcId: "
								+ esiDcId);
						throw new DataNotAvailableException(
								DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
								"No Readings Exist. Unable to find data for esiDcId: "
										+ esiDcId);
					}
				}
				// there could be a pending Send Latest
				// messageOutgoingDateTime =
				// getLatestMessageDateTime(mocSendLatest, esiGatewayId);
				// if
				// (messageOutgoingDateTime.isAfter(lastPeriodicReadDateTime))
				// {
				if (messageOutgoingSndLatestDateTime.isAfter(lastPeriodicReadDateTime))
				{ // Should this be messageLastOpsReceivedDateTime instead
					// of
					// lastPeriodicReadDateTime??
					// There is a Send Latest pending, so throw an error
					// that
					// the data is not ready
					logger.debug("Send Latest Pending. Unable to find fresh data for esiDcId: "
							+ esiDcId);
					throw new DataNotAvailableException(
							DefaultResources.ACC_ERR_CODE_NO_DATA_SEND_LATEST,
							"Send Latest Pending. Unable to find fresh data for esiDcId: "
									+ esiDcId);
				}

				// otherwise just give them the latest reading, no
				// matter how old
				if (dcReadingDateTime != OpsCenterConstants.REALLY_LONG_AGO_DATETIME)
				{
					newCRM.setOpsDateCreated(dcReadingDateTime);
				}
				else
				{
					logger.debug("No Readings Exist. Unable to find fresh data for esiDcId: "
							+ esiDcId);
					throw new DataNotAvailableException(
							DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
							"No Readings Exist. Unable to find data for esiDcId: " + esiDcId);
				}
			}
		}
	
		
	}
	
	@Override
	public DcCurrentReadingModel getDcCurrentReading(int esiDcId, Integer tenantId)
			throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] DcCurrentReadingModel UserProgramBean.getDcCurrentReading(" + esiDcId + ")");

		int accountId = 0;
		Account account;

		DcCurrentReadingModel newCRM = new DcCurrentReadingModel();
		String gatewayStatus = null;
		boolean gs = false;

		// get the EsiDcId
		if (esiDcId == 0)
		{
			throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"ESI not found for id " + esiDcId);
		}
		EsiDc dc = esiFacade.findEsiDcByEsiDcId(esiDcId);
		if (dc == null)
		{
			throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"ESI not found for id " + esiDcId);
		}

		// TODO: confirm this is a better way to get Esi
		Esi esi = dc.getEsiId();

		accountId = esi.getAccountId().getAccountId();
		long gwId = esi.getEsiGatewayId().getGatewayMqId();
		int esiId = esi.getEsiId();

		if (esi.getNetworkDeliveryId() == OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID)
		{
			gs = true;
			logger.info("DC is a GS device.");
		}
		if (!gs)
		{
			gatewayStatus = userLoginBean.getGatewayStatus(accountId);

			if (!gatewayStatus.equalsIgnoreCase(OpsCenterConstants.GATEWAY_STATUS_NORMAL))
			{
				throw new EsiGatewayNotNormalMode(DefaultResources.ACC_ERR_CODE_NOT_NORMAL_MODE,
						"Gateway not in normal mode for esi: " + esi.getEsiId());
			}
		}

		// get account number
		try
		{
			account = userAccountFacade.findAccountByAccountId(accountId);
		}
		catch (Exception ex)
		{
			logger.error("No account found in DB for AccountId = " + accountId + ". Exception: " + ex);
			throw new AccountNotFoundException(accountId);
		}

		newCRM.setEsiDcId(esiDcId);

		// get current TP
		UserProgramNameModel upnm = getProgramsForDashBoard(accountId);
		DateTimeZone datetimeZone = account.getTimezoneId().getDateTimeZone();
		LocalTime accountLocalTime = new LocalTime(datetimeZone);
		// active program id
		int programId = upnm.getUserProgramNameCollection().get(0).getProgramId();
		boolean isTemp = getCurrentDcTransitionPointIsTemp(esiDcId, programId,
				accountLocalTime);

		// set temp boolean
		newCRM.setTempTP(isTemp ? OpsCenterConstants.TRUE: OpsCenterConstants.FALSE);

		// KRMT-4068 set Pending status
		newCRM.setPendingStatus(OpsCenterConstants.FALSE);

		// set up DateTime variables
		DateTime dcReadingDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime dcReadingResponseDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime messageOutgoingDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime messageOutgoingSndLatestDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		DateTime messageLastOpsReceivedDateTime = OpsCenterConstants.REALLY_LONG_AGO_DATETIME;
		// Check for cached data
		String gwCacheKey = new Long(gwId).toString();
		String devKey = null;
		if (!gs)
		{

			int esiMQId = esi.getEsiMqId();
			//TODO-CR KRMT-6479
			String esiDevKey = getCacheKey(esiMQId, gwCacheKey);
			EsiCacheData esiCache = null;
			if (cacheManager.getGwEsiCache().isKeyInCache(esiDevKey))
			{
				Element esiElement = cacheManager.getGwEsiCache().get(esiDevKey);
				esiCache = (EsiCacheData) esiElement.getObjectValue();
				if (esiCache.getGwReadingTime() > 0)
				{
					dcReadingDateTime = new DateTime(esiCache.getGwReadingTime());
				}
				if (esiCache.getPgrmResponseTime() > 0)
				{
					dcReadingResponseDateTime = new DateTime(esiCache.getPgrmResponseTime());
				}
				if (esiCache.getPgrmRequestTime() > 0)
				{
					messageOutgoingDateTime = new DateTime(esiCache.getPgrmRequestTime());
				}
				if (esiCache.getSndLatestRequestTime() > 0)
				{
					messageOutgoingSndLatestDateTime = new DateTime(
							esiCache.getSndLatestRequestTime());
				}
				if (esiCache.getLastMqRecdTime() != null)
				{
					messageLastOpsReceivedDateTime = esiCache.getLastMqRecdTime();
				}
			}
			else
			{
				logger.debug("getDcCurrentReading - No Cache key for esiId " + esiId);
				throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
						"No Readings Exist. Unable to find data for accountId : " + accountId
								+ " esiDcId : " + esiDcId);
			}
		}
		else
		{
			// start compute base timings for GS device
			logger.debug("getDcCurrentReading(): compute base timings for GS device");
			// //DEV-282 get info from GS cache
			EsiDcCacheData gsDcCache = null;
			boolean foundMatch = false;			
			for(int i = 1 ; i <= 4 ; i++)
			{
				String cacheKey = buildLcsCacheKey(dc.getDeviceMacId(), (byte)i);
				
				if (cacheManager.getGwDCCache().isKeyInCache(cacheKey))
				{
					Element gsdcElement = cacheManager.getGwDCCache().get(cacheKey);
					gsDcCache = (EsiDcCacheData) gsdcElement.getObjectValue();
					if (gsDcCache.getEsiDcId() == esiDcId)
					{
						foundMatch = true;
						logger.debug("getDcCurrentReading(): GS dcId: (relay "+i+") " + gsDcCache.getEsiDcId()
						+ " relayStatus = " + gsDcCache.getRelayStatus());
						break;
					}
				}

			}
			
			if (!foundMatch) {
				
				throw new DataNotAvailableException(
						DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
						"No Readings Exist. Unable to find data for accountId : " + accountId
								+ " esidcId : " + esiDcId + " devMac : " + dc.getDeviceMacId());
			}

			if (gsDcCache == null)
			{
				logger.error("gsDcCache returned null in getDcCurrentReading()");
				return null;
			}
			if (gsDcCache.getRelayStatus() == OpsCenterConstants.INVALID_STATE)
			{
				logger.debug("Dc data unavailable for esiDcId " + esiDcId);
				throw new DataNotAvailableException(
						DefaultResources.ACC_ERR_CODE_NO_DATA_INVALID_DATA,
						"No valid data available. Unable to find data for accountId: " + accountId
								+ " esiDcId: " + esiDcId);
			}
			newCRM.setRelayStatus(gsDcCache.getRelayStatus());
			newCRM.setDeviceTypeId(OpsCenterConstants.deviceNameToTypeMap.get(
					gsDcCache.getDeviceType()).intValue());
			newCRM.setDeviceTypeName(gsDcCache.getDeviceType());

			if (gsDcCache.getReadingTime() > 0)
			{
				dcReadingDateTime = new DateTime(gsDcCache.getReadingTime());
			}
			if (gsDcCache.getPgrmResponseTime() > 0)
			{
				dcReadingResponseDateTime = new DateTime(gsDcCache.getPgrmResponseTime());
			}
			if (gsDcCache.getPgrmRequestTime() > 0)
			{
				messageOutgoingDateTime = new DateTime(gsDcCache.getPgrmRequestTime());
			}
			// TODO get this attributes in the cache and set them
			// properly(ran out of time)
//			if (gsDcCache.getSndLatestRequestTime() > 0)
//			{
//				messageOutgoingSndLatestDateTime = new DateTime(
//						gsDcCache.getSndLatestRequestTime());
//			}
//			if (gsDcCache.getLastMqRecdTime() != null)
//			{
//				messageLastOpsReceivedDateTime = gsDcCache.getLastMqRecdTime();
//			
//			}


		} 
		// end compute base timings for GS device

		if (dcReadingDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME
				&& dcReadingResponseDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME
				&& messageOutgoingDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME
				&& messageOutgoingSndLatestDateTime == OpsCenterConstants.REALLY_LONG_AGO_DATETIME)
		{
			logger.debug("getDcCurrentReading - No valid Cached Data found for esiId " + esiId);
			throw new DataNotAvailableException(DefaultResources.ACC_ERR_CODE_NO_DATA_NO_DATA,
					"No Readings Exist. Unable to find data for accountId: " + accountId
							+ " esiDcId: " + esiDcId);
		}
		//TODO-CR KRMT-6479
		int deviceId = dc.getDeviceMqId();
		devKey = getCacheKey(deviceId, gwCacheKey);
		// KRMT-1167 - Performance Optimizations. We should in most cases find a
		// value in the cache
		// and return.
		if (!gs)
		{
			if (cacheManager.getGwDCCache().isKeyInCache(devKey))
			{
				Element element = cacheManager.getGwDCCache().get(devKey);
				EsiDcCacheData esidcCache = (EsiDcCacheData) element.getObjectValue();
				// Throw the exception with the new reason code here
				if (esidcCache.getRelayStatus() == OpsCenterConstants.INVALID_STATE)
				{
					logger.debug("Dc data unavailable for esiDcId " + esiDcId);
					throw new DataNotAvailableException(
							DefaultResources.ACC_ERR_CODE_NO_DATA_INVALID_DATA,
							"No valid data available. Unable to find data for accountId: "
									+ accountId + " esiDcId: " + esiDcId);
				}
				newCRM.setRelayStatus(esidcCache.getRelayStatus());
				newCRM.setDeviceTypeId(OpsCenterConstants.deviceNameToTypeMap.get(
						esidcCache.getDeviceType()).intValue());
				newCRM.setDeviceTypeName(esidcCache.getDeviceType());
			}
		}

		// set up DateTime variables
		DateTime lastPeriodicReadDateTime = new DateTime()
				.minusMinutes(OpsCenterConstants.PERIODIC_READ_MINUTES);
		// KRMT-1907 variable for round-trip time
		DateTime pushDateTime = new DateTime()
				.minusMinutes(OpsCenterConstants.PUSH_RESPONSE_MINUTES);

		// BEGIN PROCESSING
		

		// DEV-1524 hard break here b/w normal gw flow and GS flow
		if (!gs)
		{
			processCellularDcReading(dcReadingDateTime,lastPeriodicReadDateTime,dcReadingResponseDateTime,messageOutgoingSndLatestDateTime,
					  messageOutgoingDateTime, pushDateTime, accountId, esiDcId,newCRM,esi);
		}
		else
		{
			DateTime pushDateTimeGS = messageOutgoingDateTime
					.plusMinutes(OpsCenterConstants.PUSH_RESPONSE_MINUTES_GS);

			logger.debug("getDcCurrentReading - GS READING : " + new DateTime());
			logger.debug("pushDateTimeGS : " + pushDateTimeGS);
			logger.debug("dcReadingDateTime : " + dcReadingDateTime);
			logger.debug("dcReadingDateTimeisBefore(pushDateTimeGS) : "
					+ dcReadingDateTime.isBefore(pushDateTimeGS));
			logger.debug("dcReadingResponseDateTime: " + dcReadingResponseDateTime);
			logger.debug("messageOutgoingDateTime : " + messageOutgoingDateTime);
			logger.debug("messageOutgoingSndLatestDateTime : " + messageOutgoingSndLatestDateTime);
			logger.debug("messageLastOpsReceivedDateTime : " + messageLastOpsReceivedDateTime);
			logger.debug("dcReadingDateTime : " + dcReadingDateTime);
			logger.debug("getRelayStatus : " + newCRM.getRelayStatus());

			// if the response is before the request time and the request was
			// pushed within the last five mins then display the pending push
			// message
			if (dcReadingDateTime.isBefore(messageOutgoingDateTime)
					&& (new DateTime()).isBefore(pushDateTimeGS))
			{
				logger.debug("Program Push Pending. Unable to find fresh data for accountId: "
						+ accountId + " esiDcId: " + esiDcId);
				throw new DataNotAvailableException(
						DefaultResources.ACC_ERR_CODE_NO_DATA_PROGRAM_PUSH,
						"Program Push Pending. Unable to find fresh data for accountId: "
								+ accountId + " esiDcId : " + esiDcId);
			}

			newCRM.setOpsDateCreated(dcReadingDateTime);
		}

		// END PROCESSING
		logger.info("Exiting getDcCurrentReading() modelData - relayStatus = "
				+ newCRM.getRelayStatus()
				+ " esiDcId = " + newCRM.getEsiDcId() + " pending status = "
				+ newCRM.getPendingStatus());

		return newCRM;
	}

	private static String buildLcsCacheKey(long devMac, byte relay)
	{
		StringBuffer id1 = new StringBuffer();
		return id1.append((Long) devMac).append(relay).toString().intern();
	}

	/**
	 * 2012-Jan-03, Brockman KRMT-5613: New Logic to deactivate a certain program that is currently running scheduled by range
	 * The user story is 'return early from Vacation'
	 *
	 * This is invoked by the UI Consumer Dashboard QuickBar 'Change Program' tile. 
	 * @param accountId
	 * @param programId
	 * @param userModified
	 * @return
	 * @throws ProgramNotFoundException
	 * @throws ProgramNotCurrentlyScheduledByRangeException (new)
	 * @throws AccountNumberNotFoundException
	 * @throws AbstractOpsCenterException
	 */

	/*
		// META CODE:
		
		// 1. Check and make sure this program by ID exists and is owned by user.

		// 2. Check and make sure this program by ID is scheduled by range
		//   If not, throw ProgramNotCurrentlyScheduledByRangeX ( PRG_ERR_CODE_PROGRAM_NOT_BY_RANGE  )

		// 3. Check and make sure this program by ID is currently running with an active schedule row.
		//   If not, throw ProgramNotCurrentlyScheduledByRangeX ( PRG_ERR_CODE_PROGRAM_NOT_CURRENTLY_SCHEDULED )

		// 4. Update this program ID's scheduled to set the end date to Today() - 1  (aka Yesterday)

		// NOTE = No Side Effect of pushing message. Caller must explicitly do a program push to gateway.
		*/

	@Override
	public UserProgramModel updateProgramToEndCurrentScheduleByRange(int accountId,
			int programId, String userModified, Integer tenantId) throws ProgramNotFoundException,
			AccountNumberNotFoundException, AbstractOpsCenterException,
			ProgramNotCurrentlyScheduledByRangeException
	{
		// To help the logs appear more sane.
		TenantContext.setCurrentTenant(tenantId);
		String errorPrefix = "[updateProgramsToEndCurrentScheduleByRange (" + accountId + ","
				+ programId + ", " + userModified + ")]";
		logger.info(errorPrefix + " start");

		Account account = null;
		Program program = null;

		// Look up account
		account = findAccountEntityByAccountID(accountId);
		if (account == null)
		{
			throw new AccountNumberNotFoundException(accountId + "", "Find Account By accountId ("
					+ accountId + ") returned null");
		}

		// Look up program - Probably is more efficient way to do it by ID, but
		// re-using plumbing to minimize risk
		List<Program> programs = findProgramEntitiesByAccountId(accountId);
		for (Program p : programs)
		{
			if (p.getProgramId() == programId && p.getAccountId().getAccountId() == accountId)
			{
				program = p;
			}
		}

		if (program == null)
		{
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT, "Program ID "
							+ programId + " is not owned by Account ID  " + accountId);
		}
		if (program.getDeleteFlag().equalsIgnoreCase(OpsCenterConstants.TRUE))
		{
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT, "Program ID "
							+ programId + " is marked as deleted, can no longer modify.");
		}

		// 2. Check and make sure this program by ID is scheduled by range
		// If not, throw ProgramNotCurrentlyScheduledByRangeX (
		// PRG_ERR_CODE_PROGRAM_NOT_BY_RANGE )

		if (program.getSchedByRangeFlag().equalsIgnoreCase(OpsCenterConstants.FALSE))
		{
			throw new ProgramNotCurrentlyScheduledByRangeException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_BY_RANGE, "ProgramId=" + programId
							+ " is not scheduled by range");
		}

		if (program.getDefaultFlag().equalsIgnoreCase(OpsCenterConstants.TRUE))
		{
			throw new ProgramNotCurrentlyScheduledByRangeException(
					DefaultResources.PRG_ERR_CODE_DEFAULT_PROGRAM_NOT_EDITABLE, "ProgramId="
							+ programId + " is the default program, not editable by this method");
		}

		// 3. Check and make sure this program by ID is currently running with
		// an active schedule row.
		// If not, throw ProgramNotCurrentlyScheduledByRangeException (
		// PRG_ERR_CODE_PROGRAM_NOT_CURRENTLY_SCHEDULED )

		// 4. Update this program ID's scheduled to set the end date to Today()
		// - 1 (aka Yesterday)
		ProgramScheduleRange range = null;

		LocalDate now = new LocalDate();
		for (ProgramScheduleRange psr : program.getProgramScheduleRangeCollection())
		{

			// IMPORTANT: Only work on non-deleted ranges.
			if (psr.getDeleteFlag().equalsIgnoreCase(OpsCenterConstants.FALSE))
			{

				// Check and see if now is wihtin this date band
				if (!now.isBefore(psr.getStartDate()) && !now.isAfter(psr.getEndDate()))
				{
					range = psr;
				}

			}

		}

		if (range == null)
		{
			throw new ProgramNotCurrentlyScheduledByRangeException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_CURRENTLY_SCHEDULED,
					"Unable to find any ranges for program that contain current date: " + now);
		}

		boolean methodDeleteRange = true;
		if (methodDeleteRange)
		{
			// Method 1: Delete
			range.setDeleteFlag(OpsCenterConstants.TRUE);
			range.setActiveFlag(OpsCenterConstants.FALSE);
		}
		else
		{
			// Method 2: Alter End date
			range.setEndDate(now.minusDays(1));
		}

		// Always update timestamps and owner
		range.setUserModified(userModified);
		range.setDateModified(new DateTime());
		program.setUserModified(userModified);
		program.setDateModified(new DateTime());

		try
		{
			logger.info(errorPrefix + "updateProgram: updateprogramId: " + program.getProgramId());
			progFacade.updateProgram(program);

			// Create + Update all program schedule ranges
			logger.info(errorPrefix + "updateProgramScheduleRange: programId: "
					+ range.getProgramId().getProgramId() + "   startdate: " + range.getStartDate()
					+ " enddate: " + range.getEndDate());

			progFacade.updateProgramScheduleRange(range);

		}
		catch (Exception e)
		{
			if (logger.isErrorEnabled())
			{
				logger.error(errorPrefix + "Error Updating Schedules By Range For ProgramId: "
						+ program.getProgramId(), e);
			}
			e.printStackTrace();
			throw new AbstractOpsCenterRuntimeException(e);
		}

		logger.info(errorPrefix + " stop");

		// Convert the new active program to program model and return it.
		UserProgramModel pm = Program2ProgramModel.transformProgramEntityToModel(program,
				progFacade);
		return pm;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @seecom.consert.core.ejb.session.interfaces.UserProgramBeanLocal#
	 * updateProgramsToOverrideActiveProgramUntilDate(int, int,
	 * org.joda.time.LocalDate)
	 */
	
	@Override
	public UserProgramModel updateProgramsToOverrideActiveProgramUntilDate(
			ProgramOverrideModel programOverrideModel, Integer tenantId) throws ProgramNotFoundException,
			AccountNumberNotFoundException, AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		int accountId = programOverrideModel.getAccountId();
		int programId = programOverrideModel.getProgramId();
		LocalDate overrideStart = programOverrideModel.getOverrideStart();
		LocalDate overrideStop = programOverrideModel.getOverrideStop();
		String userModified = programOverrideModel.getUserModified();

		// To help the logs appear more sane.
		String errorPrefix = "[updateProgramsToOverrideActiveProgramUntilDate(" + accountId
				+ "," + programId + ", " + overrideStart + ", " + overrideStop + ")] ";

		logger.info(errorPrefix + " start");

		// BUGBUG: KRMT-1440: We decided as a group that if the program coming
		// in is
		// not scheduled by range, we would convert it to schedule by range by
		// creating ranges out for a year for each of the days. This
		// implementation
		// is not currently doing that.

		/**
		 * Meta Code:
		 * 
		 * 1. Search all programs for the user and determine which are schedule
		 * by range. Detect Conflicts.
		 * 
		 * 2. Update the programs that conflict by altering the schedule by
		 * range start + stop times.
		 * 
		 * Example: Program A is 1/1 to 1/10, Program B is 1/11 to 1/31. User is
		 * requesting to schedule Program C by range from today (1/7) for a week
		 * until 1/14.
		 * 
		 * The resulting schedule by range would be:
		 * 
		 * Program A: 1/1 to 1/6 Program B: 1/15 to 1/31 Program C: 1/7 to 1/14
		 * 
		 * 3. Save the programs that were modified.
		 * 
		 * 4. This method does not have the side effect of publishing the
		 * message to the gateway. UI must explicitly call
		 * publishMessageForSingelAccount
		 * 
		 * 5. Return the updatedUserProgram model for the program that was just
		 * modified.
		 * 
		 * 6. The UI will probably turn around and query the UserLoginCombined
		 * Object again to re-display the current program tile.
		 * 
		 * BUGBUG: This entire operation should be run inside of a single transaction
		 * so no partial updates happen.
		 * 
		 */

		Account a = findAccountEntityByAccountID(accountId);
		if (a == null)
		{
			throw new AccountNumberNotFoundException(accountId + "", "Find Account By accountId ("
					+ accountId + ") returned null");
		}
		List<Program> programs = findProgramEntitiesByAccountId(accountId);

		List<Program> programsByRange = new ArrayList<Program>();
		Program programToMakeActive = null;

		// Scan the list of all programs and detect which programs are sched by
		// range or the one the user is looking for

		for (Program p : programs)
		{
			// Consider the dormant programs scheduled by ranges for the active programId
			// because by the end of the transaction, it will be scheduled by range.
			if ((p.getSchedByRangeFlag().equals(OpsCenterConstants.TRUE) || p.getProgramId() == programId)
					&&
					// Do not consider the range of the default program
					p.getDefaultFlag().equals(OpsCenterConstants.FALSE))
			{
				programsByRange.add(p);
			}

			if (p.getProgramId() == programId)
			{
				programToMakeActive = p;
			}
		}

		// Don't go any further if the program ID is not in th eusers's list
		if (programToMakeActive == null)
		{
			if (logger.isErrorEnabled())
			{
				logger.error(errorPrefix + "Program ID " + programId
						+ " is not owned by Account ID  " + accountId);
			}
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT, "Program ID "
							+ programId + " is not owned by Account ID  " + accountId);
		}

		// Find the intersection between the existing programs and the new range
		// the user is attempting to create

		ArrayList<ProgramScheduleRange> programScheduleRangesToUpdate = new ArrayList<ProgramScheduleRange>();
		ArrayList<ProgramScheduleRange> programScheduleRangesToCreate = new ArrayList<ProgramScheduleRange>();

		DateTime now = new DateTime();

		// How does this handle the case where the program we're adding already
		// has a schedule by range?
		// Code below should gracefully handle it because everything is generic.
		// The program iterator doesn't
		// care if you're working on the program in question or not.

		for (Program p : programsByRange)
		{

			// Do not process any Deleted Programs
			if (p.getDeleteFlag().equals(OpsCenterConstants.TRUE)
					|| !p.getActiveFlag().equals(OpsCenterConstants.TRUE))
			{
				continue;
			}

			for (ProgramScheduleRange psr : p.getProgramScheduleRangeCollection())
			{

				// Do not process any Deleted Program Ranges
				if (psr.getDeleteFlag().equals(OpsCenterConstants.TRUE)
						|| !psr.getActiveFlag().equals(OpsCenterConstants.TRUE))
				{
					continue;
				}

				logger.info(errorPrefix + "updateProgramScheduleRange: ITERATE: programId: "
						+ p.getProgramId() + "  psr.id: " + psr.getProgramScheduleRangeId());

				boolean newStartWithin = false;
				boolean newStopWithin = false;

				// Does the new beginning date lie within this program's range?

				if ((overrideStart.isAfter(psr.getStartDate()) || overrideStart.equals(psr
						.getStartDate()))
						&& (overrideStart.isBefore(psr.getEndDate()) || overrideStart.equals(psr
								.getEndDate())))
				{
					newStartWithin = true;
				}

				// Does the new end date lie within this program's range?

				if ((overrideStop.isAfter(psr.getStartDate()) || overrideStop.equals(psr
						.getStartDate()))
						&& (overrideStop.isBefore(psr.getEndDate()) || overrideStop.equals(psr
								.getEndDate())))
				{
					newStopWithin = true;
				}

				// Time on the X axis.
				// Time for some ASCII Art!
				// 6 cases here:
				// ===============================================================
				// [ OLD ] = Case 1 : no change
				// [ NEW ] newStrtWithin = false newStopWithin = false
				// ===============================================================
				// [ OLD ] = Case 2: no change
				// [ NEW ] newStrtWithin = false newStopWithin = false
				// ===============================================================
				// [ OLD ] = Case 3: OLD must be deleted
				// [ NEW ] newStrtWithin = false newStopWithin = false
				// ===============================================================
				// [ OLD | ] = Case 4: OLD must be finished sooner
				// [ NEW ] newStartWithin = true newStopWithin = false
				// ===============================================================
				// [ | OLD ] = Case 5: OLD must be started later
				// [ NEW ] newStartWithin = false newStopWithin = true
				// ===============================================================
				// [ | OLD | ] = Case 6: OLD must be split into two pieces
				// [ NEW ] newStartWithin = true newStopWithin = true
				// ===============================================================

				if (!newStartWithin && !newStopWithin)
				{

					// CASE 1: No operation

					// CASE 2: No Operation

					// CASE 3: check for case 3 where the old must be deleted.

					if ((overrideStart.isBefore(psr.getStartDate()) || overrideStart.equals(psr
							.getStartDate()))
							&& (overrideStop.isAfter(psr.getEndDate()) || overrideStart.equals(psr
									.getEndDate())))
					{

						// Completely delete the OLD range, it's inside.
						psr.setDeleteFlag(OpsCenterConstants.TRUE);
						psr.setUserModified(userModified);
						psr.setDateModified(now);
						programScheduleRangesToUpdate.add(psr);

					}

				}
				else if (newStartWithin && !newStopWithin)
				{
					// CASE 4: OLD Must be finished sooner.

					// KRMT-1585 take into consideration special case where
					// start is equal
					if (overrideStart.equals(psr.getStartDate()))
					{
						psr.setDeleteFlag(OpsCenterConstants.TRUE);
					}
					else
					{
						psr.setEndDate(overrideStart.minusDays(1));
					}
					psr.setUserModified(userModified);
					psr.setDateModified(now);

					programScheduleRangesToUpdate.add(psr);

				}
				else if (!newStartWithin && newStopWithin)
				{
					// CASE 5: OLD must be started later.
					// KRMT-1585 take into special case where start is equal
					if (overrideStop.equals(psr.getEndDate()))
					{
						psr.setDeleteFlag(OpsCenterConstants.TRUE);
					}
					else
					{
						psr.setStartDate(overrideStop.plusDays(1));
					}
					psr.setUserModified(userModified);
					psr.setDateModified(now);

					programScheduleRangesToUpdate.add(psr);

				}
				else if (newStartWithin && newStopWithin)
				{
					// CASE 6: OLD must be split into two pieces.
					// KRMT-1585 Some edge cases of CASE 6 create bad date
					// ranges... conditional code added

					psr.setDeleteFlag(OpsCenterConstants.TRUE);
					psr.setUserModified(userModified);
					psr.setDateModified(now);
					ProgramScheduleRange splitBegin = null;
					ProgramScheduleRange splitEnd = null;

					// only have a splitBegin if OLD started before NEW start
					if (psr.getStartDate().isBefore(overrideStart))
					{
						splitBegin = new ProgramScheduleRange();
						splitBegin.setActiveFlag(OpsCenterConstants.TRUE);
						splitBegin.setDeleteFlag(OpsCenterConstants.FALSE);
						splitBegin.setStartDate(psr.getStartDate());
						splitBegin.setEndDate(overrideStart.minusDays(1));
						splitBegin.setProgramId(p);
						splitBegin.setDateCreated(now);
						splitBegin.setUserModified(userModified);
						splitBegin.setDateModified(now);
						splitBegin.setUserCreated(userModified);
					}

					// only have a splitEnd if OLD ends after NEW end
					if (psr.getEndDate().isAfter(overrideStop))
					{
						splitEnd = new ProgramScheduleRange();
						splitEnd.setActiveFlag(OpsCenterConstants.TRUE);
						splitEnd.setDeleteFlag(OpsCenterConstants.FALSE);
						splitEnd.setStartDate(overrideStop.plusDays(1));
						splitEnd.setEndDate(psr.getEndDate());
						splitEnd.setProgramId(p); // split end are what chicks
													// get in their hair
						splitEnd.setDateCreated(now);
						splitEnd.setUserModified(userModified);
						splitEnd.setDateModified(now);
						splitEnd.setUserCreated(userModified);
					}

					programScheduleRangesToUpdate.add(psr);

					if (splitBegin != null)
					{
						programScheduleRangesToCreate.add(splitBegin);
					}

					if (splitEnd != null)
					{
						programScheduleRangesToCreate.add(splitEnd);
					}

				}
				else
				{
					// This point seems impossible to hit, but just in case,
					// throw an X
					throw new ProgramNotFoundException(programId + "",
							"Fell through on the date logic. This is an internal error and data quality must be investigated");

				}

			}
		}

		// And be sure to update the current program in question.

		ProgramScheduleRange newOverrideRange = new ProgramScheduleRange();
		newOverrideRange.setDeleteFlag(OpsCenterConstants.FALSE);
		newOverrideRange.setActiveFlag(OpsCenterConstants.TRUE);
		newOverrideRange.setStartDate(overrideStart);
		newOverrideRange.setEndDate(overrideStop);
		newOverrideRange.setProgramId(programToMakeActive);
		newOverrideRange.setUserCreated(userModified);
		newOverrideRange.setDateCreated(now);
		newOverrideRange.setUserModified(userModified);
		newOverrideRange.setDateModified(now);

		programScheduleRangesToCreate.add(newOverrideRange);

		// Be sure to make the current program schedule by Range.
		programToMakeActive.setSchedByRangeFlag(OpsCenterConstants.TRUE);
		programToMakeActive.setDateModified(now);
		programToMakeActive.setUserModified(userModified);

		try
		{
			logger.info(errorPrefix + "updateProgram: updateprogramId: "
					+ programToMakeActive.getProgramId());

			progFacade.updateProgram(programToMakeActive);

			// Create + Update all program schedule ranges

			for (ProgramScheduleRange psr : programScheduleRangesToUpdate)
			{
				logger.info(errorPrefix + "updateProgramScheduleRange: programId: "
						+ psr.getProgramId().getProgramId() + "   startdate: " + psr.getStartDate()
						+ " enddate: " + psr.getEndDate());

				progFacade.updateProgramScheduleRange(psr);

			}

			for (ProgramScheduleRange psr : programScheduleRangesToCreate)
			{
				logger.info(errorPrefix + "createProgramScheduleRange: programId: "
						+ psr.getProgramId().getProgramId() + "   startdate: " + psr.getStartDate()
						+ " enddate: " + psr.getEndDate());

				progFacade.createProgramScheduleRange(psr);
			}
		}
		catch (Exception e)
		{
			if (logger.isErrorEnabled())
			{
				logger.error(errorPrefix + "Error Updating Schedules By Range For ProgramId: "
						+ programToMakeActive.getProgramId(), e);
			}
			e.printStackTrace();
			throw new AbstractOpsCenterRuntimeException(e);
		}

		// BUGBUG, should probably set the userModified and userModified
		// datetime on the prgorams affected.

		// BUGBUG KRMT-1440 Implementation would go here to down convert the
		// DoW/MoY into schedule by ranges.

		logger.info(errorPrefix + " stop");

		// Convert the new active program to program model and return it.

		UserProgramModel pm = Program2ProgramModel.transformProgramEntityToModel(
				programToMakeActive, progFacade);

		return pm;

	}

	/**
	 * Private helper to make Account Lookup by ID less verbose
	 * 
	 * @author brockman
	 * 
	 * @param accountId
	 * @return
	 * @throws AccountNumberNotFoundException
	 */

	private Account findAccountEntityByAccountID(int accountId)
			throws AccountNumberNotFoundException
	{
		List<Account> acc = userAccountFacade.getAccountByAccountId(accountId);
		if (acc == null || acc.size() == 0)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("[findAccountEntityByAccountId(" + accountId
						+ ")] Error:  No valid account found in DB for account id  " + accountId);
			}
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No account found for account id " + accountId);
		}
		if (acc.size() > 1)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("[findAccountEntityByAccountId(" + accountId
						+ ")] Error:  More than 1 account found in DB for account ID :  "
						+ accountId);
			}
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"More than 1 account found in DB for account ID :  " + accountId);
		}
		Account account = acc.get(0);

		logger.info("[findAccountEntityByAccountId(" + accountId
				+ ")] Account found. Account Number: " + account.getAccountNumber());

		return account;
	}

	/**
	 * Private Helper to make program listing less verbose.
	 * 
	 * @author brockman
	 * @param accountId
	 * @return
	 * @throws ProgramNotFoundException
	 */

	private List<Program> findProgramEntitiesByAccountId(int accountId)
			throws ProgramNotFoundException
	{

		List<Program> programList = progFacade.getProgramByAccountId(accountId);
		if (programList == null || programList.size() == 0)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("[findProgramEntitiesByAccountId(" + accountId
						+ ")] No programs found for Account ID =  " + accountId);
			}
			throw new ProgramNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
					"No programs found for Account ID  " + accountId);
		}

		logger.info("[findProgramEntitiesByAccountId(" + accountId + ")] Found "
				+ programList.size() + " programs for Account ID =  " + accountId);
		return programList;

	}

	private boolean getCurrentDcTransitionPointIsTemp(int esiTstatId, int programId,
			LocalTime tempTpTime)
	{

		LocalTime midnight = LocalTime.MIDNIGHT.plusSeconds(1);
		LocalTime tpTime = midnight;
		boolean tpTimeTemp = false;
		LocalTime tpHighestTime = midnight;
		boolean tpHighestTimeTemp = false;

		// check DC TP's
		List<DcTransitionPoint> dcTpList = progFacade.getDcTransitionPointByEsiDcIdProgramId(
				esiTstatId, programId);

		for (DcTransitionPoint tp : dcTpList)
		{

			// check TP to see if it is best candidate to be next
			if (tp.getTpTime().isBefore(tempTpTime) && tp.getTpTime().isAfter(tpTime))
			{
				tpTime = tp.getTpTime();
				tpTimeTemp = tp.isTemporary();
			}

			// keep track of highest in case localTime is before first
			if (tp.getTpTime().isAfter(tpHighestTime))
			{
				tpHighestTime = tp.getTpTime();
				tpHighestTimeTemp = tp.isTemporary();
			}

		}

		// never set means that there is no tp before localTime, so use last tp
		// of previous day
		if (tpTime.isEqual(midnight))
		{
			tpTime = tpHighestTime;
			tpTimeTemp = tpHighestTimeTemp;
		}

		return tpTimeTemp;

	}

	private TstatTransitionPoint getCurrentTstatTransitionPoint(int esiTstatId, int programId,
			LocalTime localTime)
	{
		logger.info("[ENTER] TstatTransitionPoint UserProgramBean.getCurrentTstatTransitionPoint(esiTstatId = " +
				esiTstatId + ", programId = " + programId + ", localTime = " + localTime);

		/*
		 * DEV-2410 Check to see if the latest temporary transition point created for this TSTAT
		 * is for an indefinite hold.  If so, use this transition point instead
		 */
		TstatTransitionPoint latestTempTP = getLatestTempTstatTransitionPoint(esiTstatId);
		
		if (latestTempTP != null && latestTempTP.getHoldStatus().equalsIgnoreCase(OpsCenterConstants.TRUE))
		{
			logger.debug("TSTAT " + esiTstatId + " is in indefinite hold.  Currently using TP : " + latestTempTP.getTstatTransitionPointId());
			return latestTempTP;
		}

		LocalTime midnight = LocalTime.MIDNIGHT.plusSeconds(1);
		LocalTime tpTime = midnight;
        TstatTransitionPoint tpData = new TstatTransitionPoint();
		LocalTime tpHighestTime = midnight;
		TstatTransitionPoint tpHighestTimeData = new TstatTransitionPoint();

        // check TSTAT TP's
		List<TstatTransitionPoint> tsTpList = progFacade
				.getTstatTransitionPointByEsiTstatIdProgramId(esiTstatId, programId);

		// Code fix for KRMT-6947 by KochharR
		//sets tp in case of single element in the list and it is midnight
		if (tsTpList != null && tsTpList.size() == 1
				&& tpTime.isEqual(midnight)) {
			logger.info("Single transaction point set for midnight ");
			tpHighestTime = tsTpList.get(0).getTpTime();
			tpHighestTimeData = tsTpList.get(0);
		}
		// find the highest tp which is after midnight
		else {
			for (TstatTransitionPoint tp : tsTpList) {
				// check TP to see if it is best candidate to be next
				if (tp.getTpTime().isBefore(localTime)
						&& tp.getTpTime().isAfter(tpTime)) {
					tpTime = tp.getTpTime();
					tpData = tp;
				}

				// keep track of highest in case localTime is before first
				if (tp.getTpTime().isAfter(tpHighestTime)) {
					tpHighestTime = tp.getTpTime();
					tpHighestTimeData = tp;
				}

				logger.debug("just set latest TP, tp_id = "
						+ tpData.getTstatTransitionPointId());
			}
		}
		
		// never set means that there is no tp after localTime, so use first tp
		// of next day
		if (tpTime.isEqual(midnight))
		{
			tpTime = tpHighestTime;
			tpData = tpHighestTimeData;
		}

		logger.info("[ EXIT] UserProgramBean.getCurrentTstatTransitionPoint");
		return tpData;
	}

	public DcTransitionPoint getLatestTempDcTransitionPoint(int esiDcId)
	{
		logger.info("[ENTER] TstatTransitionPoint UserProgramBean.getLatestTempDcTransitionPoint(esiDcId = " + esiDcId + ")");

		DcTransitionPoint latestTempTransitionPoint = null;

		// check DC TEMP TP's for the one with the latest DATE_CREATED
		latestTempTransitionPoint = progFacade.getLatestTempTransitionPointByEsiDcId(esiDcId);

		if (latestTempTransitionPoint == null)
		{
			logger.debug("No temp transition point for esiDcId : " + esiDcId);
			logger.info("[ EXIT] UserProgramBean.getLatestTempDcTransitionPoint");
			return null;
		}

		logger.debug("latestTempTransitionPoint for this DC : tpId = " +
				latestTempTransitionPoint.getDcTransitionPointId() +
				", dateCreated = " + latestTempTransitionPoint.getDateCreated() +
				", temporaryFlag = " + latestTempTransitionPoint.getTemporaryFlag());

		logger.info("[ EXIT] UserProgramBean.getLatestTempDcTransitionPoint");

		return latestTempTransitionPoint;
	}

	@Override
	public TstatTransitionPoint getLatestTempTstatTransitionPoint(int esiTstatId)
	{
		logger.info("[ENTER] TstatTransitionPoint UserProgramBean.getLatestTempTstatTransitionPoint(esiTstatId = " + esiTstatId + ")");

		TstatTransitionPoint latestTempTransitionPoint = null;

		// check TSTAT TEMP TP's for the one with the latest DATE_CREATED
		latestTempTransitionPoint = progFacade
				.getLatestTempTransitionPointByEsiTstatId(esiTstatId);
		if (latestTempTransitionPoint == null)
		{
			logger.debug("No temp transition point for esiTstatId : " + esiTstatId);
			logger.info("[ EXIT] UserProgramBean.getLatestTempTstatTransitionPoint");
			
			return null;
		}

		logger.debug("latestTempTransitionPoint for this TSTAT : tpId = " +
				latestTempTransitionPoint.getTstatTransitionPointId() +
				", dateCreated = " + latestTempTransitionPoint.getDateCreated() +
				", temporaryFlag = " + latestTempTransitionPoint.getTemporaryFlag() +
				", holdStatus = " + latestTempTransitionPoint.getHoldStatus());
		logger.info("[ EXIT] UserProgramBean.getLatestTempTstatTransitionPoint");

		return latestTempTransitionPoint;
	}

	/**
	 * Expires all Temp Transition Points for a given Program
	 * except for those still currently in effect
	 *
	 * @param program
	 * @return
	 */

	private void expireTempTransitionPoints(Program program)
	{

		int programId = program.getProgramId();
		Account acct = program.getAccountId();
		DateTimeZone datetimeZone = acct.getTimezoneId().getDateTimeZone();
		DateTime currentDateTime = new DateTime(datetimeZone);
		int checkTime = 1426; // 23hr, 46min

		String userModified = userLoginBean.whoAmI();

		// check DC TP's
		List<DcTransitionPoint> dctpList = progFacade
				.getDcTransitionPointByProgramId(programId);
		if (dctpList == null || dctpList.size() == 0)
		{

			// no DC transition points in db--this should be ok??
			logger.warn("No DC transition points found for Prog id : " + programId);
		}
		else
		{

			for (DcTransitionPoint tp : dctpList)
			{

				if (tp.isTemporary())
				{

					DateTime tpExpireDateTime = tp.getDateCreated().plusMinutes(checkTime);

					// expire if aged out
					if (tpExpireDateTime.isBefore(currentDateTime))
					{

						tp.setDeleteFlag(OpsCenterConstants.TRUE);
						tp.setDateModified(currentDateTime);
						tp.setUserModified(userModified);
						try
						{
							progFacade.updateDcTransitionPoint(tp);
						}
						catch (Exception e)
						{
							e.printStackTrace();
							throw new AbstractOpsCenterRuntimeException(e);
						}

					}
				}
			}

		}

		// check Tstat TP's
		List<TstatTransitionPoint> tstpList = progFacade
				.getTstatTransitionPointByProgramId(programId);
		if (tstpList == null || tstpList.size() == 0)
		{
			// no TSTAT transition points in db--this should be ok??
			logger.warn("No TSTAT transition points found for Prog id : " + programId);
		}
		else
		{
			// which TSTATs are in this program?
			List<Integer> esiTstatIdList = new ArrayList<Integer>();
			for (TstatTransitionPoint tp : tstpList)
			{
				Integer esiTstatId = new Integer(tp.getEsiTstatId().getEsiTstatId());

				if (!esiTstatIdList.contains(esiTstatId))
				{
					esiTstatIdList.add(esiTstatId);
				}
			}

			logger.debug("List of esi_tstat_ids for program " + program.getProgramId() + " : " + esiTstatIdList);

			// which TSTATs are currently in indefinite holds?
			List<TstatTransitionPoint> currentlyActiveHoldTPList = new ArrayList<TstatTransitionPoint>();
			for (Integer esiTstatId : esiTstatIdList)
			{
				TstatTransitionPoint tempTP = getLatestTempTstatTransitionPoint(esiTstatId);

				if (tempTP != null && tempTP.getHoldStatus().equals(OpsCenterConstants.TRUE))
				{
					currentlyActiveHoldTPList.add(tempTP);
				}
			}

			List<Integer> currentHoldTPIds = new ArrayList<Integer>();
			for (TstatTransitionPoint holdTP : currentlyActiveHoldTPList)
			{
				currentHoldTPIds.add(holdTP.getTstatTransitionPointId());
			}

			logger.debug("Currently active hold TPs for TSTATs in program " + program.getProgramId() + " : " + currentHoldTPIds);

			for (TstatTransitionPoint tp : tstpList)
			{
				// don't expire currently active indefinite hold TPs
				if (tp.isTemporary() && !currentlyActiveHoldTPList.contains(tp))
				{
					DateTime tpExpireDateTime = tp.getDateCreated().plusMinutes(checkTime);

					// expire if aged out
					if (tpExpireDateTime.isBefore(currentDateTime))
					{
						tp.setDeleteFlag(OpsCenterConstants.TRUE);
						tp.setDateModified(currentDateTime);
						tp.setUserModified(userModified);
						try
						{
							progFacade.updateTstatTransitionPoint(tp);
						}
						catch (Exception e)
						{
							e.printStackTrace();
							throw new AbstractOpsCenterRuntimeException(e);
						}
					}
				}
			}
		}
	}

	// KRMT-1375 edit device name
	@Override
	public void updateEsiDc(EsiDcModel esiDcModel, Integer tenantId) throws EsiDcNotFoundException, Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering updateEsiDc()");

		// get the EsiDcId
		if (esiDcModel == null)
		{
			throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"EsiDc is null. ");
		}
		int esiDcId = esiDcModel.getEsiDcId();

		EsiDc dc = esiFacade.findEsiDcByEsiDcId(esiDcId);
		if (dc == null)
		{
			throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"EsiDc not found for id " + esiDcId);
		}

		dc.setName(esiDcModel.getName());
		cacheManager.updateDeviceName(esiDcId, esiDcModel.getName());
		try
		{
			esiFacade.updateEsiDc(dc);
		}
		catch (Exception e)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Failed to update EsiDc for id " + esiDcId);
			}
			throw new DatabaseUpdateFailed(DefaultResources.PRG_ERR_CODE_ESI_DC_UPDATE_FAILED,
					"Failed to update EsiDc in DB for id = " + esiDcId);

		}

		DcHistory dcHistory = new DcHistory();
		List<HistoryAction> histActionList = null;
		dcHistory.setActionUserId(userAccountFacade.findUserByUsername(esiDcModel.getUserName()));
		dcHistory.setActionDate(new DateTime());
		dcHistory.setDcId(dc.getDcId());
		dcHistory.setActionLongCommentsFlag(OpsCenterConstants.FALSE);
		histActionList = genericFacade.getHistoryActionByActionName("Modified");
		if (histActionList == null || histActionList.size() <= 0)
		{
			logger.error("No History Action found for Modified in DB");
		}
		else
		{
			dcHistory.setHistoryActionId(histActionList.get(0));
			dcHistory.setActionShortComments("DC modified for DC = "
					+ esiDcModel.getDeviceTypeName());

		}

		// now update the DB
		if (histActionList != null && histActionList.size() > 0)
		{
			deviceFacade.createDcHistory(dcHistory);
			logger.debug("DC history created for dcId = " + dc.getDcId().getDcId());

		}

		logger.info("Exiting updateEsiDc()");

	}

	// KRMT-1375 edit device name
	@Override
	public void updateEsiTstat(EsiTstatModel esiTstatModel, Integer tenantId) throws EsiTstatNotFoundException,
			Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering updateEsiTstat()");

		// get the EsiTstatId
		if (esiTstatModel == null)
		{
			throw new EsiTstatNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"EsiTstat is null. ");
		}
		int esiTstatId = esiTstatModel.getEsiTstatId();

		EsiTstat tstat = esiFacade.findEsiTstatByEsiTstatId(esiTstatId);
		if (tstat == null)
		{
			throw new EsiTstatNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"EsiTstat not found for id " + esiTstatId);
		}

		tstat.setName(esiTstatModel.getName());

		// KRMT-1375: also update the fake DC that is associated with this TSTAT
		EsiDc dc = tstat.getEsiDcId();
		if (dc == null)
		{
			throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"the fake EsiDc not found for Tstat=" + esiTstatId);
		}

		dc.setName(esiTstatModel.getName());
		cacheManager.updateDeviceName(dc.getEsiDcId(), esiTstatModel.getName());
		try
		{
			esiFacade.updateEsiTstat(tstat);
			esiFacade.updateEsiDc(dc);
		}
		catch (Exception e)
		{
			if (logger.isErrorEnabled())
			{
				logger.error("Failed to update EsiTstat for id " + esiTstatId);
			}
			throw new DatabaseUpdateFailed(DefaultResources.PRG_ERR_CODE_ESI_TSTAT_UPDATE_FAILED,
					"Failed to update EsiTstat in DB for id = " + esiTstatId);

		}

		TstatHistory tstatHistory = new TstatHistory();
		List<HistoryAction> histActionList = null;
		tstatHistory.setActionUserId(userAccountFacade.findUserByUsername(esiTstatModel
				.getUserName()));
		tstatHistory.setActionDate(new DateTime());
		tstatHistory.setTstatId(tstat.getTstatId());
		tstatHistory.setActionLongCommentsFlag(OpsCenterConstants.FALSE);
		histActionList = genericFacade.getHistoryActionByActionName("Modified");
		if (histActionList == null || histActionList.size() <= 0)
		{
			logger.error("No History Action found for Modified in DB");
		}
		else
		{
			tstatHistory.setHistoryActionId(histActionList.get(0));
			tstatHistory.setActionShortComments("Tstat modified for Tstat =  "
					+ esiTstatModel.getName());

		}

		// now update the DB
		if (histActionList != null && histActionList.size() > 0)
		{
			deviceFacade.createTstatHistory(tstatHistory);
			logger.debug("TSTAT history created for tstatId = " + tstat.getTstatId().getTstatId());

		}

		logger.info("Exiting updateEsiTstat()");

	}

	//TODO-CR KRMT-6479 UserProgramBean Completed
	private static String getCacheKey(int devid, String gwKey)
	{
		StringBuffer id = new StringBuffer();
		id.append(devid);
		id.append("|");
		id.append(gwKey);
		return id.toString();
	}

	private int setProgPushAlarm(Set<Integer> programs, int esiId,
			Long deviceMacAddr, User user, byte opCode)
			throws EsiGatewayNotFoundException
	{
		logger.info("[ENTER] int UserProgramBean.setProgPushAlarm(...)");

		List<Esi> esiList = esiFacade.getEsiByEsiId(esiId);
		if (esiList == null || esiList.isEmpty())
		{
			String message = "ESI not found for esi = " + esiId;
			logger.info("[ EXIT] UserProgramBean.setProgPushAlarm");
			throw new EsiGatewayNotFoundException(message);
		}

		Esi esi = esiList.get(0);

		Integer messagingOpCodeId = OpsCenterConstants.opcodeMap.get(ByteUtilityLocal
				.asHex(opCode));

		// Create the messaging alarm entity
		MessagingAlarm mAlarm = new MessagingAlarm();
		mAlarm.setDateRaised(new DateTime());
		mAlarm.setGatewayId(esi.getEsiGatewayId().getGatewayId());
		mAlarm.setMessagingOpcodeId(messagingOpCodeId);

		// GridStream alarms will use MAC Addr
		if (deviceMacAddr != null)
		{
			mAlarm.setDeviceMacId(deviceMacAddr);
		}

		if (opCode == OpsCenterConstants.OPCODE_SEND_USER_PROGRAM
				|| opCode == OpsCenterConstants.OPCODE_DEVICE_PROGRAM_PUSH)
		{
			mAlarm.setComments("Prog Push message sent: " + OpsCenterConstants.PUSH_REASON_FULL);
		}
		else if (opCode == OpsCenterConstants.OPCODE_SEND_OVERRIDE_PROGRAM
				|| opCode == OpsCenterConstants.OPCODE_DEVICE_PROGRAM_OVERRIDE)
		{
			mAlarm.setComments("Prog Push message sent: " + OpsCenterConstants.PUSH_REASON_OVERRIDE);
		}

		if (user != null)
		{
			mAlarm.setUserId(user);
		}
		else
		{
			mAlarm.setUserId(userAccountFacade.getRefUserByUserId(1));
		}

		// Store the messaging alarm entity
		try
		{
			genericFacade.createMessagingAlarm(mAlarm);
		}
		catch (Exception e)
		{
			logger.error("setProgPushAlarm: Could not create new alarm in DB on Esi = " + esiId);
		}

		logger.debug("setProgPushAlarm: New alarm created for Esi = " + esiId);

		setProgramAlarmRelation(programs, mAlarm);

		logger.info("[ EXIT] UserProgramBean.setProgPushAlarm");

		return mAlarm.getMessagingAlarmId();
	}

	/**
	 * @param programs
	 * @param mAlarm
	 */
	private void setProgramAlarmRelation(Set<Integer> programs, MessagingAlarm mAlarm)
	{
		// This has to be done after createMessagingAlarm to get the messaging
		// alarm ID set.
		if (programs != null && programs.size() > 0)
		{
			for (int programId : programs)
			{
				try
				{
					MessagingAlarmProgramRel messagingAlarmProgramRel = new MessagingAlarmProgramRel();
					messagingAlarmProgramRel.setMessagingAlarmId(mAlarm.getMessagingAlarmId());
					messagingAlarmProgramRel.setProgramId(programId);
					try
					{
						genericFacade.createMessagingAlarmProgramRel(messagingAlarmProgramRel);
					}
					catch (Exception e)
					{
						logger.error("setProgramAlarmRelation: Could not create new alarm program ewl in DB Alarm = "
								+ mAlarm.getMessagingAlarmId() + "  Program = " + programId);
						logger.error("setProgramAlarmRelation: exception: ", e);
					}

					logger.debug("setProgramAlarmRelation: Alarm = " + mAlarm.getMessagingAlarmId()
							+ "  Program = " + programId);
				}
				catch (Exception e)
				{
					logger.error("setProgramAlarmRelation: Could not create new program/message map for = "
							+ programId);
				}
			}
		}
	}

	/**
	 * Convert from a Program (DB) object to a ProgramStatusModel (UI) object
	 * 
	 * @param accountId
	 * @return
	 */
	
	public ProgramStatusModel programToProgramModel(Program program)
	{
		// Get the status of each program associated with this account
		ProgramStatusModel programStatus = new ProgramStatusModel();

		programStatus.setProgramId(program.getProgramId());
		programStatus.setProgramName(program.getName());
		programStatus.setProgramDateCreated(program.getDateCreated());
		programStatus.setProgramDateUpdated(program.getDateModified());

		// Given an account ID, search the account history table for a deleted
		// date
		List<ProgramHistory> programHistoryList = progFacade
				.getProgramHistoryByProgramIdOrderByActionDate(program.getProgramId());
		if (programHistoryList != null && !programHistoryList.isEmpty())
		{
			for (ProgramHistory programHistory : programHistoryList)
			{
				// Log for the delete flag
				if (programHistory.getActionShortComments().contains(
						UserProgramBean.PROGRAM_DELETE_MESSAGE))
				{
					programStatus.setProgramDateDeleted(programHistory.getActionDate());

					// Break on the first instance of a delete flag change.
					break;
				}
			}
		}

		TreeMap<DateTime, MessagingAlarm> clearedAlarms = new TreeMap<DateTime, MessagingAlarm>();
		TreeMap<DateTime, MessagingAlarm> notClearedAlarms = new TreeMap<DateTime, MessagingAlarm>();
		List<MessagingAlarmProgramRel> messagingAlarmsForProgram = genericFacade
				.getMessagingAlarmProgramRelByProgramId(program.getProgramId());
		for (MessagingAlarmProgramRel messagingAlarmForProgram : messagingAlarmsForProgram)
		{
			List<MessagingAlarm> alarms = genericFacade
					.getMessagingAlarmByMessagingAlarmId(messagingAlarmForProgram
							.getMessagingAlarmId());
			if (alarms != null && alarms.size() > 0)
			{
				MessagingAlarm alarm = alarms.get(0);
				if (alarm.getDateCleared() == null)
				{
					notClearedAlarms.put(alarm.getDateRaised(), alarm);
				}
				else
				{
					clearedAlarms.put(alarm.getDateRaised(), alarm);
				}
			}
		}

		// Get the last time the program was pushed;
		if (clearedAlarms.size() > 0)
		{
			NavigableSet<DateTime> nset = clearedAlarms.descendingKeySet();
			MessagingAlarm lastPush = clearedAlarms.get(nset.first());
			programStatus.setProgramDatePushed(lastPush.getDateRaised());
		}

		// Get the last time the program was pushed without being acknowledged;
		if (notClearedAlarms.size() > 0)
		{
			// Loop through the alarms looking for the last cleared.
			Iterator<DateTime> keySet = notClearedAlarms.descendingKeySet().iterator();
			while (keySet.hasNext())
			{
				DateTime key = keySet.next();
				MessagingAlarm lastFailed = notClearedAlarms.get(key);
				long timeSincePush = System.currentTimeMillis()
						- lastFailed.getDateRaised().getMillis();
				// If it has just been pushed do not report it as failed.
				if (timeSincePush > OpsCenterConstants.FIVE_MINUTES_MILLIS)
				{
					programStatus.setProgramDatePushFailed(lastFailed.getDateRaised());

					// Break after the first uncleared alarm
					break;
				}
			}
		}

		return programStatus;
	}

	/**
	 * Build the default template with repairs
	 */
	
	public DefaultTemplateModel getDefaultTemplateWithRepair()
	{
		return getDefaultTemplate(true, false);
	}

	/**
	 * Build the default template without attempting repairs
	 */
	
	@Override
	public DefaultTemplateModel getDefaultTemplate(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return getDefaultTemplate();
	}
	
	public DefaultTemplateModel getDefaultTemplate()
	{
		return getDefaultTemplate(false, false);
	}

	/**
	 * Build the default template without attempting repairs
	 */
	
	public DefaultTemplateModel getDefaultTemplateUseCache()
	{
		return getDefaultTemplate(false, true);
	}

	/**
	 * Build the default template
	 */
	private DefaultTemplateModel getDefaultTemplate(boolean repair, boolean useCache)
	{
		// Try the cache first. The cache is used in cyclic operations.
		// For access by the default template editor we always get from the
		// database
		DefaultTemplateCache cacheAccesor = new DefaultTemplateCache();
		if (useCache)
		{
			try
			{
				if (cacheAccesor.isDefaultTemplateInCache())
				{
					DefaultTemplateModel defaultTemplateFromCache = cacheAccesor
							.getDefaultTemplateFromCache();
					if (defaultTemplateFromCache != null)
					{
						return defaultTemplateFromCache;
					}
				}
			}
			catch (Exception e)
			{
				logger.error("Error accessing default template cache: " + e.getMessage());
			}
		}

		// Build the default template model
		DefaultTemplate defaultTemplate = progFacade.getDefaultTemplate();

		List<UserProgramModel> programModels = new ArrayList<UserProgramModel>();
		for (Program program : defaultTemplate.getDefaultPrograms())
		{
			try
			{
				UserProgramModel programModel = Program2ProgramModel
						.transformProgramEntityToModel(program, progFacade);

				programModels.add(programModel);
			}
			catch (ProgramNotFoundException e)
			{
				logger.error("getDefaultTemplate: ProgramNotFoundException on program "
						+ program.getName());
			}
		}
		
		
		DefaultTemplateModel defaultTemplateModel = new DefaultTemplateModel();
		
		//set Programs
		defaultTemplateModel.setDefaultPrograms(programModels);
		
		//convert devices to models
		EsiDcModel waterHeater  = createEsiDcModel(defaultTemplate.getWaterHeater());
		EsiDcModel irrigationPump  = createEsiDcModel(defaultTemplate.getEsiIrrigationPump());
		EsiDcModel poolPump  = createEsiDcModel(defaultTemplate.getPoolPump());
		EsiDcModel cropHeat  = createEsiDcModel(defaultTemplate.getEsiCropHeat());
		EsiDcModel generator  = createEsiDcModel(defaultTemplate.getEsiGenerator());
		EsiTstatModel esiTstat = createEsiTstatModel(defaultTemplate.getDefaultEsiTstat());
		
		defaultTemplateModel.setWaterHeater(waterHeater);
		defaultTemplateModel.setIrrigationPump(irrigationPump);
		defaultTemplateModel.setCropHeat(cropHeat);
		defaultTemplateModel.setGenerator(generator);
		defaultTemplateModel.setPoolPump(poolPump);
		defaultTemplateModel.setEsiTstat(esiTstat);
		
		// Validate
		ProgramValidationModel programValidationModel = getProgramValidationModel();
		DefaultTemplateValidator defaultTemplateValidator = new DefaultTemplateValidator(
				programValidationModel);
		defaultTemplateValidator.validate(defaultTemplateModel);
		defaultTemplateModel.setErrors(defaultTemplateValidator.getValidationErrorStrings());

		// If repair was requested, do it.
		if (repair)
		{
			if (defaultTemplateModel.getErrors().size() > 0)
			{
				DefaultTemplateRepair defaultTemplateRepair = new DefaultTemplateRepair();
				defaultTemplateRepair.repair(defaultTemplate,
						defaultTemplateValidator.getValidationErrors());

				// After repairs we have to get the default template again -
				// this time with no repairs
				defaultTemplateModel = getDefaultTemplate(false, false);
			}
		}

		// Cache the default template after the first get
		try
		{
			if (defaultTemplateModel.getErrors().size() == 0)
			{
				cacheAccesor.cacheDefaultTemplate(defaultTemplateModel);
			}
		}
		catch (Exception e)
		{
			logger.error("Error inserting default template cache on first get: " + e.getMessage());
		}

		return defaultTemplateModel;
	}

	/**
	 * Build the default template
	 */
	
	@Override
	public DefaultTemplateModel setDefaultTemplate(DefaultTemplateModel defaultTemplateModel, Integer tenantId)
			throws Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		return setDefaultTemplate(defaultTemplateModel);
	}
	
	public DefaultTemplateModel setDefaultTemplate(DefaultTemplateModel defaultTemplateModel)
			throws Exception
	{
		logger.debug("setDefaultTemplate:" + defaultTemplateModel.toString());

		// Clear the error list before we do validation.
		defaultTemplateModel.getErrors().clear();

		// Adjust max and min temps for tstat transition points based on values
		// for pref cool and pref heat
		adjustDefaultTemplateTransitionPoints(defaultTemplateModel);

		// Validate the default template before we save
		ProgramValidationModel programValidationModel = getProgramValidationModel();
		DefaultTemplateValidator defaultTemplateValidator = new DefaultTemplateValidator(
				programValidationModel);
		defaultTemplateValidator.validate(defaultTemplateModel);

		// No validation errors - save the new default template
		if (defaultTemplateValidator.getValidationErrors().size() == 0)
		{
			setDefaultTemplateDevices(defaultTemplateModel);

			setDefaultTemplatePrograms(defaultTemplateModel);

			// Cache the default template after a set
			DefaultTemplateCache cacheAccesor = new DefaultTemplateCache();
			try
			{
				cacheAccesor.cacheDefaultTemplate(defaultTemplateModel);
			}
			catch (Exception e)
			{
				// Failure to set the template in cache does not invalidate the
				// changes
				logger.error("Error inserting default template cache after set: " + e.getMessage());
			}
		}
		// Validation errors - setthe error in the model to allow the UI to
		// display them
		else
		{
			defaultTemplateModel.setErrors(defaultTemplateValidator.getValidationErrorStrings());
			logger.error("Errors in default template.  Default template will not be saved.  Check logs for details.");
		}

		// Return the default template.
		// If no errors it will be the same as the input.
		// If there are errors then those errors will be added to the model.
		return defaultTemplateModel;
	}

	/**
	 * Make any adjustments to transition points as needed.
	 * 
	 * @param defaultTemplateModel
	 */
	private void adjustDefaultTemplateTransitionPoints(
			DefaultTemplateModel defaultTemplateModel)
	{
		// Default to CPS values
		int prefCoolToMax = 3;
		int prefHeatToMin = 3;

		// Get the parameters from the DB
		try
		{
			String prefHeatToMinFromDB = genericFacade
					.getUtilityPropertyValue(OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_PREFHEAT_MIN_LOWERLIMIT);
			if (prefHeatToMinFromDB != null)
			{
				prefHeatToMin = Integer.parseInt(prefHeatToMinFromDB);
			}

			String prefCoolToMaxFromDB = genericFacade
					.getUtilityPropertyValue(OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_MAX_PREFCOOL_LOWERLIMIT);
			if (prefCoolToMaxFromDB != null)
			{
				prefCoolToMax = Integer.parseInt(prefCoolToMaxFromDB);
			}
		}
		catch (Exception e)
		{
			logger.error("adjustDefaultTemplateTransitionPoints: Failed to get tstat transition poin constants from DB: "
					+ e.getMessage());
		}

		// For each tstat transition point, adjust the max and min based on pref
		// cool and pref heat.
		for (UserProgramModel defaultProgram : defaultTemplateModel.getDefaultPrograms())
		{
			List<TstatTransitionPointModel> tstatTransitionPoints = defaultProgram
					.getTstatTransitionPointCollection();
			if (tstatTransitionPoints != null && tstatTransitionPoints.size() > 0)
			{
				for (TstatTransitionPointModel tstatTransitionPoint : tstatTransitionPoints)
				{
					tstatTransitionPoint.setMaxTemp(tstatTransitionPoint.getPrefCoolTemp()
							+ prefCoolToMax);
					tstatTransitionPoint.setMinTemp(tstatTransitionPoint.getPrefHeatTemp()
							- prefHeatToMin);
				}
			}
		}
	}

	/**
	 * This is done as a separate transaction to avoid interference with default template 
	 * program updates.
	 */
	private void setDefaultTemplateDevices(DefaultTemplateModel defaultTemplateModel)
			throws Exception
	{
		logger.debug("setDefaultTemplateDevices:" + defaultTemplateModel.toString());

		// Get the modifying user and propagate to the device objects.
		String userModified = null;
		if (defaultTemplateModel.getDefaultPrograms().size() > 0)
		{
			UserProgramModel defaultProgram = defaultTemplateModel.getDefaultPrograms()
					.get(0);
			if (defaultProgram.getUserModified() != null)
			{
				userModified = defaultProgram.getUserModified();
			}
			else
			{
				throw new Exception("setDefaultTemplateDevices: user modified not set for program "
						+ defaultProgram.getName());
			}
		}
		else
		{
			throw new Exception("setDefaultTemplateDevices: no program provided ");
		}

		// Update or create the default Tstat
		List<EsiTstat> defaultTstatList = esiFacade
				.getEsiTstatByEsiTstatId(defaultTemplateModel.getEsiTstat().getEsiTstatId());
		if (defaultTstatList.size() > 0)
		{
			EsiTstatModel esiTstat = defaultTemplateModel.getEsiTstat();
			if (esiTstat != null)
			{
				esiTstat.setUserName(userModified);
				updateEsiTstat(esiTstat, TenantContext.getCurrentTenant());
				entityManager.flush();
			}
		}

		// Update or create the default pool pump
		List<EsiDc> defaultPoolPump = esiFacade.getEsiDcByEsiDcId(defaultTemplateModel
				.getPoolPump().getEsiDcId());
		if (defaultPoolPump.size() > 0)
		{
			EsiDcModel esiDc = defaultTemplateModel.getPoolPump();
			if (esiDc != null)
			{
				esiDc.setUserName(userModified);
				updateEsiDc(esiDc, TenantContext.getCurrentTenant());
				entityManager.flush();
			}
		}

		// Update or create the default water heater
		List<EsiDc> defaultWaterHeater = esiFacade.getEsiDcByEsiDcId(defaultTemplateModel
				.getWaterHeater().getEsiDcId());
		if (defaultWaterHeater.size() > 0)
		{
			EsiDcModel esiDc = defaultTemplateModel.getWaterHeater();
			if (esiDc != null)
			{
				esiDc.setUserName(userModified);
				updateEsiDc(esiDc, TenantContext.getCurrentTenant());
				entityManager.flush();
			}
		}
	}

	/**
	 * This is done as a separate transaction to avoid interference with default template 
	 * device definition updates.
	 */
	private void setDefaultTemplatePrograms(DefaultTemplateModel defaultTemplateModel)
			throws Exception
	{
		logger.debug("setDefaultTemplatePrograms:" + defaultTemplateModel.toString());

		// Do the program model update after the devices are squared away.
		for (UserProgramModel defaultProgram : defaultTemplateModel.getDefaultPrograms())
		{
			updateProgram(defaultProgram, TenantContext.getCurrentTenant());
			entityManager.flush();
		}
	}

	/**
	 * @return
	 */
	
	public ProgramValidationModel getProgramValidationModel()
	{
		// Create the program validation model
		ProgramValidationModel model = new ProgramValidationModel();
		PropertyUtil propertyUtil = PropertyUtil.getInstance();

		// Set program validation limits from the property file.
		// This overrides hard coded initialization values in the model.
		try
		{
			model.setTstatExtremeMax(propertyUtil.getTstatMax());
			model.setTstatExtremeMin(propertyUtil.getTstatMin());

			model.setTstatPrefHeatMax(propertyUtil.getTstatPrefHeatMax());
			model.setTstatPrefHeatMin(propertyUtil.getTstatPrefHeatMin());
			model.setTstatPrefHeatDefault(propertyUtil.getTstatPrefHeatDefault());

			model.setTstatPrefCoolMax(propertyUtil.getTstatPrefCoolMax());
			model.setTstatPrefCoolMin(propertyUtil.getTstatPrefCoolMin());
			model.setTstatPrefCoolDefault(propertyUtil.getTstatPrefCoolDefault());

			model.setTstatDiffBetweenPrefHeatAndMinDefault(propertyUtil
					.getTstatMinAndPrefHeatDefaultDiff());
			model.setTstatDiffBetweenPrefHeatAndMinLowerLimit(propertyUtil
					.getTstatMinAndPrefHeatLowerDiff());
			model.setTstatDiffBetweenPrefHeatAndMinUpperLimit(propertyUtil
					.getTstatMinAndPrefHeatUpperDiff());

			model.setTstatDiffBetweenMaxAndPrefCoolDefault(propertyUtil
					.getTstatMaxAndPrefCoolDefaultDiff());
			model.setTstatDiffBetweenMaxAndPrefCoolLowerLimit(propertyUtil
					.getTstatMaxAndPrefCoolLowerDiff());
			model.setTstatDiffBetweenMaxAndPrefCoolUpperLimit(propertyUtil
					.getTstatMaxAndPrefCoolUpperDiff());

			model.setTstatDiffBetweenPrefCoolAndPrefHeatLowerLimit(propertyUtil
					.getTstatPrefHeatPrefCoolLowerDiff());
		}
		catch (Throwable t)
		{
			logger.error("Error setting program validation from properties file: " + t.getMessage());
			t.printStackTrace();
		}

		// Override program validation limits with database entries, if DB
		// entries are available
		try
		{
			model.setTstatExtremeMax(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_EXTREME_MAX, model.getTstatExtremeMax()));
			model.setTstatExtremeMin(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_EXTREME_MIN, model.getTstatExtremeMin()));

			model.setTstatPrefHeatMax(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_PREFHEAT_MAX, model.getTstatPrefHeatMax()));
			model.setTstatPrefHeatMin(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_PREFHEAT_MIN, model.getTstatPrefHeatMin()));
			model.setTstatPrefHeatDefault(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_PREFHEAT_DEFAULT,
					model.getTstatPrefHeatDefault()));

			model.setTstatPrefCoolMax(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_PREFCOOL_MAX, model.getTstatPrefCoolMax()));
			model.setTstatPrefCoolMin(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_PREFCOOL_MIN, model.getTstatPrefCoolMin()));
			model.setTstatPrefCoolDefault(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_PREFCOOL_DEFAULT,
					model.getTstatPrefCoolDefault()));

			model.setTstatDiffBetweenPrefHeatAndMinDefault(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_MAX_PREFCOOL_DEFAULT,
					model.getTstatDiffBetweenPrefHeatAndMinDefault()));
			model.setTstatDiffBetweenPrefHeatAndMinLowerLimit(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_MAX_PREFCOOL_LOWERLIMIT,
					model.getTstatDiffBetweenPrefHeatAndMinLowerLimit()));
			model.setTstatDiffBetweenPrefHeatAndMinUpperLimit(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_MAX_PREFCOOL_UPPERLIMIT,
					model.getTstatDiffBetweenPrefHeatAndMinUpperLimit()));

			model.setTstatDiffBetweenMaxAndPrefCoolDefault(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_PREFHEAT_MIN_DEFAULT,
					model.getTstatDiffBetweenMaxAndPrefCoolDefault()));
			model.setTstatDiffBetweenMaxAndPrefCoolLowerLimit(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_PREFHEAT_MIN_LOWERLIMIT,
					model.getTstatDiffBetweenMaxAndPrefCoolLowerLimit()));
			model.setTstatDiffBetweenMaxAndPrefCoolUpperLimit(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_PREFHEAT_MIN_UPPERLIMIT,
					model.getTstatDiffBetweenMaxAndPrefCoolUpperLimit()));

			model.setTstatDiffBetweenPrefCoolAndPrefHeatLowerLimit(getIntegerGenericProperty(
					OpsCenterConstants.UTILITY_TSTAT_DIFF_BETWEEN_PREFCOOL_PREFHEAT_LOWERLIMIT,
					model.getTstatDiffBetweenPrefCoolAndPrefHeatLowerLimit()));
		}
		catch (Throwable t)
		{
			logger.error("Error setting program validation from database values: " + t.getMessage());
			t.printStackTrace();
		}

		return model;
	}

	private int getIntegerGenericProperty(String key, int defaultValue)
	{
		List<UtilityProperty> uPropList = genericFacade.getUtilityPropertyByKey(key);
		if (uPropList != null && !uPropList.isEmpty())
		{
			UtilityProperty uProp = uPropList.get(0);
			String propValue = uProp.getValue();
			if (propValue != null)
			{
				return Integer.parseInt(uProp.getValue());
			}
		}
		return defaultValue;
	}

	/**
	 * DEV-1582
	 * Fetches the device MAC address for a particular device based on its esiDcId
	 * 
	 * @param esiDcId
	 * @return The device's respective device MAC address
	 */
	public Long retrieveDeviceMacIdForEsiDcId(int esiDcId)
	{
		EsiDcCacheData esiDcCache = null;

		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(
				cacheManager.getGwDCCache(), esiDcId);

		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCache = (EsiDcCacheData) esiDcResult.getValue();
		}

		if (esiDcCache != null)
		{
			return esiDcCache.getDeviceMacId();
		}
		esiDcResults.discard();
		return null;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserProgramBeanRemote#pingIndividualDevice(int)
	 */
	@Override
	public void pingIndividualDevice(int esiDcId, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] void UserProgramBean.pingIndividualDevice" +esiDcId);
		
		boolean pingRequestSuccess = false;

		DeviceStatisticsModel deviceStatisticsModel = new DeviceStatisticsModel();
		DeviceStatistics deviceStatistics = new DeviceStatistics();

		EsiDcCacheData esiDcCache = getCacheDataByEsiDcIdForPingRequest(esiDcId);
		try
		{
			if (esiDcCache != null)
			{
				pingRequestSuccess = sendPingRequestUsingCacheData(esiDcCache);
				updateDeviceStatisticsFromCacheDataForPingRequest(deviceStatistics, esiDcCache,
						pingRequestSuccess);
			}
			else
			{
				populateDeviceStatisticsModelWithDatabaseData(deviceStatisticsModel, esiDcId);
				if (deviceStatisticsModel.getDeviceMacId() != INVALID_MAC_ADDRESS)
				{
					pingRequestSuccess = sendPingRequestUsingModelData(deviceStatisticsModel);
					updateDeviceStatisticsFromModelData(deviceStatistics, deviceStatisticsModel,
							pingRequestSuccess);
				}
			}
		}
		catch (PublishMessageFailedException e)
		{
			throw new DeviceStatisticsOperationFailedException(
					DefaultResources.ACC_ERR_CODE_DEVICE_STATISTICS_UPDATE_FAILED);
		}

		logger.debug("DeviceStatistics entity : " + deviceStatistics);

		// make sure this is a valid MAC address before touching the DB
		if (deviceStatistics.getDeviceMacId() != INVALID_MAC_ADDRESS)
		{
			String result = null;

			// first see if the record for this device already exists
			List<DeviceStatistics> results = deviceReadingFacade
					.getDeviceStatisticsByDeviceMacId(deviceStatistics.getDeviceMacId());
			if (results == null || results.isEmpty())
			{
				result = deviceReadingFacade.createDeviceStatistics(deviceStatistics);
			}
			else
			{
				DeviceStatistics existingRecord = results.get(0);
				existingRecord.setPingRequests(deviceStatistics.getPingRequests());
				existingRecord.setRequestTime(deviceStatistics.getRequestTime());
				existingRecord.setPingResponses(deviceStatistics.getPingResponses());
				existingRecord.setResponseTime(deviceStatistics.getResponseTime());
				result = deviceReadingFacade.updateDeviceStatistics(existingRecord);
			}

			if (result == null)
			{
				logger.error("DB error, could not create DeviceStatistics, exiting");
				throw new DeviceStatisticsOperationFailedException(
						DefaultResources.ACC_ERR_CODE_DEVICE_STATISTICS_UPDATE_FAILED);
			}
		}
		else
		{
			logger.error("Failed to send ping request due to no available device with esiDcId: "
					+ esiDcId);
		}

		logger.info("[ EXIT] UserProgramBean.pingIndividualDevice");
	}

	/**
	 * @param esiDcCache
	 * @throws EsiDcNotFoundException 
	 */
	protected boolean sendPingRequestUsingCacheData(EsiDcCacheData esiDcCache)
			throws EsiDcNotFoundException
	{
		logger.info("[ENTER] boolean UserProgramBean.sendPingRequestUsingCacheData" + esiDcCache.getEsiDcId());

		boolean pingSuccess = true;

		int totalPingRequests = esiDcCache.getPingRequests();
		Long deviceMacId = esiDcCache.getDeviceMacId();

		// device MAC ID and correlationID will be used to identify this ping
		// request later on for when we get the ping response back
		DateTime pingRequestTime = new DateTime();
		String correlationId = UserProgramBean.ESI_DC_PING_REQUEST + deviceMacId;
		esiDcCache.setPingRequestTimeStamp(new Long(pingRequestTime.getMillis()));
		esiDcCache.setCorrelationId(correlationId);

		List<String> pingErrors = null;
		if (OpsCenterConstants.THIRD_PARTY_TSTAT.equals(esiDcCache.getDeviceType()))
		{
			Account account = userAccountFacade.findAccountByAccountId(esiDcCache.getAccountId());
			pingErrors = tccApiRequestsBean.ping3PtTstatDevice(account, Long.toHexString(deviceMacId));
			esiDcCache.setPingResponseTimeStamp(pingErrors == null ? new DateTime().getMillis() : esiDcCache.getPingRequestTimeStamp());
			esiDcCache.setPingResponses(esiDcCache.getPingResponses() == null ? 0 : esiDcCache.getPingResponses() + 1);
		}
		else
		{
			pingErrors = ccPublisherBean.publishPingRequest(deviceMacId, pingRequestTime, correlationId);
		}
		
		if (pingErrors != null)
		{
			logger.error("Errors returned from ping request #" + totalPingRequests + ": "
					+ pingErrors);
			pingSuccess = false;
		}

		totalPingRequests++;

		// update total ping requests
		esiDcCache.setPingRequests(totalPingRequests);
		Element element = new Element(esiDcCache.getCacheKey(), esiDcCache);
		cacheManager.getGwDCCache().put(element);

		logger.info("[ EXIT] UserProgramBean.sendPingRequestUsingCacheData");

		return pingSuccess;
	}

	/**
	 * @param deviceStatisticsModel
	 * @return 
	 */
	protected boolean sendPingRequestUsingModelData(DeviceStatisticsModel deviceStatisticsModel)
	{
		logger.info("[ENTER] boolean UserProgramBean.sendPingRequestUsingModelData, mac Id"+ deviceStatisticsModel.getDeviceMacId()) ;


		boolean pingSuccess = true;

		long deviceMacId = deviceStatisticsModel.getDeviceMacId();
		int totalPingRequests = deviceStatisticsModel.getPingRequests();

		// device MAC ID and correlationID will be used to identify this ping
		// request later on for when we get the ping response back
		DateTime pingRequestTime = new DateTime();
		String correlationId = UserProgramBean.ESI_DC_PING_REQUEST + deviceMacId;
		deviceStatisticsModel.setRequestTime(pingRequestTime);

		List<String> pingErrors = null;
		if (OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT == deviceStatisticsModel.getDtId())
		{
			Account account = userAccountFacade.findAccountByAccountId(deviceStatisticsModel.getAccountId());
			pingErrors = tccApiRequestsBean.ping3PtTstatDevice(account, Long.toHexString(deviceMacId));
			deviceStatisticsModel.setResponseTime(pingErrors == null ? new DateTime() : deviceStatisticsModel.getResponseTime());
			deviceStatisticsModel.setPingResponses(deviceStatisticsModel.getPingResponses() + 1);
		}
		else
		{
			pingErrors = ccPublisherBean.publishPingRequest(deviceMacId, pingRequestTime, correlationId);
		}
		
		if (pingErrors != null)
		{
			logger.error("Errors returned from ping request #" + totalPingRequests + ": "
					+ pingErrors);
			pingSuccess = false;
		}

		totalPingRequests++;

		// update total ping requests
		deviceStatisticsModel.setPingRequests(totalPingRequests);

		logger.info("[ EXIT] UserProgramBean.sendPingRequestUsingModelData");

		return pingSuccess;
	}

	/**
	 * @param deviceStatisticsModel
	 * @param esiDcId
	 */
	protected void populateDeviceStatisticsModelWithDatabaseData(
			DeviceStatisticsModel deviceStatisticsModel, int esiDcId)
	{
		logger.info("[ENTER] void UserProgramBean.populateDeviceStatisticsModelWithDatabaseData " + esiDcId);

		long deviceMacId = getDeviceMacIdByEsiDcId(esiDcId);

		if (deviceMacId == INVALID_MAC_ADDRESS)
		{
			logger.error("No valid MAC address found for device with esiDcId : " + esiDcId);
		}
		else
		{
			List<EsiDc> esiDcs = esiBeanFacade.getEsiDcByEsiDcId(esiDcId);
			if(isNotEmpty(esiDcs))
			{
				EsiDc esiDc = esiDcs.get(0);
				deviceStatisticsModel.setDtId(esiDc.getDeviceTypeId().getDeviceTypeId());
				deviceStatisticsModel.setAccountId(esiDc.getEsiId().getAccountId().getAccountId());
			}
			List<DeviceStatistics> deviceStatsResults = deviceReadingFacade
					.getDeviceStatisticsByDeviceMacId(deviceMacId);

			// set the MAC address whether or not a DB row for this device
			// exists yet
			if (deviceStatsResults != null && !deviceStatsResults.isEmpty())
			{
				for (DeviceStatistics deviceStats : deviceStatsResults)
				{
					deviceStatisticsModel
							.setDeviceStatisticsId(deviceStats.getDeviceStatisticsId());
					deviceStatisticsModel.setDeviceMacId(deviceStats.getDeviceMacId());
					deviceStatisticsModel.setPingRequests(deviceStats.getPingRequests());
					deviceStatisticsModel.setPingResponses(deviceStats.getPingResponses());
					deviceStatisticsModel.setRequestTime(deviceStats.getRequestTime());
					deviceStatisticsModel.setResponseTime(deviceStats.getResponseTime());
				}
			}
			else
			{
				deviceStatisticsModel.setDeviceMacId(deviceMacId);
				deviceStatisticsModel.setPingRequests(0);
			}
		}

		logger.info("[ EXIT] UserProgramBean.populateDeviceStatisticsModelWithDatabaseData");
	}

	/**
	 * @param esiDcId
	 * @return
	 */
	private long getDeviceMacIdByEsiDcId(int esiDcId)
	{
		logger.info("[ENTER] long UserProgramBean.getDeviceMacIdByEsiDcId(" + esiDcId + ")");

		long deviceMacId = getEsiDcByEsiDcId(esiDcId);

		// couldn't find a mac address in ESI_DC? Then check ESI_TSTAT
		if (deviceMacId == INVALID_MAC_ADDRESS)
		{
			deviceMacId = getEsiTstatByEsiDcId(esiDcId);
		}

		logger.info("[ EXIT] UserProgramBean.getDeviceMacIdByEsiDcId - " + deviceMacId);

		return deviceMacId;
	}

	/**
	 * @param esiDcId
	 * @return
	 */
	private long getEsiTstatByEsiDcId(int esiDcId)
	{
		logger.info("[ENTER] long UserProgramBean.getEsiTstatByEsiDcId(" + esiDcId + ")");

		List<EsiTstat> esiTstatResults = esiFacade.getEsiTstatByEsiDcId(esiDcId);

		logger.debug("ESI_TSTAT records with esiDcId: " + esiDcId + ": "
				+ esiTstatResults.size());

		for (EsiTstat esiTstat : esiTstatResults)
		{
			logger.debug("deviceMacId : " + esiTstat.getDeviceMacId());

			// make sure this is a current ESI_TSTAT record you're pulling
			// the deviceMacId from
			if (esiTstat.getDeviceMacId() != INVALID_MAC_ADDRESS)
			{
				logger.info("[ EXIT] UserProgramBean.getEsiTstatByEsiDcId - "
						+ esiTstat.getDeviceMacId());
				return esiTstat.getDeviceMacId();
			}
		}

		logger.info("[ EXIT] UserProgramBean.getEsiTstatByEsiDcId");
		return INVALID_MAC_ADDRESS;
	}

	/**
	 * @param esiDcId
	 * @return
	 */
	private long getEsiDcByEsiDcId(int esiDcId)
	{
		logger.info("[ENTER] long UserProgramBean.getEsiDcByEsiDcId(" + esiDcId + ")");

		EsiDc esiDc = esiFacade.findEsiDcByEsiDcId(esiDcId);

		// make sure this is a current ESI_DC record you're pulling the
		// deviceMacId from
		if (esiDc != null && esiDc.getDeviceMacId() != INVALID_MAC_ADDRESS)
		{
			logger.info("[ EXIT] UserProgramBean.getEsiDcByEsiDcId - " + esiDc.getDeviceMacId());
			return esiDc.getDeviceMacId();
		}

		logger.info("[ EXIT] UserProgramBean.getEsiDcByEsiDcId");
		return INVALID_MAC_ADDRESS;
	}

	/**
	 * @param esiDcCache
	 * @param deviceStatistics
	 * @param pingRequestSuccess 
	 */
	public void updateDeviceStatisticsFromCacheDataForPingRequest(DeviceStatistics deviceStatistics,
			EsiDcCacheData esiDcCache, boolean pingRequestSuccess)
	{
		deviceStatistics.setDeviceMacId(esiDcCache.getDeviceMacId());
		deviceStatistics.setPingRequests(esiDcCache.getPingRequests() != null ? esiDcCache
				.getPingRequests() : 0);
		deviceStatistics.setRequestTime(new DateTime(esiDcCache.getPingRequestTimeStamp()));

		if (pingRequestSuccess)
		{
			deviceStatistics.setResponseTime(new DateTime(esiDcCache.getPingResponseTimeStamp()));
			deviceStatistics.setPingResponses(esiDcCache.getPingResponses() != null ? esiDcCache
					.getPingResponses() : 0);
		}
	}

	private void updateDeviceStatisticsFromModelData(DeviceStatistics deviceStatistics,
			DeviceStatisticsModel deviceStatisticsModel, boolean pingRequestSuccess)
	{
		deviceStatistics.setDeviceMacId(deviceStatisticsModel.getDeviceMacId());
		deviceStatistics.setPingRequests(deviceStatisticsModel.getPingRequests());
		deviceStatistics.setRequestTime(new DateTime(deviceStatisticsModel.getRequestTime()));

		if (pingRequestSuccess)
		{
			deviceStatistics.setResponseTime(new DateTime(deviceStatisticsModel.getResponseTime()));
			deviceStatistics.setPingResponses(deviceStatisticsModel.getPingResponses());
		}
	}

	/**
	 * @param esiDcCache
	 * @return
	 * @throws EsiDcNotFoundException 
	 */
	protected Long getDeviceMacIdFromEsiDcCache(EsiDcCacheData esiDcCache)
			throws EsiDcNotFoundException
	{
		logger.info("[ENTER] Long UserProgramBean.getDeviceMacIdFromEsiDcCache(EsiDcCacheData esiDcCache)");

		// first, get the deviceMacId of the device we're pinging
		if (esiDcCache != null && esiDcCache.getDeviceMacId() != INVALID_MAC_ADDRESS)
		{
			logger.info("[ EXIT] UserProgramBean.getDeviceMacIdFromEsiDcCache");
			return esiDcCache.getDeviceMacId();
		}

		logger.info("[ EXIT] UserProgramBean.getDeviceMacIdFromEsiDcCache");
		throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
				"No ESI DC found in the cache for esiDcId");
	}

	/**
	 * @param esiDcId
	 * @return
	 */
	protected EsiDcCacheData getCacheDataByEsiDcIdForPingRequest(int esiDcId)
	{
		logger.info("[ENTER] EsiDcCacheData UserProgramBean.getCacheDataByEsiDcIdForPingRequest(" + esiDcId + ")");

		EsiDcCacheData esiDcCache = null;
		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), esiDcId);
		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCache = (EsiDcCacheData) esiDcResult.getValue();
		}

		logger.info("[ EXIT] UserProgramBean.getCacheDataByEsiDcIdForPingRequest");
		// Cache data only good if these are all here
		if (esiDcCache != null && esiDcCache.getDeviceMacId() != INVALID_MAC_ADDRESS) // &&
		// esiDcCache.getPingRequests() != null)
		{
			logger.info("dumping more ping info " + esiDcCache.getDeviceMacId() + "/" + esiDcCache.getPingRequests());
			return esiDcCache;
		}
		esiDcResults.discard();
		return null;
	}

	/**
	 * @param esiDcId
	 * @return
	 */
	protected EsiDcCacheData getCacheDataByEsiDcIdForPingResponse(int esiDcId)
	{
		logger.info("[ENTER] EsiDcCacheData UserProgramBean.getCacheDataByEsiDcIdForPingResponse(" + esiDcId + ")");

		EsiDcCacheData esiDcCache = getCacheDataByEsiDcIdForPingRequest(esiDcId);

		logger.info("[ EXIT] UserProgramBean.getCacheDataByEsiDcIdForPingResponse");

		// Cache data only good if these are all here (includes all data for
		// ping request
		if (esiDcCache != null && esiDcCache.getPingResponseTimeStamp() != null
				&& esiDcCache.getPingResponses() != null)
		{
			return esiDcCache;
		}

		return null;
	}
	
	/**
	 * This method will set the start and end opt-out window time values into the DB and cache
	 * In addition if the dev passed in is currently in a CE, it will perform the opt-out  on
	 * the device
	 *
	 * @see com.consert.core.ejb.session.interfaces.UserProgramBeanRemote#updateDeviceOptOutWindow(com.consert.core.model.EsiDcModel)
	 */
	@Override
	public void updateDeviceOptOutWindow(EsiDcModel dcModel, Integer tenantId)
			throws EsiDcNotFoundException, DeviceOptOutWindowException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] UserProgramBean.updateDeviceOptOutWindow(EsiDcModel dcModel)");

		if (dcModel.getEsiDcId() <= 0) {
			logger.error("Invalid  ESI DC received, exiting");
				throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"Invalid  ESI DC received, exiting");
		}
		if (dcModel.getOptOutWindowStarttime() != null &&
				dcModel.getOptOutWindowEndtime() != null &&
				dcModel.getOptOutWindowStarttime().getMillis() >= dcModel.getOptOutWindowEndtime().getMillis()) {
			logger.error("Invalid optOutWindowStartTime received, exiting"+dcModel.getOptOutWindowStarttime());
			throw new DeviceOptOutWindowException(DefaultResources.DEVICE_INVALID_OPTOUT_WINDOW,
					"Invalid Device OptOut Window received, exiting");
		}
		//determine if this is a tstat or not
		EsiTstat esiTstat = esiFacade.getEsiTstatByDeviceMacId(dcModel.getDeviceMacId());
		EsiDcCacheData dcCache = null;
		if (esiTstat != null) {
			Element element = cacheManager.getGsTstatCache().get(Long.toString(esiTstat.getDeviceMacId()));
			if (element == null)
			{
	          // relay not found in cache, go to next one
				logger.error("No Tstat cache found hence no DC cache avail for MacAddr,  exiting= "+ esiTstat.getDeviceMacId());
				throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"EsiDc for TSTAT not found in cache, exiting");
	        }
			//if tstat then store opt-out window on the hvacDc entry in cache as well
			GridStreamTstatCacheData tstatCache = (GridStreamTstatCacheData) element.getObjectValue();

			Results dcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(),
					tstatCache.getEsiHvacDcId());
			for (Result dcResult : dcResults.all())
			{
				dcCache = (EsiDcCacheData) dcResult.getValue();

				if (dcCache == null)
				{
					logger.error("Could not find an RMM DC for tstatMacId = "+ tstatCache.getDeviceMacId());
					throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
							"EsiDc for TSTAT not found in cache, exiting");
				}
				dcCache.setOptOutWindowStarttime(dcModel.getOptOutWindowStarttime() != null ?
						dcModel.getOptOutWindowStarttime().getMillis() : null);
				dcCache.setOptOutWindowEndtime(dcModel.getOptOutWindowEndtime() != null ?
						dcModel.getOptOutWindowEndtime().getMillis() : null);
				element = new Element(dcCache.getCacheKey(), dcCache);
				cacheManager.getGwDCCache().put(element);
			}
		}
		ControlEventCacheData ceCache = null;
		if (dcCache != null && 0 < dcCache.getCeId()) {
			Results ceResults = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(),dcCache.getCeId());
			if (ceResults == null || ceResults.size() == 0)
			{
			  logger.error("No CE found in cache for ceId = "+ dcCache.getCeId());
			  return;
			}else {
				for (Result ceResult : ceResults.all())
				{
					ceCache = (ControlEventCacheData) ceResult.getValue();
				}
			}
		}
		EsiDc esiDc = esiFacade.findEsiDcByEsiDcId(dcModel.getEsiDcId());
		//dev-2078 get orig start time to determine if re-adding dev back is needed
		long windowTime =0;
		if (esiDc.getOptOutWindowStarttime() != null)
		 windowTime = esiDc.getOptOutWindowStarttime().getMillis();

		esiDc.setOptOutWindowStarttime(dcModel.getOptOutWindowStarttime());
		esiDc.setOptOutWindowEndtime(dcModel.getOptOutWindowEndtime());
		EsiDcCacheData esiDcCache = null;
		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(),dcModel.getEsiDcId());

		if (esiDcResults == null || esiDcResults.size() == 0)
		{
		  logger.error("No esiDc found in cache, could not set optout window, exiting, esiDc= "+ dcModel.getEsiDcId());
		  throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"Invalid  ESI DC received, exiting");
		}else {
			for (Result esiDcResult : esiDcResults.all())
			{
				esiDcCache = (EsiDcCacheData) esiDcResult.getValue();
			}
		}
		esiDcCache.setOptOutWindowStarttime(dcModel.getOptOutWindowStarttime() != null ?
				dcModel.getOptOutWindowStarttime().getMillis() : null);
		esiDcCache.setOptOutWindowEndtime(dcModel.getOptOutWindowEndtime() != null ?
				dcModel.getOptOutWindowEndtime().getMillis() : null);
		if (isDeviceInActiveEvent(dcModel.getEsiDcId()) || isDeviceInRequestedCeState(dcModel.getEsiDcId())) {
		  if (dcModel.getOptOutWindowStarttime() != null ) {
			  //now check to see if startTime for optout is = or < start CE time
			  //if so, then opt the user out

			if ((esiDcCache != null) &&
			    (esiDcCache.getCeId() > 0) &&
			    esiDcCache.getOptOutReason() == null){
			    //dev still in a CE and has not optedout, check the optout window time now
				if (ceCache != null  && dcModel.getOptOutWindowStarttime() != null){
					if (ceCache.getStartTime().getMillis() >= dcModel.getOptOutWindowStarttime().getMillis()) {
						//this means the optout window start time is inside of the running CE , so now, opt the device out
						try {
							controlEventPowerBean.optOutIndividualDeviceFromCE(esiDcCache.getAccountId(), dcModel.getEsiDcId(),
									                                           ceCache.getCeId(), OpsCenterConstants.OptOutReason.UTILITY_DEV_OPTOUT);
						} catch (AbstractOpsCenterException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}

					}
				}
			}

			
			
		}
		  
	   }else { //dev-2078 check to see if opt-out window has been cleared, if so, and the device
		       //has already optout of an ongoing CE, bring it back in..
		   DateTime currTime = new DateTime();
		  if (dcModel.getOptOutWindowStarttime() == null && 
			   dcModel.getOptOutWindowEndtime() == null && windowTime != 0) {
			  if (esiDcCache.getCeId() != 0 && 
					OpsCenterConstants.TRUE.equals(esiDcCache.getOptOutFlag()) &&
					windowTime <= currTime.getMillis())
				{
				  //fake the opt-out window, so task handler re-adds dev next time it runs...
				  esiDcCache.setOptOutWindowStarttime(currTime.minusMinutes(10).getMillis());
				  esiDcCache.setOptOutWindowEndtime(currTime.getMillis());
				  
				}
		  }
	   }

	
		
		if (esiDcCache != null) {
		  //now update cache to push to other clones
		  Element element = new Element(esiDcCache.getCacheKey(), esiDcCache);
		  cacheManager.getGwDCCache().put(element);
		}

		logger.info("[ EXIT] UserProgramBean.updateDeviceOptOutWindow");

	}
	
	
	public void updateProgAndTPForAccIdFromTmplt(UserProgramModel userPgmModel) throws ProgramNotFoundException,
	Exception
	{
		logger.info("[ENTER] updateProgAndTPForAccIdFromTmplt");
 		DateTime currTime = new DateTime();
 		Account acc = userAccountFacade.findAccountByAccountId(userPgmModel.getAccountId());
        //now lets apply the new prg template programs and TP
 		consertAccountProvisioning.assignProgramTemplateProgramsIfNecessary(acc, userPgmModel.getUserModified(), currTime);
         
		logger.info("[EXIT] updateProgAndTPForAccIdFromTmplt()");
	}
	
	public void deleteProgramsAndTP (UserProgramModel userPgmModel) throws ProgramNotFoundException,
	Exception{
		
		
 		DateTime currTime = new DateTime();

		List<Program> progList = progFacade.getNonDefaultPrograms(userPgmModel.getAccountId());
		if (progList == null || progList.size() <= 0)
		{
			throw new Exception("No programs found for accountId = " + userPgmModel.getAccountId());
		}
		//first lets remove the programs
        for(Program prog:progList) {
		   // Program marked as deleted (logical delete) 
        	prog.setDeleteFlag(OpsCenterConstants.TRUE);
        	prog.setActiveFlag(OpsCenterConstants.FALSE);
        	prog.setDateModified(new DateTime());
        	prog.setUserModified(userPgmModel.getUserModified()); 
			logger.info("just deleted program Id = " + prog.getProgramId());

			// Program is scheduled by range 
			if (OpsCenterConstants.TRUE.equalsIgnoreCase(prog.getSchedByRangeFlag()))
			{
				HashSet<ProgramScheduleRange> schedulesOfProgramFordeletion = new HashSet<ProgramScheduleRange>(
						prog.getProgramScheduleRangeCollection());
	
				// KRMT-2041 remove code that was trying to move schedule to default
				// program if
				// it was scheduled for today. No longer needed.
	
				List<ProgramScheduleRange> newList = new ArrayList<ProgramScheduleRange>();
				List<ProgramScheduleRange> oldList = new ArrayList<ProgramScheduleRange>(
						schedulesOfProgramFordeletion);
	
				// Verify overlapping programs and process it correctly 
				schUserBean.saveNewSchedulesRange(newList, prog.getAccountId()
						.getAccountId(), oldList, null, userPgmModel);
	
			}
			else
			{ // Program is scheduled by month day
	
				HashSet<ProgramScheduleMonthDay> schedulesOfProgramFordeletion = new HashSet<ProgramScheduleMonthDay>(
						prog.getProgramScheduleMonthDayCollection());
				new ArrayList<ProgramScheduleMonthDay>();
				for (ProgramScheduleMonthDay pgmSchMonthDay : schedulesOfProgramFordeletion)
				{
	
					// TODO: Delete ProgramScheduleMonthDays
				}
	
			}
	
			// Complete deletion of program 
			//progFacade.updateProgram(prog);
			// add prog history entry in DB - KRMT-2999
			ProgramHistory progHist = new ProgramHistory();
			try
			{
				progHist.setActionUserId(userAccountFacade.findUserByUsername(userPgmModel
						.getUserModified()));
			}
			catch (UserNotUniqueException e)
			{
				progHist.setActionUserId(null);
			}
			List<HistoryAction> histActionList = genericFacade
					.getHistoryActionByActionName("Retired");
			if (histActionList == null || histActionList.size() <= 0)
			{
				logger.error("No History Action found for Created in DB, hist record not created for program");
			}
			else
			{
				progHist.setActionDate(new DateTime());
				progHist.setProgramId(prog);
				progHist.setActionShortComments(UserProgramBean.PROGRAM_DELETE_MESSAGE);
				progHist.setHistoryActionId(histActionList.get(0));
				progFacade.createProgramHistory(progHist);
			}
			
			//now remove tstat/dc TP
			
			// check Tstat TP's
			List<TstatTransitionPoint> tstpList = progFacade
					.getTstatTransitionPointByProgramId(prog.getProgramId());
			
			for(TstatTransitionPoint tp : tstpList) {
				tp.setDeleteFlag(OpsCenterConstants.TRUE);
				tp.setActiveFlag(OpsCenterConstants.FALSE);
				tp.setDateModified(currTime);
				tp.setUserModified(userPgmModel.getUserModified());
				logger.info("just deleted tstat tpId = " + tp.getTstatTransitionPointId());

				progFacade.updateTstatTransitionPoint(tp);
			}
			
			// check Tstat TP's
			List<DcTransitionPoint> dcList = progFacade
					.getDcTransitionPointByProgramId(prog.getProgramId());
		
			for(DcTransitionPoint tp : dcList) {
				tp.setDeleteFlag(OpsCenterConstants.TRUE);
				tp.setActiveFlag(OpsCenterConstants.FALSE);
				tp.setDateModified(currTime);
				tp.setUserModified(userPgmModel.getUserModified());
				logger.info("just deleted dc tpId = " + tp.getDcTransitionPointId());

				progFacade.updateDcTransitionPoint(tp);
				
			}
        }
		
	}
	
}