/*
 * @(#)UserBean.java 1.00 10/01/26
 */
package com.consert.core.ejb.session;

import java.io.Serializable;
import java.security.Principal;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.consert.core.ejb.cache.AccountSyncCacheData;
import com.consert.core.ejb.cache.AccountUserSyncCacheData;
import com.consert.core.ejb.cache.EsiCacheData;
import com.consert.core.ejb.cache.EsiDcCacheData;
import com.consert.core.ejb.cache.GridStreamTstatCacheData;
import com.consert.core.ejb.cache.Macable;
import com.consert.core.ejb.constant.DefaultResources;
import com.consert.core.ejb.constant.OpsCenterConstants;
import com.consert.core.ejb.exception.AbstractOpsCenterException;
import com.consert.core.ejb.exception.AccountNotFoundException;
import com.consert.core.ejb.exception.AccountNumberNotFoundException;
import com.consert.core.ejb.exception.AccountWithThirdPartyDeviceOnlyException;
import com.consert.core.ejb.exception.EsiDcNotFoundException;
import com.consert.core.ejb.exception.EsiNotFoundException;
import com.consert.core.ejb.exception.EsiNotUniqueException;
import com.consert.core.ejb.exception.ProgramNotFoundException;
import com.consert.core.ejb.exception.ProgramPushException;
import com.consert.core.ejb.exception.PublishMessageFailedException;
import com.consert.core.ejb.exception.SecurityQuestionNumberNotFoundException;
import com.consert.core.ejb.exception.SystemUnavailableException;
import com.consert.core.ejb.exception.UnrecognizedSSOPayloadReceivedException;
import com.consert.core.ejb.exception.UserNameAlreadyExistsException;
import com.consert.core.ejb.exception.UserNameNotFoundException;
import com.consert.core.ejb.exception.UserNotUniqueException;
import com.consert.core.ejb.exception.UtilityUserRoleInvalid;
import com.consert.core.ejb.multitenant.TenantContext;
import com.consert.core.ejb.multitenant.interfaces.MultiTenantEntityManagerWrapper;
import com.consert.core.ejb.session.facade.interfaces.DeviceBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.DeviceReadingBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.EsiBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.GenericFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.ProgramBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.ProgramTemplateFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.UserAccountBeanFacadeLocal;
import com.consert.core.ejb.session.interfaces.DemandManagerBeanLocal;
import com.consert.core.ejb.session.interfaces.PortalUserFacadeBeanLocal;
import com.consert.core.ejb.session.interfaces.PublisherBeanRemote;
import com.consert.core.ejb.session.interfaces.UserBeanRemote;
import com.consert.core.ejb.session.interfaces.local.GenericBeanLocal;
import com.consert.core.ejb.session.interfaces.local.UserBeanLocal;
import com.consert.core.ejb.session.interfaces.local.UserProgramBeanLocal;
import com.consert.core.ejb.session.messages.GridStreamEventHandlerBean;
import com.consert.core.ejb.session.messages.GridStreamMessagesGroupBean;
import com.consert.core.ejb.session.messages.ProvisioningMessagesGroupBean;
import com.consert.core.ejb.session.ota.OtaMessagesGroupBean;
import com.consert.core.ejb.session.provisioning.services.ConfigurationException_Exception;
import com.consert.core.ejb.session.utility.Account2AccountModel;
import com.consert.core.ejb.session.utility.AccountAlerts;
import com.consert.core.ejb.session.utility.AccountHistoryGenerator;
import com.consert.core.ejb.session.utility.AccountSummary;
import com.consert.core.ejb.session.utility.CompoundAccountKey;
import com.consert.core.entities.Account;
import com.consert.core.entities.Dc;
import com.consert.core.entities.DcTransitionPoint;
import com.consert.core.entities.DeviceType;
import com.consert.core.entities.Esi;
import com.consert.core.entities.EsiAlert;
import com.consert.core.entities.EsiDc;
import com.consert.core.entities.EsiGateway;
import com.consert.core.entities.EsiTstat;
import com.consert.core.entities.ExternalAccountXRef;
import com.consert.core.entities.GsManageable;
import com.consert.core.entities.HistoryAction;
import com.consert.core.entities.ManageMode;
import com.consert.core.entities.MasterPortalFunction;
import com.consert.core.entities.MasterPortalFunctionRoleMap;
import com.consert.core.entities.MasterPortalRole;
import com.consert.core.entities.MasterPortalSecurityQuestion;
import com.consert.core.entities.MasterPortalUser;
import com.consert.core.entities.MasterPortalUserRoleMap;
import com.consert.core.entities.Program;
import com.consert.core.entities.ProgramTemplate;
import com.consert.core.entities.ProgramTemplateDcTransitionPoint;
import com.consert.core.entities.ProgramTemplateProgram;
import com.consert.core.entities.ProgramTemplateTstatTransitionPoint;
import com.consert.core.entities.Role;
import com.consert.core.entities.SecurityQuestion;
import com.consert.core.entities.TstatTransitionPoint;
import com.consert.core.entities.User;
import com.consert.core.entities.UserAccountMap;
import com.consert.core.entities.UserHistory;
import com.consert.core.entities.UserRoleMap;
import com.consert.core.entities.UtilityProperty;
import com.consert.core.gsmessages.DeviceConfigMessage;
import com.consert.core.gsmessages.DeviceToggleRequest;
import com.consert.core.gsmessages.RequestDeviceHealthMessage;
import com.consert.core.messages.EndpointIdentifier;
import com.consert.core.model.AccountAlertsModel;
import com.consert.core.model.AccountDataFilterCriteriaModel;
import com.consert.core.model.AccountHistoryModel;
import com.consert.core.model.AccountModel;
import com.consert.core.model.AccountPartsModel;
import com.consert.core.model.AccountStatusModel;
import com.consert.core.model.DefaultTemplateModel;
import com.consert.core.model.EsiAlertCountModel;
import com.consert.core.model.EsiAlertModel;
import com.consert.core.model.FunctionModel;
import com.consert.core.model.PortalRoleModel;
import com.consert.core.model.PortalUserModel;
import com.consert.core.model.RawMessage;
import com.consert.core.model.RoleModel;
import com.consert.core.model.SecurityQuestionModel;
import com.consert.core.model.UserModel;
import com.consert.core.model.UserTimeZoneModel;
import com.consert.core.utils.ByteUtilityLocal;
import com.consert.core.utils.EncryptService;
import com.consert.core.utils.PersistenceUtilities;
import com.consert.core.utils.WebServiceUtil;
import com.consert.service.ns.utility.consertaccountsync.ConsertAccountSync;
import com.consert.service.ns.utility.consertaccountsync.ConsertAccountSync_Service;
import com.consert.service.ns.utility.xml.ConsertAccountSyncAcknowledgement;
import com.consert.service.ns.utility.xml.ConsertAccountSyncInfo;
import com.consert.service.ns.utility.xml.ConsertAccountSyncMessage;
import com.consert.service.ns.utility.xml.ConsertAccountUserSyncInfo;
import com.consert.service.ns.utility.xml.ConsertAcknowledgementById;
import com.consert.service.ns.xml.ConsertCompoundAccountKey;
import com.consert.service.ns.xml.ConsertEquipmentType;
import com.consert.service.ns.xml.ConsertGatewayStatus;

import net.sf.ehcache.Cache;
import net.sf.ehcache.Element;
import net.sf.ehcache.search.Result;
import net.sf.ehcache.search.Results;

/**
 * UserBean is the main business class dedicated to the handling of all operations related to users
 * management.
 * 
 * @author David Conklin
 * @version 3.0
 * @since 3.0
 */
@Stateless
public class UserBean implements UserBeanRemote, UserBeanLocal
{

	private static boolean matchEmail(String s)
	{
		Pattern p = Pattern
				.compile("^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$");
		return p.matcher(s.toUpperCase()).matches();
	}

	private Logger logger = LoggerFactory.getLogger(getClass());
	public static byte numOfConfigBlocks = 0x01;
	public static byte tableId = 0x00;

	public static byte offset = 0x00;

	@Resource
	SessionContext context;

	@EJB
	UserAccountBeanFacadeLocal userAccFacade;

	@EJB
	DeviceBeanFacadeLocal deviceBeanFacadeLocal;

	@EJB
	DeviceReadingBeanFacadeLocal deviceReadingFacade;

	@EJB
	ProvisioningMessagesGroupBean provisioningMessagesGroupBean;

	@EJB
	GenericFacadeLocal genericFacade;

	@EJB
	ProgramBeanFacadeLocal programBeanFacade;
	
	@EJB
	ProgramTemplateFacadeLocal programTemplateFacade;

	@EJB
	UserProgramBeanLocal userProgramBean;

	@EJB
	GenericBeanLocal genericBean;

	@EJB
	EsiBeanFacadeLocal esiBeanFacade;

	@EJB
	private CacheManagerBean cacheManager;

	@EJB
	private PublisherBeanRemote publisher;

	@EJB
	private SSOBean ssoBean;

	@EJB
	private OtaMessagesGroupBean otaBean;

	@EJB
	private GridStreamEventHandlerBean gsEventHandlerBean;
	
	@EJB
	private GridStreamMessagesGroupBean gsMsgGrpBean;
	
	@EJB
	private DemandManagerBeanLocal demandManagerBeanLocal;

	@EJB
	private MultiTenantEntityManagerWrapper    entityManager;
	
	@PersistenceContext(unitName = "master-portal-persistance")
	private EntityManager entityManager1;
	
	@EJB
	private PortalUserFacadeBeanLocal portalUserFacade;

	/**
	 * Default constructor.
	 */
	public UserBean()
	{
	}

	/**
	 * Given an account cross reference list, return all associated accounts
	 * 
	 * @param xrefList
	 * @return
	 */
	private List<AccountModel> accountXRefToAccounts(List<ExternalAccountXRef> xrefList)
	{
		List<AccountModel> accountModels = new ArrayList<AccountModel>();

		for (ExternalAccountXRef xref : xrefList)
		{
			Account account = xref.getAccount();
			AccountModel accountModel = Account2AccountModel.convert(account, esiBeanFacade,
					userAccFacade);
			accountModels.add(accountModel);
		}

		return accountModels;
	}

	/**
	 * Make decisions regarding user history entries
	 * 
	 * @param user
	 * @param fullComment
	 * @param paramName
	 * @param newParam
	 * @param oldParam
	 * @param changeCount
	 * @param flush
	 * @return
	 */
	private int addUserHistoryEntry(User user, StringBuffer fullComment, String paramName, String newParam,
			String oldParam, int changeCount, boolean flush) throws Exception
	{
		int baseLength = new String("Update to User: Parameter|New Value|Old Value =").length();

		if (paramName == null)
		{
			paramName = "";
		}

		if (newParam == null)
		{
			newParam = "";
		}

		if (oldParam == null)
		{
			oldParam = "";
		}

		// No change
		if (newParam.equals(oldParam))
		{
			// Handle the flush with no change scenario
			if (flush)
			{
				if (changeCount > 0)
				{
					storeUserHistoryEntry(user, fullComment.toString());
					changeCount = 0;
					fullComment.deleteCharAt(baseLength); // it is important to
															// operate on the
															// passed
															// StringBuffer
															// instance
				}
			}

			return changeCount;
		}

		// If we get here then the entry has changed
		String newEntry = " " + paramName + "|" + newParam + "|" + oldParam;

		// If the total record length exceeds the DB field length,
		// flush what we have and start a new entry.
		if (fullComment.length() + newEntry.length() > 254)
		{
			storeUserHistoryEntry(user, fullComment.toString());
			changeCount = 0;
			fullComment.delete(baseLength, fullComment.length()); // it is
																	// important
																	// to
																	// operate
																	// on the
																	// passed
																	// StringBuffer
																	// instance
		}

		// Append the the new entry to the buffer
		fullComment.append(newEntry);
		++changeCount;

		// Last history entry - flush the record
		if (flush)
		{
			// Handle the flush with change scenario
			storeUserHistoryEntry(user, fullComment.toString());
			changeCount = 0;
			fullComment.deleteCharAt(baseLength); // it is important to operate
													// on the passed
													// StringBuffer instance
		}

		return changeCount;
	}

	/**
	 * Map the passed in user to the specific account id. This is used when adding secondary
	 * accounts in the consumer UI.
	 * 
	 * @author B Rodriguez
	 * @param user
	 * @param accountId
	 * @throws UserNameAlreadyExistsException
	 * @throws AccountNumberNotFoundException
	 * @throws UserNotUniqueException
	 * @throws ProgramNotFoundException
	 */

	@Override
	public void addUserToAccountMap(UserModel user, int accountId,
			boolean emailAlerts, Integer tenantId)
			throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		// Make sure this won't be a duplicate?

		if (accountId <= 0)
		{
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_ACCOUNT_NOT_FOUND,
					"No Account found for account number " + accountId);
		}
		Account account = userAccFacade.findAccountByAccountId(accountId);
		if (account == null)
		{
			logger.info("addUserToAccountMap() - Account is NULL for account id: "
					+ accountId);

			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountId);
		}

		// KRMT-1196: Ensure the new account has been properly provisioned with
		// an active ESI
		List<Esi> esiList = esiBeanFacade.getEsiByActiveFlagAccountId(accountId,
				OpsCenterConstants.TRUE);
		if (esiList == null || esiList.isEmpty())
		{
			String errMsg = "No ESI found for Account=" + accountId;
			logger.error(errMsg);
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND, errMsg);
		}

		// KRMT-1195: You are allowed to add an account that is already on your
		// account list
		if (userAccountMapExists(user.getUserId(), accountId, tenantId))
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_ACCOUNT_MAP_EXISTS,
					"Account=" + accountId
							+ " already added to User=" + user.getUserId());
		}

		// KRMT-1196: Ensure the new account has been properly set up with at
		// least the default program
		Set<Program> programSet = account.getProgramCollection();
		if (programSet == null || programSet.isEmpty())
		{
			Esi esi = esiList.get(0);
			List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(esi.getEsiId());
			boolean amiOnlyFlag = esiDcList.isEmpty();
			if (!amiOnlyFlag)
			{
				String errMsg = "No Programs found for Account=" + accountId;
				logger.error(errMsg);
				throw new ProgramNotFoundException(
						DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
						errMsg);
			}
		}

		logger
				.info("addUserToAccountMap() - adding account map: userID = "
						+ user.getUserId() + " to accountId: "
						+ account.getAccountId());
		// we must reset the pwd flag to 0 here to prevent the UI from
		// prompting for pwd reset when multiple same acc are present
		// krmt-6212
		User usr = findUserByUsername(user.getUsername());
		usr.setPasswordResetFlag("0");
		UserAccountMap userAccountMap = new UserAccountMap();
		userAccountMap.setUserId(UserModel2User(user));
		// userAccountMap.setEmail(email);
		userAccountMap.setEmailAlertsFlag(emailAlerts ? "1" : "0");
		userAccountMap.setPrimaryFlag("0");
		userAccountMap.setAccountId(account);

		try
		{
			userAccFacade.createUserAccountMap(userAccountMap);
		}
		catch (Exception e)
		{
			logger
					.error("addUserToAccountMap() - Internal exception handled and converted: "
							+ e);
			e.printStackTrace();
			throw new UserNotUniqueException(e + "", e.getMessage());
		}
	}

	/**
	 * Map the passed in user to the specific account. This is used when adding secondary accounts
	 * in the consumer UI.
	 * 
	 * @author Taylor Brockman
	 * @param user
	 * @param accountId
	 * @throws UserNameAlreadyExistsException
	 * @throws AccountNumberNotFoundException
	 * @throws UserNotUniqueException
	 */

	
	public void addUserToAccountMap(UserModel user, String accountNumber,
			boolean emailAlerts)
			throws UserNameAlreadyExistsException,
			AccountNumberNotFoundException, UserNotUniqueException
	{
		// Make sure this won't be a duplicate?

		Account account = getAccountByAccountNumber(accountNumber);
		if (account == null)
		{
			logger.info("createUser() - Account is NULL for account number: "
					+ accountNumber);

			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountNumber);
		}

		// KRMT-1196: Ensure the new account has been properly provisioned with
		// an active ESI
		List<Esi> esiList = esiBeanFacade.getEsiByActiveFlagAccountId(
				account.getAccountId(), OpsCenterConstants.TRUE);
		if (esiList == null || esiList.isEmpty())
		{
			String errMsg = "No ESI found for Account=" + accountNumber;
			logger.error(errMsg);
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND, errMsg);
		}

		// KRMT-1195: You are allowed to add an account that is already on your
		// account list
		if (userAccountMapExists(user.getUserId(), account.getAccountId(), TenantContext.getCurrentTenant()))
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_ACCOUNT_MAP_EXISTS,
					"Account=" + account.getAccountId()
							+ " already added to User=" + user.getUserId());
		}

		// KRMT-1196: Ensure the new account has been properly set up with at
		// least the default program
		Set<Program> programSet = account.getProgramCollection();
		if (programSet == null || programSet.isEmpty())
		{
			String errMsg = "No Programs found for Account=" + accountNumber;
			logger.error(errMsg);
			throw new AccountNumberNotFoundException(
					DefaultResources.PRG_ERR_CODE_PROGRAM_NOT_FOUND_FOR_ACCOUNT,
					errMsg);
		}

		logger
				.info("addUserToAccountMap() - adding account map: userID = "
						+ user.getUserId() + " to accountId: "
						+ account.getAccountId());

		UserAccountMap userAccountMap = new UserAccountMap();
		userAccountMap.setUserId(UserModel2User(user));
		// userAccountMap.setEmail(email);
		userAccountMap.setEmailAlertsFlag(emailAlerts ? "1" : "0");
		userAccountMap.setPrimaryFlag("0");
		userAccountMap.setAccountId(account);

		try
		{
			userAccFacade.createUserAccountMap(userAccountMap);
		}
		catch (Exception e)
		{
			logger
					.error("addUserToAccountMap() - Internal exception handled and converted: "
							+ e);
			e.printStackTrace();
			throw new UserNotUniqueException(e + "", e.getMessage());
		}
	}

	/**
	 * Apply the default template to the program
	 * 
	 * @param esi
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	
	public boolean checkDevicesAndAssignDefaultProgramData(Esi esi) throws AbstractOpsCenterException
	{
		logger.info(" Entering checkDevicesAndAssignDefaultProgramData method");

		try
		{
			// START KRMT-2554 - Support for Pool Pump DC TPs

			// Find out what kind of devices we have
			// Obtain EsiTstatList for Esi_ID
			checkDevicesAndAssignProgramTemplateTPData(esi);
			
			List<EsiTstat> esiTstatList = new ArrayList<EsiTstat>();
			esiTstatList = esiBeanFacade.getEsiTstatByEsiId(esi.getEsiId());
			logger.debug(" Number of TSTATs : " + esiTstatList.size());

			// Obtain EsiDcList for Esi_ID
			List<EsiDc> esiDcList = new ArrayList<EsiDc>();
			esiDcList = esiBeanFacade.getEsiDcByEsiId(esi.getEsiId());
			logger.debug(" Number of DCs : " + esiDcList.size());

			// Start - KRMT-3355
			if (esiDcList.size() == 0 && esiTstatList.size() == 0)
			{
				logger.debug(" No devices found for this Gateway. It is an AMI Only Account ");
				return false;
			}

			// Cannot mix cycling only and VPP devices
			if (isMixedDeviceTypes(esiDcList))
			{
				String errorMessage = "checkDevicesAndAssignDefaultProgramData: Cycling only and VPP devices were configured for the same account.  Gateway: "
						+
						esi.getEsiGatewayId().getGatewayMqId();

				throw new ProgramPushException(
						DefaultResources.PRG_ERR_CODE_INVALID_DEVICE_CONFIG,
						errorMessage);
			}

			// Cycling only devices do not have programs. Return false to
			// prevent
			// application of default program.
			if (containsCyclingDeviceTypes(esiDcList))
			{
				logger.debug("A/C Switch/Single Heat/Dual Heat devices found for this Gateway.  No programs necessary. ");
				return false;
			}

			// KRMT-4970 We should never assign a default program to a root
			// account
			if (esi.getAccountId().getAccountId() == 1)
			{
				String errorMessage = "checkDevicesAndAssignDefaultProgramData: Attempt to apply default program to root account";
				throw new ProgramPushException(
						DefaultResources.PRG_ERR_CODE_INVALID_DEVICE_CONFIG,
						errorMessage);
			}

			// Now assign the default program
			DefaultTemplateModel defaultTemplateModel = userProgramBean
					.getDefaultTemplateUseCache();
			if (defaultTemplateModel.getErrors().size() > 0)
			{
				throw new ProgramPushException(
						DefaultResources.PRG_ERR_CODE_INVALID_DEFAULT_PROGRAM,
						"Invalid default program.  Check logs for errors.");
			}

			// This gets active and not deleted
			List<Program> programList = programBeanFacade.getProgramByAccountId(esi.getAccountId()
					.getAccountId());
			Program accountDefaultProgram = null;
			for (Program pgm : programList)
			{
				if (pgm.getDefaultFlag().equals(OpsCenterConstants.TRUE))
				{
					accountDefaultProgram = pgm;
					break;
				}
			}
			// If there is no default program added to this account, throw an
			// exception to Ruby
			if (accountDefaultProgram == null)
			{
				throw new ProgramPushException(
						DefaultResources.PRG_ERR_CODE_MISSING_DEFAULT_PROGRAM,
						"No default program exists for account number: "
								+ esi.getAccountId().getAccountNumber());
			}

			logger.debug(" Default Program Id to be added with Transition Points:"
					+ accountDefaultProgram);

			List<EsiDc> systemDefaultEsiDcList = null;

			List<DcTransitionPoint> dcTransitionPointList = null;

			Esi defaultEsi = null;

			DateTime now = new DateTime();
			String userModified = whoAmI();

			for (EsiDc esiDc : esiDcList)
			{
				// Check if it is a fake device for Tstat
				// Removed DC_HVAC from DC List KRMT-2232, valid DCs are only
				// Water Heater and Pool Pump
				// KRMT - and AC Switch and EV and Irrigation Pump
				if (esiDc.getDeviceTypeId().getDeviceTypeName()
						.equalsIgnoreCase(OpsCenterConstants.DC_WATER_HEATER)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_POOL_PUMP)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_HVAC_SWITCH)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_SINGLE_HEAT)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_DUAL_HEAT)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_EV_CHARGER)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_IRRIGATION_PUMP)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_CROP_HEAT)
						||
						esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_GENERATOR))
				{
					for (Program program : programList)
					{
						
						logger.debug("Checking if DC TPs exist for this DC: " + esiDc.getEsiDcId()
								+ ", program: "
								+ program.getProgramId());
						List<DcTransitionPoint> currDcTransitionPointList =
								programBeanFacade.getDcTransitionPointByEsiDcIdProgramId(
										esiDc.getEsiDcId(), program.getProgramId());
						logger.debug(" Default DC Transition Points selected :"
								+ currDcTransitionPointList.size());
						// If one transition point exists then don't need to add
						// the defaults
						if (!currDcTransitionPointList.isEmpty())
						{
							continue;
						}

						logger.debug("Processing Esi Dc Id " + esiDc.getEsiDcId()
								+ " for adding DC TPs");
						// KRMT-2554 - Start Adding DC TPs for Pool Pump

						if (systemDefaultEsiDcList == null)
						{
							// KRMT-2554 - Start Adding DC TPs for Pool Pump and
							// Water Heater separately
							defaultEsi = esiBeanFacade.getEsiByAccountId(
									OpsCenterConstants.DEFAULT_ACCOUNT_ID).get(0);
							logger.debug("Dc Transition Points are added for this default ESI Id : "
									+ defaultEsi.getEsiId());
							// KRMT-2554 - End Adding DC TPs for Pool Pump

							systemDefaultEsiDcList = esiBeanFacade.getEsiDcByEsiId(defaultEsi
									.getEsiId());
							logger.debug("System Default Esi Dc Ids List Size : "
									+ systemDefaultEsiDcList.size());
						}

						if (defaultEsi == null)
						{
							logger.error("defaultEsi returned null in checkDevicesAndAssignDefaultProgramData() - Please verify that there is a default ESI for account id : " + OpsCenterConstants.DEFAULT_ACCOUNT_ID);
							return false;
						}
						
						if (systemDefaultEsiDcList.size() == 0)
						{
							String errorMessage = "There are no default ESI DC records in database for ESI ID="
									+ defaultEsi.getEsiId();
							throw new ProgramPushException(
									DefaultResources.PRG_ERR_CODE_INVALID_DEFAULT_PROGRAM,
									errorMessage);
						}
						EsiDc defaultEsiDc = null;
						for (EsiDc tempEsiDc : systemDefaultEsiDcList)
						{
							logger.debug("Checking System Default Esi Dc Id : "
									+ tempEsiDc.getEsiDcId());
							if (tempEsiDc.getDeviceTypeId().getDeviceTypeId() == esiDc
									.getDeviceTypeId().getDeviceTypeId())
							{
								defaultEsiDc = tempEsiDc;
								logger.debug("Requested DC is of type : "
										+ defaultEsiDc.getDeviceTypeId().getDeviceTypeId());
							}
						}

						List<DcTransitionPoint> defDcTransitionPointList = new ArrayList<DcTransitionPoint>();
						if (dcTransitionPointList == null)
						{
							dcTransitionPointList =
									programBeanFacade
											.getDcTransitionPointByProgramId(accountDefaultProgram
													.getSystemDefaultProgramId());
							logger.debug(" System Default DC Transition Points selected :"
									+ dcTransitionPointList.size());
						}

						if (defaultEsiDc == null)
						{
							logger.error("defaultEsiDc returned null in checkDevicesAndAssignDefaultProgramData() - Please verify that there is a default ESI DC for device type " + esiDc.getDeviceTypeId().getDeviceTypeName());
							return false;
						}

						for (DcTransitionPoint dcTransitionPoint : dcTransitionPointList)
						{
							if (defaultEsiDc.getEsiDcId() == dcTransitionPoint.getEsiDcId()
									.getEsiDcId())
							{
								defDcTransitionPointList.add(dcTransitionPoint);
							}
						}

						// KRMT-2554 - End Adding DC TPs for Pool Pump

						logger.debug(" Creating DC Transition Point Object");
						for (DcTransitionPoint dcTransitionPoint : defDcTransitionPointList)
						{
							DcTransitionPoint newDcTransitionPoint = new DcTransitionPoint();
							newDcTransitionPoint.setActiveFlag("1");
							newDcTransitionPoint.setDeleteFlag("0");
							newDcTransitionPoint.setTemporaryFlag("0");
							newDcTransitionPoint.setPowerStatusFlag(dcTransitionPoint
									.getPowerStatusFlag());
							newDcTransitionPoint.setTpTime(dcTransitionPoint.getTpTime());
							newDcTransitionPoint.setEsiDcId(esiDc);
							newDcTransitionPoint.setProgramId(program);
							newDcTransitionPoint.setDateCreated(now);
							newDcTransitionPoint.setUserCreated(userModified);
							newDcTransitionPoint.setDateModified(now);
							newDcTransitionPoint.setUserModified(userModified);
							programBeanFacade.createDcTransitionPoint(newDcTransitionPoint);
							logger.debug(" Adding DC Transition Point :"
									+ newDcTransitionPoint.toString());
						}
					}
					// Checking if DC TPs exist for this DC

				}
				else
				{
					logger.debug("Found a fake DC : EsiDcId:" + esiDc.getEsiDcId() + ", Name:" +
							esiDc.getDeviceTypeId().getDeviceTypeName());
				}
			}

			List<TstatTransitionPoint> tstatTransitionPointList = null;

			for (EsiTstat esiTstat : esiTstatList)
			{

				for (Program program : programList)
				{
					// START KRMT-2554
					// Checking if TSTAT TPs exist for this TSTAT
				
					logger.debug("Checking if TSTAT TPs exist for this TSTAT: "
							+ esiTstat.getEsiTstatId()
							+ ", program: " + program.getProgramId());
					List<TstatTransitionPoint> currTstatTransitionPointList =
							programBeanFacade.getTstatTransitionPointByEsiTstatIdProgramId(
									esiTstat.getEsiTstatId(), program.getProgramId());
					logger.debug(" Default Tstat Transition Points selected :"
							+ currTstatTransitionPointList.size());
					// If one transition point exists then don't need to add the
					// defaults
					if (!currTstatTransitionPointList.isEmpty())
					{
						continue;
					}
					// END KRMT-2554

					if (tstatTransitionPointList == null)
					{
						tstatTransitionPointList =
								programBeanFacade
										.getTstatTransitionPointByProgramId(accountDefaultProgram
												.getSystemDefaultProgramId());
						logger.debug(" System Default Tstat Transition Points selected :"
								+ tstatTransitionPointList.size());
					}
					logger.debug(" Creating TSTAT Transition Point Object");
					for (TstatTransitionPoint tstatTransitionPoint : tstatTransitionPointList)
					{
						TstatTransitionPoint newTstatTransitionPoint = PersistenceUtilities.getTargetedClone(tstatTransitionPoint);
						newTstatTransitionPoint.setActiveFlag("1");
						newTstatTransitionPoint.setDeleteFlag("0");
						newTstatTransitionPoint.setTemporaryFlag("0");
						newTstatTransitionPoint.setEsiTstatId(esiTstat);
						newTstatTransitionPoint.setProgramId(program);
						newTstatTransitionPoint.setDateCreated(now);
						newTstatTransitionPoint.setUserCreated(userModified);
						newTstatTransitionPoint.setDateModified(now);
						newTstatTransitionPoint.setUserModified(userModified);
						programBeanFacade.createTstatTransitionPoint(newTstatTransitionPoint);
						logger.debug(" Adding TstatTransition Point :"
								+ newTstatTransitionPoint.toString());
					}
				}
			}
			logger.debug(" Adding transition point records to database COMPLETE ...");
			
		}
		catch (AbstractOpsCenterException e)
		{
			logger.error("Error in checkDevicesAndAssignDefaultProgramData", e);
			throw e;
		}
		
		
		
		return true;
	}

	
	public boolean checkDevicesAndAssignProgramTemplateTPData(Esi esi) throws AbstractOpsCenterException
	{
		logger.info(" Entering checkDevicesAndAssignProgramTemplateTPData method");
		
		/**
		 * 1. Get Prgm template id from account and verify if the template id is valid.
		 * 2. Get ProgramTemplatePrgmList by prgmTemplateId
		 * 3. Search Prgm table for Prgm name that match Prgm Template prgm table.
		 * 4. Copy DC & Tstat tp from template table matching on prgm name.
		 * 
		 */
		try
		{
			
			// 	We should never assign a default program to a root  account
			if (esi.getAccountId().getAccountId() == 1)
			{
				String errorMessage = "checkDevicesAndAssignProgramTemplateTPData: Attempt to apply program template to root account";
				throw new ProgramPushException(
						DefaultResources.PRG_ERR_CODE_INVALID_DEVICE_CONFIG,
						errorMessage);
			}

			ProgramTemplate prgTemp = esi.getAccountId().getProgramTemplateId();
			if(prgTemp == null ){
				logger.debug("No Prgram Template is assigned to this account.");
				return true;
			}
			logger.debug("Assigning Program Template "+ prgTemp.getProgramTemplateId() + " - " + prgTemp.getName() + " to account " + esi.getAccountId().getAccountNumber());
			
			/* Validate if Program Template is active.
			 * As per RDRN-660 account/devices must continue to follow  deleted program template*/
			if(OpsCenterConstants.TRUE.equals(prgTemp.getDeleteFlag())){
				String msg = "Program Template is Deleted " + prgTemp.getProgramTemplateId() + " - "+ prgTemp.getName();
				logger.debug(msg + " Pushing the programs from the deleted template. New programs shall be pushed when a new template has been applied");
//				throw new ProgramPushException(
//						DefaultResources.PRG_TMP_ERR_CODE_INVALID, errMsg);
			}
			

			// Obtain EsiTstatList for Esi_ID
			List<EsiTstat> esiTstatList = new ArrayList<EsiTstat>();
			esiTstatList = esiBeanFacade.getEsiTstatByEsiId(esi.getEsiId());
			logger.debug(" Number of TSTATs : " + esiTstatList.size());

			// Obtain EsiDcList for Esi_ID
			List<EsiDc> esiDcList = new ArrayList<EsiDc>();
			esiDcList = esiBeanFacade.getEsiDcByEsiId(esi.getEsiId());
			logger.debug(" Number of DCs : " + esiDcList.size());

			// Start - KRMT-3355
			if (esiDcList.size() == 0 && esiTstatList.size() == 0)
			{
				logger.debug(" No devices found for this Account " + esi.getAccountId().getAccountNumber() + " Esi " + esi.getEsiId());
				return false;
			}


			Set<ProgramTemplateProgram> prgTempPrgSet = prgTemp.getProgramTemplateProgramCollection();
			
			// This gets active and not deleted
			DateTime now = new DateTime();
			String userModified = OpsCenterConstants.PROVISIONING_USER;
			List<Program> programList = programBeanFacade.getProgramByAccountId(esi.getAccountId().getAccountId());
			for (Program prgm : programList)
			{
				for(ProgramTemplateProgram prgTempPrg : prgTempPrgSet)
				{
					if(!prgTempPrg.getName().equals(prgm.getName())){
					 continue;
					}
					
					logger.debug("Processing Program Template "+ prgTempPrg.getName());
					Set<ProgramTemplateDcTransitionPoint> tmplDcTransPointSet = prgTempPrg.getProgramTemplateDcTransitionPointCollection();
					Set<ProgramTemplateTstatTransitionPoint> tmplTstatTransPointSet = prgTempPrg.getProgramTemplateTstatTransitionPointCollection();
					
					for (EsiDc esiDc : esiDcList)
					{
						if (esiDc.getDeviceTypeId().getDeviceTypeName()
								.equalsIgnoreCase(OpsCenterConstants.DC_WATER_HEATER)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_POOL_PUMP)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_HVAC_SWITCH)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_SINGLE_HEAT)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_DUAL_HEAT)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_EV_CHARGER)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_IRRIGATION_PUMP)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_CROP_HEAT)
								||
								esiDc.getDeviceTypeId().getDeviceTypeName()
										.equalsIgnoreCase(OpsCenterConstants.DC_GENERATOR))
						{
							logger.debug("Checking if DC TPs exist for this EsiDc: " + esiDc.getEsiDcId() + ", program: " + prgm.getProgramId());
							List<DcTransitionPoint> currDcTransitionPointList = programBeanFacade.getDcTransitionPointByEsiDcIdProgramId(esiDc.getEsiDcId(), prgm.getProgramId());
							logger.debug(" Program Template DC Transition Points selected :" + currDcTransitionPointList.size());
							// If one transition point exists then don't need to add the program template transition points
							if (!currDcTransitionPointList.isEmpty())
							{
								continue;
							}
							
							for (ProgramTemplateDcTransitionPoint tmplDcTransPoint : tmplDcTransPointSet)
							{
								if(esiDc.getDeviceTypeId().getDeviceTypeId() != tmplDcTransPoint.getDeviceTypeId().getDeviceTypeId())
									continue;
								logger.debug(" Creating DC Transition Point Object");										
								DcTransitionPoint newDcTransitionPoint = new DcTransitionPoint();
								newDcTransitionPoint.setActiveFlag("1");
								newDcTransitionPoint.setDeleteFlag("0");
								newDcTransitionPoint.setTemporaryFlag("0");
								newDcTransitionPoint.setPowerStatusFlag(tmplDcTransPoint.getPowerStatusFlag());
								newDcTransitionPoint.setTpTime(tmplDcTransPoint.getTpTime());
								newDcTransitionPoint.setEsiDcId(esiDc);
								newDcTransitionPoint.setProgramId(prgm);
								newDcTransitionPoint.setDateCreated(now);
								newDcTransitionPoint.setUserCreated(userModified);
								newDcTransitionPoint.setDateModified(now);
								newDcTransitionPoint.setUserModified(userModified);
								programBeanFacade.createDcTransitionPoint(newDcTransitionPoint);
								logger.debug(" Adding DC Transition Point :" + newDcTransitionPoint.getDcTransitionPointId());
							}
						}
					/*	else
						{
							logger.debug("Found a fake DC : EsiDcId:" + esiDc.getEsiDcId() + ", Name:" +
									esiDc.getDeviceTypeId().getDeviceTypeName());
						}*/
					
					}
					
					for (EsiTstat esiTstat : esiTstatList)
					{
						logger.debug("Checking if TSTAT TPs exist for this TSTAT: " + esiTstat.getEsiTstatId() + ", program: " + prgm.getProgramId());
						List<TstatTransitionPoint> currTstatTransitionPointList = programBeanFacade.getTstatTransitionPointByEsiTstatIdProgramId(esiTstat.getEsiTstatId(), prgm.getProgramId());
						logger.debug(" Default Tstat Transition Points selected :" 	+ currTstatTransitionPointList.size());
						// If one transition point exists then don't need to add the program template transition points
						if (!currTstatTransitionPointList.isEmpty())
						{
							continue;
						}

						for (ProgramTemplateTstatTransitionPoint tmplTstatTransPoint : tmplTstatTransPointSet){	
							
							TstatTransitionPoint newTstatTransitionPoint = new TstatTransitionPoint();
							newTstatTransitionPoint.setTpTime(tmplTstatTransPoint.getTpTime());
							newTstatTransitionPoint.setPrefHeatTemp(tmplTstatTransPoint.getPrefHeatTemp());
							newTstatTransitionPoint.setPrefCoolTemp(tmplTstatTransPoint.getPrefCoolTemp());
							newTstatTransitionPoint.setMaxTemp(tmplTstatTransPoint.getMaxTemp());
							newTstatTransitionPoint.setMinTemp(tmplTstatTransPoint.getMinTemp());
							newTstatTransitionPoint.setOpModeId(tmplTstatTransPoint.getOpModeId());
							
							newTstatTransitionPoint.setEsiTstatId(esiTstat);
							newTstatTransitionPoint.setProgramId(prgm);
							newTstatTransitionPoint.setHoldStatus(OpsCenterConstants.FALSE);
							newTstatTransitionPoint.setActiveFlag("1");
							newTstatTransitionPoint.setDeleteFlag("0");
							newTstatTransitionPoint.setTemporaryFlag("0");
							newTstatTransitionPoint.setDateCreated(now);
							newTstatTransitionPoint.setUserCreated(userModified);
							newTstatTransitionPoint.setDateModified(now);
							newTstatTransitionPoint.setUserModified(userModified);
							
							programBeanFacade.createTstatTransitionPoint(newTstatTransitionPoint);
							logger.debug(" Adding TstatTransition Point :"	+ newTstatTransitionPoint.getTstatTransitionPointId());
							}
						}
				}
			}
		}
		catch (AbstractOpsCenterException e)
		{
			logger.error("Error in checkDevicesAndAssignDefaultProgramData", e);
			throw e;
		}

		return true;
	}
	
	
	
	/**
	 * @param esiDcList
	 * @return
	 */
	private boolean containsCyclingDeviceTypes(List<EsiDc> esiDcList)
	{
		for (EsiDc esiDc : esiDcList)
		{
			DeviceType deviceType = esiDc.getDeviceTypeId();
			if (deviceType != null)
			{
				if ((deviceType.getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_HVAC_SWITCH)
						|| deviceType.getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_SINGLE_HEAT)
						|| deviceType.getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_DUAL_HEAT)
					) && esiDc.getDeviceMacId() == 0)
				{
					//  dev-2110 only return true for legacy hvac_switch devices, we will allow prog for GS cause
					//1 switch could have hvs and non-hvs devices
					return true;
				}
			}
		}
		return false;
	}

	private User createConsumerUserFromAccModel(AccountModel accModel, String userName) throws Exception
	{

		logger.info("Entering createConsumerUserFromAccModel ");
		User user = null;
		user = userAccFacade.findUserByUsername(userName);
		if (user == null)
		{
			user = new User();
		}
		user.setActiveFlag(OpsCenterConstants.TRUE);
		user.setDeleteFlag(OpsCenterConstants.FALSE);
		user.setUsername(userName);
		user.setFirstName("GEuser");
		user.setLastName("GEuser");
		user.setHomePhoneNumber(accModel.getHomePhoneNumber());
		user.setAddr1Line1(accModel.getAddr1Line1());
		user.setAddr1Line2(accModel.getAddr1Line2());
		user.setAddr1City(accModel.getAddr1City());
		user.setAddr1State(accModel.getAddr1State());
		user.setAddr1Country(accModel.getAddr1Country());
		user.setAddr1Zip(accModel.getAddr1Zip());
		user.setBizPhoneNumber(accModel.getBizPhoneNumber());
		user.setDateCreated(new DateTime());
		user.setUserCreated("SSO User");
		user.setUserModified("SSO User");
		user.setDateModified(new DateTime());

		user.setFailureCount(0);
		user.setLockFlag(OpsCenterConstants.FALSE);
		user.setTermsAgrmntFlag(OpsCenterConstants.TRUE);
		// set security questions to first entry--customer not ever going
		// to change, but model requires it
		List<SecurityQuestion> questions = userAccFacade.getSecurityQuestion();
		user.setSecurityQuestionId(questions.get(0));
		user.setSecurityAnswer("SSO Login");
		// user will never login using pwd, so lets gen a fake one here
		// and encrypt it
		try
		{
			// dev-922 support SSO login for CSU
			// if pwd not yet created by user, then go ahead and generate one
			// otherwise leave the pwd
			// as is -since CSU user created it
			if (user.getPassword() == null || user.getPassword().isEmpty())
			{
				user.setPassword(EncryptService.getInstance().encrypt(generateRandomPassword()));
			}
		}
		catch (SystemUnavailableException e)
		{
			logger.error("createConsumerUserFromAccModel() - Exception during setPassword: "
					+ e.getMessage());
		}
		logger.debug("Random passwd generated on userName = " + user.getUsername());
		user.setPasswordResetFlag(OpsCenterConstants.FALSE);

		// now lets create a user
		try
		{
			userAccFacade.createUser(user);
		}
		catch (Exception e)
		{
			logger.error("createConsumerUserFromAccModel() - Exception during createUser: "
					+ e.getMessage());
			throw e;
		}
		// and the userAccountMap table as well
		createUserAccMap(user, accModel);
		logger.info("Exiting  createConsumerUserFromAccModel");

		return user;
	}

	/**
	 * @param accountSyncCacheData
	 * @param users
	 * @return
	 */
	private ConsertAccountSyncInfo createInfo(DatatypeFactory datatypeFactory,
			AccountSyncCacheData accountSyncCacheData, List<AccountUserSyncCacheData> users, long id)
	{
		ConsertAccountSyncInfo info = new ConsertAccountSyncInfo();
		info.setId(id);
		info.setAccountNumber(accountSyncCacheData.getAccountNumber());
		if (accountSyncCacheData.getBillingAccountNumber() != null
				|| accountSyncCacheData.getMeterLocationNumber() != null
				|| accountSyncCacheData.getUtilityNumber() != null
				|| accountSyncCacheData.getPremiseNumber() != null)
		{
			ConsertCompoundAccountKey key = new ConsertCompoundAccountKey();
			key.setBillingAccountNumber(accountSyncCacheData.getBillingAccountNumber());
			key.setMeterLocationNumber(accountSyncCacheData.getMeterLocationNumber());
			key.setUtilityNumber(accountSyncCacheData.getUtilityNumber());
			key.setPremiseNumber(accountSyncCacheData.getPremiseNumber());
			info.setCompoundAccountKey(key);
		}
		info.setConsumerCreatedCustomPrograms(accountSyncCacheData
				.isConsumerCreatedCustomPrograms());
		info.setConsumerLoginPossible(accountSyncCacheData.isConsumerLoginPossible());
		info.setConsumerSelfRegistered(accountSyncCacheData.isConsumerSelfRegistered());
		info.setEquipmentTypeAtLocation(ConsertEquipmentType.fromValue(accountSyncCacheData
				.getEquipmentTypeAtLocation().trim()));
		info.setReportingReadsViaBillingReports(accountSyncCacheData
				.isReportingReadsViaBillingReport());
		info.setStandaloneGatewaySerialNumber(accountSyncCacheData
				.getStandaloneGatewaySerialNumber());
		info.setElectricMeterNumber(accountSyncCacheData.getElectricMeterNumber());

		ConsertGatewayStatus status = new ConsertGatewayStatus();
		long gatewayStatusTime = accountSyncCacheData.getGatewayStatusTime();
		if (gatewayStatusTime > 0)
		{
			status.setLastCommunicationTime(datatypeFactory.newXMLGregorianCalendar(new DateTime(
					gatewayStatusTime).toGregorianCalendar()));
		}
		status.setLastKnownStatus(accountSyncCacheData.getGatewayStatus());
		info.setGatewayStatus(status);

		if (users != null)
		{
			for (AccountUserSyncCacheData accountUserSyncCacheData : users)
			{
				ConsertAccountUserSyncInfo userInfo = new ConsertAccountUserSyncInfo();
				userInfo.setBusinessPhone(accountUserSyncCacheData.getBusinessPhone());
				userInfo.setEmail(accountUserSyncCacheData.getEmail());
				userInfo.setFirstName(accountUserSyncCacheData.getFirstName());
				userInfo.setLastName(accountUserSyncCacheData.getLastName());
				userInfo.setMobilePhone(accountUserSyncCacheData.getMobilePhone());
				userInfo.setHomePhone(accountUserSyncCacheData.getHomePhone());
				info.getUser().add(userInfo);
			}
		}
		return info;
	}

	@Override
	public void createUser(UserModel userInfo, String email,
			int accountId, Integer tenantId) throws UserNameAlreadyExistsException,
			AccountNumberNotFoundException, Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("createUser() - starting.  userInfo: " + userInfo + "  email: " + email
				+ "  accountId: "
				+ accountId);
		
		User user = UserModel2User(userInfo);
		String forcePasswordReset = OpsCenterConstants.FALSE;

		// Check for existing user in the database.
		if (existUserName(user.getUsername()))
		{
			logger.info("createUser() - User Name already Exists: "
					+ user.getUsername());
			throw new UserNameAlreadyExistsException(
					DefaultResources.USR_ERR_CODE_USER_NAME_ALREADY_EXISTS,
					"User name already registered " + user.getUsername());

		}

		if (!UserBean.matchEmail(email.trim()))
		{
			logger.info("createUser() - Invalid Email format: " + email);
			return;
		}

		if (accountId <= 0)
		{
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountId);
		}

		// Account account = getAccountByAccountNumber(accountNumber);
		Account acc = userAccFacade.findAccountByAccountId(accountId);
		if (acc == null)
		{
			logger.info("createUser() - Account is NULL for account number: "
					+ accountId);
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountId);
		}
		// KRMT-3289 force password reset for utility user
		forcePasswordReset = OpsCenterConstants.TRUE;

		logger.info("createUser() - Building user in-memory object");
		user.setDeleteFlag(OpsCenterConstants.FALSE);
		user.setFailureCount(0);
		user.setLockFlag(OpsCenterConstants.FALSE);
		user.setActiveFlag(OpsCenterConstants.TRUE);
		user.setPasswordResetFlag(forcePasswordReset);
		user.setDateCreated(new DateTime());
		// User Modified is a non-null field, so it must be set
		user.setUserModified(user.getUserCreated());
		user.setDateModified(user.getDateCreated());

		// KRMT-1717, Primary email now lives in the user table in Rev 3.1
		if (userInfo.getEmail() != null)
		{
			user.setEmail(userInfo.getEmail());
		}

		user.setEmail(email);

		if (user.getTermsAgrmntFlag() == null)
		{
			user.setTermsAgrmntFlag(OpsCenterConstants.FALSE);
		}

		if (userInfo.getSecurityQuestionId() != 0)
		{
			List<SecurityQuestion> questions = userAccFacade
					.getSecurityQuestionBySecurityQuestionId(userInfo.getSecurityQuestionId());
			if (questions == null || questions.size() == 0)
			{
				logger.error("createUser() - Security question not found for question number: "
						+ userInfo.getSecurityQuestionId());
				throw new SecurityQuestionNumberNotFoundException(
						DefaultResources.SEC_CODE_QUESTION_NO_NOT_FOUND,
						"No Security Question found for question number "
								+ userInfo.getSecurityQuestionId());
			}

			// For a given security question ID there will never be more
			// than one question.
			user.setSecurityQuestionId(questions.get(0));
		}
		else
		{
			user.setSecurityQuestionId(null);
		}

		user.setPassword(EncryptService.getInstance().encrypt(
				user.getPassword()));

		try
		{
			logger.info("createUser() - Calling create() on userAccFacade");
			userAccFacade.createUser(user);

			logger.info("createUser() - Created User! : " + user.getUserId()
					+ " : " + user.getUsername());
			// force the entity to trigger commit-- so UI can use the user
			// object
			entityManager.flush();

		}
		catch (Exception ex)
		{
			logger
					.error("createUser() !! Caught Exception while creating user: "
							+ ex.getClass().getSimpleName()
							+ ": "
							+ ex.getMessage());
			ex.printStackTrace();
			throw ex;
		}

		UserAccountMap userAccountMap = new UserAccountMap();
		logger.info("createUser() - adding account map: userID = "
				+ user.getUserId());
		userAccountMap.setUserId(user);
		// userAccountMap.setEmail(email);
		userAccountMap.setEmailAlertsFlag(OpsCenterConstants.FALSE);
		userAccountMap.setPrimaryFlag(OpsCenterConstants.TRUE);
		userAccountMap.setAccountId(acc);

		userAccFacade.createUserAccountMap(userAccountMap);

		logger.info("createUser() - ending");
	}

	/**
	 * Creates a new user in DB The userId primary key is assigned internally in this function and
	 * not passed back
	 * 
	 * 2011-Nov-07 Update; Make the accountNumber argument optional, which implies that a Utility
	 * user is being created. Brockman
	 * 
	 * 
	 * @param User
	 *        new user to be created in DB
	 * @param accountNumber
	 *        Null if new user is Utility Persona
	 * 
	 * @return succesfully created user. Look up user by username in the future
	 */
	
	@Override
	public void createUser(UserModel userInfo, String email,
			String accountNumber, Integer tenantId) throws UserNameAlreadyExistsException,
			AccountNumberNotFoundException, Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("createUser() - starting.  userInfo: " + userInfo + "  email: " + email
				+ "  accountNumber: "
				+ accountNumber);
		Account account = null;
		User user = UserModel2User(userInfo);
		String forcePasswordReset = OpsCenterConstants.FALSE;

		// Check for existing user in the database.
		if (existUserName(user.getUsername()))
		{
			logger.info("createUser() - User Name already Exists: "
					+ user.getUsername());
			throw new UserNameAlreadyExistsException(
					DefaultResources.USR_ERR_CODE_USER_NAME_ALREADY_EXISTS,
					"User name already registered " + user.getUsername());

		}

		if (!UserBean.matchEmail(email.trim()))
		{
			logger.info("createUser() - Invalid Email format: " + email);
			return;
		}

		if (accountNumber != null)
		{
			account = getAccountByAccountNumber(accountNumber);
			if (account == null)
			{
				logger.info("createUser() - Account is NULL for account number: "
						+ accountNumber);
				throw new AccountNumberNotFoundException(
						DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
						"No Account found for account number " + accountNumber);
			}
		}
		else
		{
			// KRMT-3289 force password reset for utility user
			forcePasswordReset = OpsCenterConstants.TRUE;
		}

		logger.info("createUser() - Building user in-memory object");
		user.setDeleteFlag(OpsCenterConstants.FALSE);
		user.setFailureCount(0);
		user.setLockFlag(OpsCenterConstants.FALSE);
		user.setActiveFlag(OpsCenterConstants.TRUE);
		user.setPasswordResetFlag(forcePasswordReset);
		user.setDateCreated(new DateTime());
		// User Modified is a non-null field, so it must be set
		user.setUserModified(user.getUserCreated());
		user.setDateModified(user.getDateCreated());

		// KRMT-1717, Primary email now lives in the user table in Rev 3.1
		if (userInfo.getEmail() != null)
		{
			user.setEmail(userInfo.getEmail());
		}

		user.setEmail(email);

		if (user.getTermsAgrmntFlag() == null)
		{
			user.setTermsAgrmntFlag(OpsCenterConstants.FALSE);
		}

		if (userInfo.getSecurityQuestionId() != 0)
		{
			List<SecurityQuestion> questions = userAccFacade
					.getSecurityQuestionBySecurityQuestionId(userInfo.getSecurityQuestionId());
			if (questions == null || questions.size() == 0)
			{
				logger.error("createUser() - Security question not found for question number: "
						+ userInfo.getSecurityQuestionId());
				throw new SecurityQuestionNumberNotFoundException(
						DefaultResources.SEC_CODE_QUESTION_NO_NOT_FOUND,
						"No Security Question found for question number "
								+ userInfo.getSecurityQuestionId());
			}

			// For a given security question ID there will never be more
			// than one question.
			user.setSecurityQuestionId(questions.get(0));
		}
		else
		{
			user.setSecurityQuestionId(null);
		}

		user.setPassword(EncryptService.getInstance().encrypt(
				user.getPassword()));

		try
		{
			logger.info("createUser() - Calling create() on userAccFacade");
			userAccFacade.createUser(user);
			logger.info("createUser() - Created User! : " + user.getUserId()
					+ " : " + user.getUsername());
		}
		catch (Exception ex)
		{
			logger
					.error("createUser() !! Caught Exception while creating user: "
							+ ex.getClass().getSimpleName()
							+ ": "
							+ ex.getMessage());
			ex.printStackTrace();
			throw ex;
		}

		if (accountNumber != null)
		{

			UserAccountMap userAccountMap = new UserAccountMap();
			logger.info("createUser() - adding account map: userID = "
					+ user.getUserId());
			userAccountMap.setUserId(user);
			// userAccountMap.setEmail(email);
			userAccountMap.setEmailAlertsFlag(OpsCenterConstants.FALSE);
			userAccountMap.setPrimaryFlag(OpsCenterConstants.TRUE);
			userAccountMap.setAccountId(account);

			userAccFacade.createUserAccountMap(userAccountMap);
		}
		else
		{
			logger.info("createUser() - NOT Associating with account because accountNumber was null.");
		}

		logger.info("createUser() - ending");
	}

	
	public void createUserAccMap(User userInfo, AccountModel accModel)
	{
		logger.info("createUserAccMap() - starting" + userInfo.getUsername());
		if (accModel.getAccountNumber() != null)
		{

			UserAccountMap userAccountMap = new UserAccountMap();
			logger.info("adding account map: userID = " + userInfo.getUserId());
			userAccountMap.setUserId(userInfo);

			// userAccountMap.setEmail(cust.getEmail());
			userAccountMap.setEmailAlertsFlag(OpsCenterConstants.FALSE);
			userAccountMap.setPrimaryFlag(OpsCenterConstants.TRUE);
			userAccountMap.setAccountId(userAccFacade.getRefAccountByAccountId(accModel
					.getAccountId()));

			try
			{
				userAccFacade.createUserAccountMap(userAccountMap);
			}
			catch (Exception e)
			{
				logger.error("createUserAccMap() - Exception during createUserAccountMap", e);
			}
		}
		else
		{
			logger.info("createUserAccMap() - NOT Associating with account because accountNumber was null.");
		}

		logger.info("createUserAccMap() - ending");

	}

	private User createUtilityUser(String userName, List<Integer> roleList)
	{

		logger.info("Entering  createUtilityUser - UserName = " + userName);

		User user = new User();
		user.setActiveFlag(OpsCenterConstants.TRUE);
		user.setDeleteFlag(OpsCenterConstants.FALSE);
		user.setUsername(userName);
		user.setFirstName("GEuser");
		user.setLastName("GEuser");
		user.setAddr1Line1("ge utility location");
		user.setAddr1City("NorCross");
		user.setAddr1State("Georgia");
		user.setAddr1Zip("99999");
		user.setAddr1Country("USA");
		user.setDateCreated(new DateTime());
		user.setUserCreated("SSO Utility User");
		user.setUserModified("SSO Utility User");
		user.setDateModified(new DateTime());

		user.setFailureCount(0);
		// acc object does not have fax #-- so stick in home #
		user.setLockFlag(OpsCenterConstants.FALSE);
		user.setTermsAgrmntFlag(OpsCenterConstants.TRUE);
		// set security questions to first entry--customer not ever going
		// to change, but model requires it
		List<SecurityQuestion> questions = userAccFacade.getSecurityQuestion();
		user.setSecurityQuestionId(questions.get(0));
		user.setSecurityAnswer("GE");

		// user will never login using pwd, so lets gen a fake one here
		// and encrypt it
		try
		{
			user.setPassword(EncryptService.getInstance().encrypt(generateRandomPassword()));
		}
		catch (SystemUnavailableException e)
		{
			logger.error("createUtilityUser() - Exception during setPassword: " + e.getMessage());
		}
		user.setPasswordResetFlag(OpsCenterConstants.FALSE);

		// now lets create a user
		try
		{
			userAccFacade.createUser(user);
		}
		catch (Exception e)
		{
			logger.error("createUtilityUser() - Exception during createUser: " + e.getMessage());
		}
		logger.debug("User created in DB, userId = " + user.getUserId());

		for (int roleId : roleList)
		{

			Role role = userAccFacade.getRefRoleByRoleId(roleId);
			UserRoleMap mapToBeAdded = new UserRoleMap();
			mapToBeAdded.setUserId(user);
			mapToBeAdded.setRoleId(role);
			logger.debug("UserRoleMap added to DB, role = " + role.getRoleName());
			try
			{
				userAccFacade.createUserRoleMap(mapToBeAdded);
				logger.debug("UserRoleMap added to DB, role = " + role.getRoleName());
			}
			catch (Exception e)
			{
				logger.error("createUtilityUser() - Exception during createUserRoleMap: "
						+ e.getMessage());
			}
		}
		return user;
	}

	/**
	 * Mark a user as deleted in the database. KRMT-1717
	 * 
	 * @author brockman
	 * @param username
	 */

	@Override
	public void deleteUser(int userId, Integer tenantId)
			throws UserNotUniqueException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("deleteUser() - starting for userId = " + userId);

		User user = userAccFacade.findUserByUserId(userId);
		if (user == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "UserId "
							+ userId + " Not Found");
		}

		try
		{
			UserModel origUser = User2UserModel(user);

			user.setDateModified(new DateTime());
			user.setUserModified(user.getUsername());
			user.setDeleteFlag(OpsCenterConstants.TRUE);
			user.setActiveFlag(OpsCenterConstants.FALSE);
			updateUserInDatabase(user, origUser);
			logger.info("user updated successfuly to delete: " + user.getUsername());
		}
		catch (Exception x)
		{
			logger.error("Internal exception while deleting user: " + x.getMessage(), x);
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
					"Internal exception while deleting user: " + x);
		}
		logger.info("deleteUser() - ending");

	}

	/**
	 * Verifies if utility account number already exists
	 * 
	 * Case account number is not valid will return false
	 * 
	 * @param accountNumber
	 * @return
	 */
	
	public boolean existAccountNumber(String accountNumber)
	{
		logger.info("existAccountNumber() - starting");
		logger.info("Account number: " + accountNumber);

		if (accountNumber == null || "".equals(accountNumber))
		{
			return false;
		}

		/* Get Account object based on utility account number */
		List<Account> accounts = userAccFacade
				.getAccountByAccountNumber(accountNumber);

		if (accounts == null)
		{
			return false;
		}

		logger.info("account number exists: " + !accounts.isEmpty());
		logger.info("getUserByAccountNumber() - ending");
		return !accounts.isEmpty();
	}

	/**
	 * Verifies if user name already exists.
	 * 
	 * Case user name is not valid will return false
	 * 
	 * @param userName
	 *        User name
	 * @return Boolean True if user name found, False otherwise
	 */
	
	public boolean existUserName(String userName)
	{
		boolean existUser = false;
		logger.info("existUserName() - starting");
		logger.info("Username: " + userName);

		if (userName == null || "".equals(userName))
		{
			return false;
		}
		/* Get User object based on user name */
		List<User> users = userAccFacade.getUserByUsername(userName);
		if (users == null || users.isEmpty())
		{
			existUser = false;
		}
		else
		{
			existUser = true;
		}

		logger.info("usernamee exists " + existUser);
		logger.info("existUserName() - ending");

		return existUser;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#findAllUtilityPersonaUserRoles()
	 */
	
	@Override
	public List<RoleModel> findAllUtilityPersonaUserRoles(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<Role> utilityRoles = userAccFacade.getRoleByUtilityFlag();
		List<RoleModel> utilityRoleModels = new ArrayList<RoleModel>();
		for (Role role : utilityRoles)
		{
			RoleModel roleModel = new RoleModel();

			roleModel.setRoleId(role.getRoleId());
			roleModel.setRoleName(role.getRoleName());
			roleModel.setUtilityFlag(role.getUtilityFlag());
			roleModel.setComments(role.getComments());
			roleModel.setDefaultFlag(role.getDefaultFlag());
			
			utilityRoleModels.add(roleModel);
		}

		return utilityRoleModels;
	}

	/**
	 * @param changedAccountsAndUsers
	 * @param oldAccountKeysToRemove
	 * @return
	 */
	private void findOutOfSync(
			HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>> changedAccountsAndUsers,
			List<Serializable> oldAccountKeysToRemove)
	{

		HashMap<Integer, List<AccountUserSyncCacheData>> changedUsersByAccountId = new HashMap<Integer, List<AccountUserSyncCacheData>>();
		List<AccountSyncCacheData> changedAccounts = new ArrayList<AccountSyncCacheData>();

		Cache accountSyncCache = cacheManager.getAccountSyncCache();
		Cache accountUserSyncCache = cacheManager.getAccountUserSyncCache();

		// Populating accountUserMap
		Results accountUserSyncResults = cacheManager.getCacheData(accountUserSyncCache);
		HashMap<Serializable, AccountUserSyncCacheData> accountUserMap = new HashMap<Serializable, AccountUserSyncCacheData>();
		List<Result> accountUserList = accountUserSyncResults.all();
		for (Result result : accountUserList)
		{
			AccountUserSyncCacheData acountUserSyncCacheData = (AccountUserSyncCacheData) result
					.getValue();
			accountUserMap.put(acountUserSyncCacheData.getCacheKey(), acountUserSyncCacheData);
		}
		accountUserList = null;
		accountUserSyncResults.discard();
		accountUserSyncResults = null;

		// Using accountUserMap to populate accountIdsWithUserMods &
		// changedUsersByAccountId
		HashSet<Integer> accountIdsWithUserMods = new HashSet<Integer>();

		List<AccountUserSyncCacheData> accountUserSyncData = userAccFacade
				.getAllAccountUserSyncData();
		for (AccountUserSyncCacheData accountUserDb : accountUserSyncData)
		{
			AccountUserSyncCacheData accountUserCache = accountUserMap.get(accountUserDb
					.getCacheKey());
			if (accountUserCache == null || !accountUserCache.equals(accountUserDb))
			{
				if (accountUserCache == null)
				{
					logger.debug("accountUserCache == null, accountIdsWithUserMods.add()=["
							+ accountUserDb.getAccountId() + ", " + accountUserDb.getUsrId() + "]");
				}
				else
				{
					logger.debug("accountIdsWithUserMods.add(), db=" + accountUserDb + ", cache="
							+ accountUserCache);
				}
				accountIdsWithUserMods.add(accountUserDb.getAccountId());
			}
			List<AccountUserSyncCacheData> users = changedUsersByAccountId.get(accountUserDb
					.getAccountId());
			if (users == null)
			{
				users = new ArrayList<AccountUserSyncCacheData>();
				changedUsersByAccountId.put(accountUserDb.getAccountId(), users);
			}
			users.add(accountUserDb);
			accountUserMap.remove(accountUserDb.getCacheKey());
		}
		accountUserSyncData = null;

		// Handle old values no longer present
		Collection<AccountUserSyncCacheData> oldCacheValues = accountUserMap.values();
		for (AccountUserSyncCacheData accountUserSyncCacheData : oldCacheValues)
		{
			logger.debug("accountUserDb == null, accountIdsWithUserMods.add()=["
					+ accountUserSyncCacheData.getAccountId() + ", "
					+ accountUserSyncCacheData.getUsrId() + "]");
			accountIdsWithUserMods.add(accountUserSyncCacheData.getAccountId());
		}
		accountUserMap.clear();
		accountUserMap = null;

		// Populating accountMap
		Results accountSyncResults = cacheManager.getCacheData(accountSyncCache);
		HashMap<Integer, AccountSyncCacheData> accountMap = new HashMap<Integer, AccountSyncCacheData>();
		List<Result> accountList = accountSyncResults.all();
		for (Result result : accountList)
		{
			AccountSyncCacheData acountSyncCacheData = (AccountSyncCacheData) result.getValue();
			accountMap.put(acountSyncCacheData.getAccountId(), acountSyncCacheData);
		}
		accountList = null;
		accountSyncResults.discard();
		accountSyncResults = null;

		// Using accountMap & accountIdsWithUserMods to populate changedAccounts
		List<AccountSyncCacheData> accountSyncDbList = userAccFacade.getAllAccountSyncData();
		for (AccountSyncCacheData accountDb : accountSyncDbList)
		{
			AccountSyncCacheData accountCache = accountMap.get(accountDb.getAccountId());
			if (accountCache == null || accountIdsWithUserMods.contains(accountDb.getAccountId())
					|| !accountCache.equals(accountDb))
			{
				if (accountCache == null)
				{
					logger.debug("accountCache==null, changedAccounts.add()="
							+ accountDb.getAccountId());
				}
				else if (accountIdsWithUserMods.contains(accountDb.getAccountId()))
				{
					logger.debug("accountIdsWithUserMods.contains(accountDb.getAccountId()), changedAccounts.add()="
							+ accountDb.getAccountId());
				}
				else
				{
					logger.debug("changedAccounts.add(), db=" + accountDb + ", cache="
							+ accountCache);
				}
				changedAccounts.add(accountDb);
			}
			else
			{
				changedUsersByAccountId.remove(accountDb.getAccountId());
			}
			accountMap.remove(accountDb.getAccountId());
		}
		accountSyncDbList = null;
		accountIdsWithUserMods.clear();
		accountIdsWithUserMods = null;

		// Any values left in account map can be removed from cache
		Collection<AccountSyncCacheData> oldAccountCacheValues = accountMap.values();
		for (AccountSyncCacheData accountSyncCacheData : oldAccountCacheValues)
		{
			oldAccountKeysToRemove.add(accountSyncCacheData.getCacheKey());
		}
		accountMap.clear();
		accountMap = null;

		logger.debug("changedAccounts.size()=" + changedAccounts.size()
				+ ", oldAccountKeysToRemove.size()="
				+ oldAccountKeysToRemove.size());

		// Combining changedAccounts & changedUsersByAccountId to get
		// changedAccountsAndUsers
		for (AccountSyncCacheData accountSyncCacheData : changedAccounts)
		{
			List<AccountUserSyncCacheData> users = changedUsersByAccountId.get(accountSyncCacheData
					.getAccountId());
			changedAccountsAndUsers.put(accountSyncCacheData, users);
		}

	}

	/**
	 * Gets a user based on its username.
	 * 
	 * @param username
	 * @throws
	 */
	
	public User findUserByUsername(String username)
			throws UserNotUniqueException
	{
		logger.info("[ENTER] User UserBean.findUserByUsername(String username) " + username);

		return userAccFacade.findUserByUsername(username);
	}

	// for presentation layer
	
	public UserModel findUserInfoByUsername(String username,Integer tenantId)
			throws UserNotUniqueException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] UserModel UserBean.findUserInfoByUsername(String username) "
				+ username);
		
		User user = userAccFacade.findUserByUsername(username);

		if (user == null)
		{
			logger.info("[ EXIT] UserBean.findUserInfoByUsername");
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
							+ username + " Not Found");
		}

		UserModel userModel = User2UserModel(user);

		logger.info("findUserByUsername() - ending userId = "
				+ userModel.getUserId());
		logger.info("[ EXIT] UserBean.findUserInfoByUsername");

		return userModel;
	}

	/*
	 * Finder method to look up all users that are associated with a specific
	 * account.
	 * 
	 * @param accountId
	 * 
	 * @return
	 * 
	 * @throws AccountNotFoundException
	 */
	
	public List<UserModel> findUserModelsByAccountId(int accountId, Integer tenantId)
			throws AccountNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		// Ensure that the account Exists before going and looking up users.
		AccountModel account = getAccountInfoById(accountId, tenantId);
		if (account == null)
		{
			throw new AccountNotFoundException("Failed retrieving Account for accountId="
					+ accountId);
		}

		// Scan the association of user -> account mapping table
		List<UserModel> userModels = new ArrayList<UserModel>();
		List<UserAccountMap> userAccountMaps = null;

		try
		{
			userAccountMaps = userAccFacade
					.getUserAccountMapByAccountId(accountId);
		}
		catch (Exception e)
		{
			throw new AccountNotFoundException(
					"Failed retrieving UserAccountMap for accountId="
							+ accountId + ", Exception: " + e);
		}

		// TODO - CR DEV-1489 IP Opt-out
		if (userAccountMaps == null || userAccountMaps.isEmpty())
		{
			throw new AccountNotFoundException(
					"UserAccountMap not found for accountId=" + accountId);
		}

		// Resolve each of the matched users into UserModels and return them in
		// a new List
		for (UserAccountMap userAccountMap : userAccountMaps)
		{
			User user = userAccountMap.getUserId();

			// Do not return any deleted users.
			if (OpsCenterConstants.TRUE.equals(user.getDeleteFlag()))
			{
				continue;
			}

			UserModel userModel = new UserModel();
			userModel.setUserId(user.getUserId());
			userModel.setFirstName(user.getFirstName());
			userModel.setLastName(user.getLastName());
			userModel.setHomePhoneNumber(user.getHomePhoneNumber());
			userModel.setBizPhoneNumber(user.getBizPhoneNumber());
			userModel.setMobPhoneNumber(user.getMobPhoneNumber());
			userModel.setFaxNumber(user.getFaxNumber());
			userModel.setUsername(user.getUsername());
			//userModel.setPassword(user.getPassword());
			userModel.setAddr1Line1(user.getAddr1Line1());
			userModel.setAddr1Line2(user.getAddr1Line2());
			userModel.setAddr1City(user.getAddr1City());
			userModel.setAddr1State(user.getAddr1State());
			userModel.setAddr1Zip(user.getAddr1Zip());
			userModel.setAddr1Country(user.getAddr1Country());
			userModel.setLockFlag(user.getLockFlag());
			userModel.setTermsAgrmntFlag(user.getTermsAgrmntFlag());
			userModel.setFailureCount(user.getFailureCount());
			userModel.setUserCreated(user.getUserCreated());
			userModel.setUserModified(user.getUserModified());
			userModel.setDateCreated(user.getDateCreated());
			userModel.setDateModified(user.getDateModified());
			userModel.setActiveFlag(user.getActiveFlag());
			userModel.setSecurityAnswer(user.getSecurityAnswer());
			userModel.setSecurityQuestionId(user.getSecurityQuestionId()
					.getSecurityQuestionId());

			userModel.setPasswordResetFlag(user.getPasswordResetFlag());

			// KRMT-3359 set UserTimeZoneModel
			userModel.setUserTimeZoneModel(getUserTimeZoneModelforUser(user));
			userModel.setDatePasswordModified(user.getDatePasswordModified());
			userModels.add(userModel);
		}

		// IMPORTANT the List must be serializable, so should be ArrayList or
		// LinkedList
		return userModels;
	}

	/**
	 * Generated random user password
	 * 
	 * @return
	 */
	
	public String generateRandomPassword()
	{
		int n = 8;
		char[] pw = new char[n];
		int c = 'A';
		int r1 = 0;
		for (int i = 0; i < n; i++)
		{
			r1 = (int) (Math.random() * 3);
			switch (r1)
			{
				case 0:
					c = '0' + (int) (Math.random() * 10);
					break;
				case 1:
					c = 'a' + (int) (Math.random() * 26);
					break;
				case 2:
					c = 'A' + (int) (Math.random() * 26);
					break;
				default:
					break;
			}
			pw[i] = (char) c;
		}
		return new String(pw);
	}

	/**
	 * Get account by utility account number
	 * 
	 * @return List Accounts with same account number
	 */
	public Account getAccountByAccountNumber(String accountNumber)
	{
		List<Account> accounts = null;

		logger.info("getAccountByAccountNumber() - starting accountNumber = "
				+ accountNumber);

		/* Utility account number not valid */
		if (accountNumber == null || accountNumber.isEmpty())
		{
			return null;
		}

		accounts = userAccFacade.getAccountByAccountNumber(accountNumber);
		if (accounts.isEmpty())
		{
			accounts = userAccFacade.getAccountByAccountNumberStripped(accountNumber);
			if (accounts.isEmpty())
			{
				return null;
			}
			return accounts.get(0);
		}
		return accounts.get(0);
	}

	/**
	 * Given an account meter location number, return all associated accounts
	 * 
	 * @param meterLocationNumber
	 * @return
	 */
	
	public List<AccountModel> getAccountByMeterLocationNumber(String meterLocationNumber)
	{
		List<AccountModel> accountModels = new ArrayList<AccountModel>();

		List<ExternalAccountXRef> xrefList = userAccFacade
				.getAccountXRefByNonNullBillingAccountNumberPremiseNumberMeterLocationNumberUtilityNumber(null, null, meterLocationNumber, null);

		accountModels = accountXRefToAccounts(xrefList);

		return accountModels;
	}

	/**
	 * Given an account utility number, return all associated accounts
	 * 
	 * @param utilityNumber
	 * @return
	 */
	
	public List<AccountModel> getAccountByUtilityNumber(String utilityNumber)
	{
		List<AccountModel> accountModels = new ArrayList<AccountModel>();

		List<ExternalAccountXRef> xrefList = userAccFacade
				.getAccountXRefByNonNullBillingAccountNumberPremiseNumberMeterLocationNumberUtilityNumber(null, null, null, utilityNumber);

		accountModels = accountXRefToAccounts(xrefList);

		return accountModels;
	}

	/**
	 * Added as an internal convenience method to support the publicly facing getAccountInfoById
	 * that returns the model. Copy + pasted from getAccountByAccountNumber
	 * 
	 * @param accountId
	 * @return
	 */

	private Account getAccountEntityById(int accountId)
	{
		List<Account> accounts;

		// logger.info("getAccountEntityById( " + accountId + ") - starting");

		// ID Not valid check
		if (accountId <= 0)
		{
			return null;
		}

		accounts = userAccFacade.getAccountByAccountId(accountId);
		if (accounts == null || accounts.isEmpty())
		{
			return null;
		}

		return accounts.get(0);
	}

	// for presentation layer
	
	public AccountModel getAccountInfoByAccountNumber(String accountNumber, Integer tenantId)
			throws AccountNumberNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		Account account = getAccountByAccountNumber(accountNumber);

		if (account == null)
		{
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountNumber);
		}
		AccountModel accountModel = Account2AccountModel.convert(account, esiBeanFacade,
				userAccFacade);
		return accountModel;

	}

	/**
	 * Finder method to look up account Info by ID. Used by Utility search portal.
	 * 
	 * @param accountId
	 * @return
	 * @throws AccountNumberNotFoundException
	 */

	@Override
	public AccountModel getAccountInfoById(int accountId, Integer tenantId)
			throws AccountNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] AccountModel UserBean.getAccountInfoById(int accountId) " + accountId);

		Account account = getAccountEntityById(accountId);
		if (account == null)
		{
			logger.info("[ EXIT] UserBean.getAccountInfoById");
			throw new AccountNotFoundException(
					DefaultResources.ACC_ERR_ACCOUNT_NOT_FOUND,
					"No Account found for account id=" + accountId);
		}

		AccountModel accountModel = Account2AccountModel.convert(account, esiBeanFacade,
				userAccFacade);

		logger.info("[ EXIT] UserBean.getAccountInfoById");

		return accountModel;
	}

	/**
	 * Get the Account Definition data.
	 */
	
	@Override
	public AccountPartsModel getAccountParts(Integer tenantId) throws Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		return getAccountParts();
	}
	
	@Override
	public AccountPartsModel getAccountParts() throws Exception
	{
		CompoundAccountKey compoundAccountKey = new CompoundAccountKey();
		return compoundAccountKey.getAccountParts();
	}

	/**
	 * Given an account premise number, return all associated accounts
	 * 
	 * @param premiseNumber
	 * @return
	 */
	
	public List<AccountModel> getAccountsByPremiseNumber(String premiseNumber)
	{
		List<AccountModel> accountModels = new ArrayList<AccountModel>();

		List<ExternalAccountXRef> xrefList = userAccFacade
				.getAccountXRefByNonNullBillingAccountNumberPremiseNumberMeterLocationNumberUtilityNumber(null, premiseNumber, null, null);

		accountModels = accountXRefToAccounts(xrefList);

		return accountModels;
	}

	/**
	 * @param accountId
	 * @return
	 */
	
	@Override
	public AccountStatusModel getAccountStatusByAccountId(int accountId, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		List<Account> accList = userAccFacade.getAccountByAccountId(accountId);
		if (accList != null && !accList.isEmpty())
		{
			Account account = accList.get(0);
			AccountSummary accountSummary = new AccountSummary(account);

			AccountStatusModel accountStatusModel = accountSummary.getAccountStatus();
			logger.debug("accountStatusModel.getDcTransitionPoint() = "
					+ accountStatusModel.getDcTransitionPoint());

			return accountStatusModel;
		}

		throw new AccountNotFoundException(accountId);
	}

	/**
	 * @param accountNumber
	 * @return
	 */
	public AccountStatusModel getAccountStatusByAccountNumber(String accountNumber)
			throws AbstractOpsCenterException
	{
		List<Account> accList = userAccFacade.getAccountByAccountNumber(accountNumber);
		if (accList != null && !accList.isEmpty())
		{
			Account account = accList.get(0);
			AccountSummary accountSummary = new AccountSummary(account);

			AccountStatusModel accountStatusModel = accountSummary.getAccountStatus();

			return accountStatusModel;
		}

		throw new AccountNotFoundException(accountNumber);
	}


	@Override
	public List<EsiAlertCountModel> getAlertCounts(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return esiBeanFacade.getCountsForEsiAlertModelAlertCodeAlertClearedNullVisible();
	}

	@Override
	public List<EsiAlertModel> getAlertsByCode(int alertCode, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return esiBeanFacade.getEsiAlertModelAlertCodeAlertClearedNullVisible(alertCode);
	}

	@Override
	public void hideAlert(EsiAlertModel model, Integer tenantId) {
		TenantContext.setCurrentTenant(tenantId);
		List<EsiAlert> esiAlertList = esiBeanFacade.getEsiAlertByEsiAlertId(model.getEsiAlertId());
		EsiAlert alert = (esiAlertList == null || esiAlertList.isEmpty()) ? null : esiAlertList.get(0);
		if (alert != null)
		{
			DateTime hideTimestamp = model.getHideTimestamp() == null ? new DateTime() : model.getHideTimestamp();
			alert.setHideTimestamp(hideTimestamp);
			alert.setHideUsrname(model.getHideUsrname());
		}
	}

	/**
	 * @param accountNumber
	 * @return
	 */
	@Override
	public AccountAlertsModel getAlertsByAccountId(AccountDataFilterCriteriaModel model, Integer tenantId)
			throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		List<Account> accList = userAccFacade.getAccountByAccountId(model.getAccountId());
		if (accList != null && !accList.isEmpty())
		{
			Account account = accList.get(0);
			AccountAlerts accountAlerts = new AccountAlerts();
			return accountAlerts
					.getAlertsByAccount(account, model.getFromTime(), model.getToTime());
		}

		throw new AccountNotFoundException(model.getAccountId());
	}

	/**
	 * @param accountNumber
	 * @return
	 */
	public AccountAlertsModel getAlertsByAccountNumber(String accountNumber, DateTime fromTime,
			DateTime toTime) throws AbstractOpsCenterException
	{
		List<Account> accList = userAccFacade.getAccountByAccountNumber(accountNumber);
		if (accList != null && !accList.isEmpty())
		{
			Account account = accList.get(0);
			AccountAlerts accountAlerts = new AccountAlerts();
			return accountAlerts.getAlertsByAccount(account, fromTime, toTime);
		}

		throw new AccountNotFoundException(accountNumber);
	}

	// for presentation layer
	// krmt6212-- return back all accounts using the passed in acc # to support
	// CompoundAccountKey
	
	@Override
	public List<AccountModel> getAllAccountInfoByAccountNumber(String accountNumber, Integer tenantId)
			throws AccountNumberNotFoundException, EsiNotFoundException, AccountWithThirdPartyDeviceOnlyException, EsiDcNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("getAllAccountInfoByAccountNumber() - starting");

		// Account account = getAccountByAccountNumber(accountNumber);
		List<Account> accList = userAccFacade
				.getAllAccountByAccountNumberWithActiveEsi(accountNumber);

		List<AccountModel> accsModelList = new ArrayList<AccountModel>();

		if (accList == null || accList.size() <= 0)
		{
			accList = userAccFacade.getAccountByAccountNumber(accountNumber);
			if (accList == null || accList.size() <= 0)
			{
				throw new AccountNumberNotFoundException(
						DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
						"No Account found for account number " + accountNumber);
			}
			throw new EsiNotFoundException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"No active ESIs found for account number " + accountNumber);
		}
		logger.debug("got good list of accounts, accList size = " + accList.size());
		//check if account has all third party tstats
		for(Account acnt:accList)
		{
			AccountModel accountModel = Account2AccountModel.convert(acnt, esiBeanFacade,userAccFacade);
			if(accountModel.getThirdPartyDeviceOnly())
			{
				throw new AccountWithThirdPartyDeviceOnlyException(DefaultResources.ACC_ERR_CODE_THIRD_PARTY_DEVICE_ONLY, "Account has only third party devices: "+accountNumber); 
			}
			if(accountModel.getAmiOnlyFlag().equalsIgnoreCase(OpsCenterConstants.TRUE))
			{
				
				throw new EsiDcNotFoundException(DefaultResources.ACC_ERR_CODE_DC_NOT_FOUND, "No active esi dc found");
			}
			accsModelList.add(accountModel);
		}

		logger.info("getAllAccountInfoByAccountNumber() - ending");

		return accsModelList;
	}

	/**
	 * Gets the list of secret questions available in system
	 * 
	 * @return List
	 */
	
	public List<SecurityQuestionModel> getAvailableQuestions(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<SecurityQuestion> securityQuestions = null;
		List<SecurityQuestionModel> securityQuestionModels = new ArrayList<SecurityQuestionModel>();

		logger.info("getAvailableQuestions() - starting");

		securityQuestions = userAccFacade.getSecurityQuestion();

		for (SecurityQuestion question : securityQuestions)
		{
			SecurityQuestionModel questionM = new SecurityQuestionModel();
			questionM.setSecurityQuestionId(question.getSecurityQuestionId());
			questionM.setSecurityQuestionName(question
					.getSecurityQuestionName());
			securityQuestionModels.add(questionM);
		}

		logger.info("getAvailableQuestions() - ending");
		/* Get security question based on user */
		return securityQuestionModels;
	}

	private String getCacheKey(int devid, String gwKey)
	{
		StringBuffer id = new StringBuffer();
		id.append(devid);
		//TODO @JPN KRMT-6479 - Missed merge from 3.4 to 4.0
		id.append("|");
		id.append(gwKey);
		return id.toString();
	}

	/**
	 * @author David Conklin
	 * @param String
	 *        accountNumber
	 * @return List<DeviceDC>
	 * 
	 *         this method is used to return the device associated to a ACCOUNT with account number
	 * 
	 */
	
	public List<EsiDc> getDeviceListForAccount(int accountId)
			throws EsiNotUniqueException, EsiNotFoundException
	{

		List<EsiDc> listOfDevicesForAccount = null;

		// get the esi id for account number..make sure there is only one esi
		// for an account
		
		logger.info("Consertx : Tenant id here : "+TenantContext.getCurrentTenant());
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(accountId);
		logger.info("Consertx : esiList.size : " + esiList.size());
		if (!esiList.isEmpty() && esiList.size() == 1)
		{
			Esi esi = esiList.get(0);
			// Want to include deleted
			Set<EsiDc> esiDcCollection = esi.getEsiDcCollection();
			
			for (EsiDc esiDc : esiDcCollection)
			{
				esiDc.getManageModeId();
				esiDc.getEsiTstatCollection();
				Dc dc = esiDc.getDcId();
				dc.getDeviceTypeId();
			}
			
			listOfDevicesForAccount = new ArrayList<EsiDc>(esiDcCollection.size());
			listOfDevicesForAccount.addAll(esiDcCollection);

			// int esiId = esi.getEsiId();
			//
			// // get the device list for the esi
			// listOfDevicesForAccount = esiBeanFacade.getEsiDcByEsiId(esiId);

		}
		else
		{
			if (esiList.isEmpty())
			{
				throw new EsiNotFoundException(
						DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"ESI not found for account " + accountId);
			}
			throw new EsiNotUniqueException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"More than one ESI found for account " + accountId);
		}

		return listOfDevicesForAccount;

	}

	/**
	 * @param accountId
	 * @param fromTime
	 * @param toTime
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	
	public AccountHistoryModel getFullAccountHistory(AccountDataFilterCriteriaModel model)
			throws AbstractOpsCenterException
	{
		AccountHistoryGenerator accountHistoryGenerator = new AccountHistoryGenerator();
		return accountHistoryGenerator.getFullAccountHistory(model.getAccountId(),
				model.getFromTime(), model.getToTime());
	}

	/**
	 * @param accountId
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	
	@Override
	public AccountHistoryModel getFullAccountHistory(int accountId, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		DateTime toTime = new DateTime();
		DateTime fromTime = new DateTime(toTime.minusDays(90));
		AccountDataFilterCriteriaModel model = new AccountDataFilterCriteriaModel();
		model.setAccountId(accountId);
		model.setToTime(toTime);
		model.setFromTime(fromTime);
		return getFullAccountHistory(model);
	}

	/**
	 * Get the hardware type for an account
	 * 
	 * @param accountId
	 * @return
	 */

	
	public String getHardwareTypeAccount(int accountId)
			throws AbstractOpsCenterException
	{

		// Default to VPP
		String hardwareSet = OpsCenterConstants.VERIZON_CELLULAR_DELIVERY;
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(accountId);
		if (!esiList.isEmpty() && esiList.size() == 1)
		{
			Esi esi = esiList.get(0);
			if (esi.getNetworkDeliveryId() == OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID)
			{
				hardwareSet = OpsCenterConstants.GRIDSTREAM_RF_DELIVERY;
			}
			else if (esi.getNetworkDeliveryId() == OpsCenterConstants.EU_PLC_ID)
			{
				hardwareSet = OpsCenterConstants.EU_PLC;
			}
		}

		return hardwareSet;
	}

	/**
	 * @param userRoleMapList
	 * @return
	 */
	private List<RoleModel> getRolesFor(Collection<UserRoleMap> userRoleMapList)
	{
		List<RoleModel> rolesForUser = new ArrayList<RoleModel>();
		Set<Integer> uniqueSet = new HashSet<Integer>();
		for (UserRoleMap map : userRoleMapList)
		{
			Role role = map.getRoleId();
			if(!uniqueSet.add(role.getRoleId())){
				continue;
			}
			RoleModel roleModel = new RoleModel();
			roleModel.setRoleId(role.getRoleId());
			roleModel.setRoleName(role.getRoleName());
			roleModel.setUtilityFlag(role.getUtilityFlag());
			roleModel.setComments(role.getComments());
			roleModel.setDefaultFlag( role.getDefaultFlag());
			rolesForUser.add(roleModel);
		}

		return rolesForUser;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#getRolesForUser(int)
	 */
	
	public List<RoleModel> getRolesForUser(int userId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<UserRoleMap> userRoleMapList = userAccFacade.getUserRoleMapByUserId(userId);
		return getRolesFor(userRoleMapList);
	}

	/**
	 */
	
	public List<EsiTstat> getTstatListForAccount(int accountId)
			throws EsiNotUniqueException, EsiNotFoundException
	{

		List<EsiTstat> listOfTstatsForAccount = null;

		// get the esi id for account number..make sure there is only one esi
		// for an account
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(accountId);
		if (!esiList.isEmpty() && esiList.size() == 1)
		{
			Esi esi = esiList.get(0);
			// Want to include deleted
			Set<EsiTstat> esiTstatCollection = esi.getEsiTstatCollection();
			listOfTstatsForAccount = new ArrayList<EsiTstat>(esiTstatCollection.size());

			listOfTstatsForAccount.addAll(esiTstatCollection);

		}
		else
		{
			if (esiList.isEmpty())
			{
				throw new EsiNotFoundException(
						DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"ESI not found for account " + accountId);
			}
			throw new EsiNotUniqueException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"More than one ESI found for account " + accountId);
		}

		return listOfTstatsForAccount;
	}

	/**
	 * @param userId
	 * @return
	 */
	public User getUser(int userId)
	{
		// First get the user
		List<User> users = userAccFacade.getUserByUserId(userId);
		if (users != null && users.size() > 0)
		{
			return users.get(0);
		}

		return null;
	}

	// for presentation layer
	
	public List<AccountModel> getUserAccounts(String username)
			throws UserNotUniqueException
	{
		logger.info("[ENTER] List<AccountModel> UserBean.getUserAccounts(String username)");

		List<AccountModel> accounts = null;
		User user = userAccFacade.findUserByUsername(username);

		if (user != null)
		{
			/* Get UserAccountMap on user id */
			List<UserAccountMap> userAccountMaps = userAccFacade
					.getUserAccountMapByUserId(user.getUserId());
			if (userAccountMaps != null && !userAccountMaps.isEmpty())
			{
				/* Get list of accounts based on account_id */
				accounts = new ArrayList<AccountModel>();
				for (UserAccountMap userAccountMap : userAccountMaps)
				{
					Account account = userAccountMap.getAccountId();
					if (account != null) {
						AccountModel accountM = Account2AccountModel.convert(account,
								esiBeanFacade, userAccFacade);
						accounts.add(accountM);
					}
				}
			}
		}

		if (accounts != null)
		{
			logger.info("[ EXIT] UserBean.getUserAccounts - total accounts found for user "
					+ username + ": " + accounts.size());
		}

		return accounts;
	}

	/**
	 * Get user accounts
	 * 
	 * @param user
	 */
	
	public List<Account> getUserAccounts(User user)
	{
		logger.info("[ENTER] List<Account> UserBean.getUserAccounts(User user)");

		List<Account> accounts = null;

		if (user == null)
		{
			logger.debug("User is null");
			logger.info("[ EXIT] UserBean.getUserAccounts");
			return null;
		}

		logger.debug("User name: " + user.getUsername());

		/* Get UserAccountMap on user id */
		List<UserAccountMap> userAccountMaps = userAccFacade.getUserAccountMapByUserId(user
				.getUserId());
		if (userAccountMaps != null && !userAccountMaps.isEmpty())
		{
			/* Get list of accounts based on account_id */
			accounts = new ArrayList<Account>();
			for (UserAccountMap userAccountMap : userAccountMaps)
			{
				accounts.add(userAccountMap.getAccountId());
			}
		}

		logger.info("[ EXIT] UserBean.getUserAccounts");

		return accounts;
	}

	/**
	 * Get users associated to account number
	 * 
	 * Case of accountNumber not valid or not found, will return null
	 * 
	 * @param accountNumber
	 * @return
	 */
	
	public List<User> getUserByAccountNumber(String accountNumber)
	{
		List<User> users = new ArrayList<User>();

		logger.info("getUserByAccountNumber() - starting");
		logger.info("Account number: " + accountNumber);

		/* Null or empty accountNumber */
		if (accountNumber == null || "".equals(accountNumber))
		{
			return null;
		}

		/* Get Account object based on utility account number */
		List<Account> accounts = userAccFacade.getAccountByAccountNumber(accountNumber);

		/* Get list of users for indicated account */
		if (accounts == null || accounts.isEmpty())
		{
			logger.error("null or empty accounts found in the db for accountNumber "
					+ accountNumber);
			return users;
		}
		for (Account account : accounts)
		{

			List<UserAccountMap> usrAccMaps = userAccFacade
					.getUserAccountMapByAccountId(account.getAccountId());
			/* Get list of users associated to account number */
			for (UserAccountMap userAccountMap : usrAccMaps)
			{
				users.add(userAccountMap.getUserId());
			}
		}
		logger.info("getUserByAccountNumber() - ending");
		return users;
	}

	/**
	 * Get User based on utility account number and account email address
	 * 
	 * If users not found returns empty list
	 * 
	 * @param accountNumber
	 *        Account number to find
	 * @param email
	 *        Email address to validate
	 * @return User user that matches account and email address
	 */
	
	public User getUserByAccountNumberAndEmail(String accountNumber, String email)
	{

		logger.info("getUserByAccountNumberAndEmail() - starting");

		if (accountNumber == null || accountNumber.isEmpty()
				|| email == null || email.isEmpty())
		{
			return null;
		}

		List<User> users = userAccFacade.getUserByAccountNumberAndEmail(accountNumber, email);
		if (users == null || users.isEmpty())
		{
			return null;
		}

		logger.info("getUserByAccountNumberAndEmail() - ending");
		return users.get(0);
	}

	public List<User> getUserByPhoneNumber(String phoneNumber)
	{
		List<User> users = null;

		logger.info("getUserByPhoneNumber() - starting accountNumber = "
				+ phoneNumber);

		/* P number not valid */
		if (phoneNumber == null || phoneNumber.isEmpty())
		{
			return null;
		}

		users = userAccFacade.getUserByPhoneNumber(phoneNumber);
		if (users.isEmpty())
		{
			users = userAccFacade.getUserByPhoneNumberStripped(phoneNumber);
			if (users.isEmpty())
			{
				return null;
			}
			return users;
		}
		return users;
	}

	// KRMT-3359 Determine if the user is a Consumer or Utility user and
	// populate their UserTimeZoneModel accordingly
	// TODO: there might be a better way to determine this, but go with this for
	// now...

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#getUserInfoByAccountEmail(java.lang.String)
	 */
	@Override
	public UserModel getUserInfoByAccountNumberAndEmail(String accountNumber, String email, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		User user = getUserByAccountNumberAndEmail(accountNumber, email);
		if (user != null) {
			return User2UserModel(user);
		}
		return null;

	}
	
	// for presentation layer
	
	public List<UserModel> getUserInfoByAccountNumber(String accountNumber, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<UserModel> usersM = new ArrayList<UserModel>();
		List<User> users = getUserByAccountNumber(accountNumber);
		if (users != null)
		{ // KRMT-1717 brockman Null Pointer Exception fix 2011-Nov-03
			for (User user : users)
			{
				UserModel userM = User2UserModel(user);
				usersM.add(userM);
			}
		}
		return usersM;
	}

	/**
	 * KRMT-1717 The USER table now contains a column : EMAIL that is being recorded at login time.
	 * When logging in users, we allow them to log in by email address. The USER.EMAIL field is the
	 * field matched.
	 * 
	 * @author brockman
	 * @param email
	 * @return
	 */
	
	public List<UserModel> getUserInfoByUserEmail(String email,Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);

		logger.info("getUserInfoByUserEmail() - starting");
		List<User> users = userAccFacade.getUserByUserEmail(email);

		// Downshift entities into model POJOs
		List<UserModel> userModels = new ArrayList<UserModel>(users.size());
		for (User user : users)
		{
			UserModel userM = User2UserModel(user);
			userModels.add(userM);
		}

		logger.info("getUserInfoByUserEmail() - ending");

		return userModels;
	}

	/**
	 * Get user security question.
	 * 
	 * If user no valid will return null
	 * 
	 * @param account
	 *        User name account
	 * @return SecurityQuestion Security question object
	 */
	
	public SecurityQuestion getUserSecurityQuestion(User user)
	{
		SecurityQuestion securityQuestion = null;
		logger.info("getUserSecurityQuestion() - starting");

		if (user == null)
		{
			logger.info("getUserSecurityQuestion() - user is NULL");
			return null;
		}

		if (user.getSecurityQuestionId() == null)
		{
			logger.info("getUserSecurityQuestion() - security questionID is NULL");
			return null;
		}

		securityQuestion = userAccFacade
				.findSecurityQuestionBySecurityQuestionId(user
						.getSecurityQuestionId().getSecurityQuestionId());

		logger.info("getUserSecurityQuestion() - ending");

		/* Get security question based on user */
		return securityQuestion;
	}

	// For presentation layer.
	@Override
	public SecurityQuestionModel getUserSecurityQuestion(UserModel userInfo, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		SecurityQuestion securityQuestion = null;
		SecurityQuestionModel securityQuestionM = new SecurityQuestionModel();

		logger.info("getUserSecurityQuestion() - starting");

		if (userInfo == null)
		{
			logger.info("getUserSecurityQuestion() - user is NULL");
			return null;
		}

		securityQuestion = userAccFacade
				.findSecurityQuestionBySecurityQuestionId(userInfo
						.getSecurityQuestionId());

		if (securityQuestion == null)
		{
			return null;
		}

		securityQuestionM.setSecurityQuestionId(securityQuestion
				.getSecurityQuestionId());
		securityQuestionM.setSecurityQuestionName(securityQuestion
				.getSecurityQuestionName());

		logger.info("getUserSecurityQuestion() - ending");

		/* Get security question based on user */
		return securityQuestionM;
	}

	private UserTimeZoneModel getUserTimeZoneModelforUser(User user)
	{

		UserTimeZoneModel userTimeZoneModel = new UserTimeZoneModel();
		boolean isConsumerAccount = false;

		// determine user type based on associated accounts
		List<Account> accounts = getUserAccounts(user);

		// user has accounts so assume consumer
		// KRMT-4350 some utility users are associated with default account
		// (accounrt_id == 1)
		// detect these and treat them as utility users.
		if (accounts != null && !accounts.isEmpty())
		{
			if (accounts.get(0).getAccountId() != 1)
			{
				isConsumerAccount = true;
			}
		}

		if (isConsumerAccount && accounts != null)
		{
			// BUGBUG does not handle edge case of two accounts with different
			// tz in same utility
			Account account = accounts.get(0);

			// details come from account
			DateTimeZone consumerTimezone = account.getTimezoneId().getDateTimeZone();

			userTimeZoneModel.setDateTimeZone(consumerTimezone);
			userTimeZoneModel.setLongName(consumerTimezone.toTimeZone().getDisplayName());
			userTimeZoneModel
					.setShortName(consumerTimezone.getShortName(new DateTime().getMillis()));

		}
		else
		{

			// details come from Utility
			DateTimeZone utilityTimezone = genericBean.getUtilityTimeZone();

			userTimeZoneModel.setDateTimeZone(utilityTimezone);
			userTimeZoneModel.setLongName(utilityTimezone.toTimeZone().getDisplayName());
			userTimeZoneModel
					.setShortName(utilityTimezone.getShortName(new DateTime().getMillis()));

		}

		return userTimeZoneModel;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#getUtilityPersonaUserInfoSortedByUserId()
	 */
	@Override
	public List<UserModel> getUtilityPersonaUserInfoSortedByUserId(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		// for presentation layer
		List<UserModel> usersM = new ArrayList<UserModel>();
		LinkedHashMap<User, Set<UserRoleMap>> userRoleMapsByUser = getUtilityPersonaUsersSortedByUserId();
		Set<User> users = userRoleMapsByUser.keySet();

		for (User user : users)
		{
			UserModel userM = User2UserModel(user);
			usersM.add(userM);

			List<RoleModel> roles = getRolesFor(userRoleMapsByUser.get(user));
			Collections.sort(roles, Comparator.comparing(PortalRoleModel::getRoleName));
			userM.setRoles(roles);
		}
		return usersM;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#getUtilityPersonaUsersSortedByUserId()
	 */
	public LinkedHashMap<User, Set<UserRoleMap>> getUtilityPersonaUsersSortedByUserId()
	{
		LinkedHashMap<User, Set<UserRoleMap>> users = new LinkedHashMap<User, Set<UserRoleMap>>();
		List<UserRoleMap> userRoleMaps = userAccFacade
				.getUtilityPersonaUserRoleMapsSortedByUserId();
		if (userRoleMaps == null || userRoleMaps.isEmpty())
		{
			return users;
		}

		for (UserRoleMap map : userRoleMaps)
		{
			User user = map.getUserId();
			Set<UserRoleMap> mapSet = users.get(user);
			if (mapSet == null)
			{
				mapSet = new HashSet<UserRoleMap>();
				users.put(user, mapSet);
			}
			mapSet.add(map);
		}

		return users;
	}

	
	public void handleAccountSync()
	{

		List<UtilityProperty> propertyList = genericFacade
				.getUtilityPropertyLikeKey(OpsCenterConstants.UTILITY_ACCOUNT_SYNC_LIKE);
		logger.info("handleAccountSync");
		if(propertyList.size() != 0){
			logger.info(propertyList.get(0).getKey());
			if(propertyList.get(0).getValue()!= null){
				logger.info(propertyList.get(0).getValue());
			}else{
				logger.info("propertyList.get(0).getValue() is null");
			}
		}
		else{
			logger.info("propertyList size is 0");
		}
		HashMap<String, String> accountSyncProperties = new HashMap<String, String>();
		for (UtilityProperty utilityProperty : propertyList)
		{
			logger.info("utilityProperty.getKey()"+utilityProperty.getKey());
			logger.info("utilityProperty.getValue()"+utilityProperty.getValue());
			accountSyncProperties.put(utilityProperty.getKey(), utilityProperty.getValue());
		}

		// This can be configured via the utility portal Settings/index
		String endpointUrl = accountSyncProperties
				.get(OpsCenterConstants.UTILITY_ACCOUNT_SYNC_ENDPOINT_URL);
		if (endpointUrl == null || endpointUrl.trim().isEmpty())
		{
			logger.info("SKIPPED Account Sync Task");
			return;
		}

		HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>> changedAccountsAndUsers = new HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>>();
		List<Serializable> oldAccountKeysToRemove = new ArrayList<Serializable>();

		findOutOfSync(changedAccountsAndUsers, oldAccountKeysToRemove);

		Cache accountSyncCache = cacheManager.getAccountSyncCache();
		Cache accountUserSyncCache = cacheManager.getAccountUserSyncCache();

		//ConsertAccountSyncPortProxy portProxy = new ConsertAccountSyncPortProxy();
		ConsertAccountSync portProxy = new ConsertAccountSync_Service().getConsertAccountSyncPort();
		//portProxy._getDescriptor().setEndpoint(endpointUrl);
		WebServiceUtil.setEndpoint(portProxy, endpointUrl);

		int tmpBlockSize = 40;
		String blockSizeString = accountSyncProperties
				.get(OpsCenterConstants.UTILITY_ACCOUNT_SYNC_BLOCK_SIZE);
		if (blockSizeString != null)
		{
			try
			{
				tmpBlockSize = Integer.parseInt(blockSizeString);
			}
			catch (Exception e)
			{
				// Defaults
			}
		}
		int blockSize = tmpBlockSize;

		int blockIndex = 0;

		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		}
		catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return;
		}
		XMLGregorianCalendar now = datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar());

		ConsertAccountSyncMessage message = new ConsertAccountSyncMessage();
		message.setMessageTime(now);

		HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>> changedAccountsAndUsersInBlock = new HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>>();
		Map<Long, AccountSyncCacheData> dataByIdInBlock = new HashMap<Long, AccountSyncCacheData>();

		Set<AccountSyncCacheData> changedAccounts = changedAccountsAndUsers.keySet();
		if (!changedAccounts.isEmpty())
		{
			Iterator<AccountSyncCacheData> changedAccountsItr = changedAccounts.iterator();
			boolean hasNext;
			do
			{
				AccountSyncCacheData accountSyncCacheData = changedAccountsItr.next();
				hasNext = changedAccountsItr.hasNext();
				List<AccountUserSyncCacheData> users = changedAccountsAndUsers
						.get(accountSyncCacheData);
				changedAccountsAndUsersInBlock.put(accountSyncCacheData, users);
				changedAccountsItr.remove();

				blockIndex++;

				dataByIdInBlock.put((long) blockIndex, accountSyncCacheData);

				ConsertAccountSyncInfo info = createInfo(datatypeFactory, accountSyncCacheData,
						users, blockIndex);

				message.getInfo().add(info);

				if (blockIndex >= blockSize || !hasNext)
				{
					logger.debug("Account Sync sending " + blockIndex);

					String wss_outgoing_username = accountSyncProperties
							.get(OpsCenterConstants.UTILITY_ACCOUNT_SYNC_WSS_OUTGOING_USERNAME);
					if (wss_outgoing_username != null && !wss_outgoing_username.trim().isEmpty())
					{
						String wss_outgoing_password = accountSyncProperties
								.get(OpsCenterConstants.UTILITY_ACCOUNT_SYNC_WSS_OUTGOING_PASSWORD);

						
						
						/* JBOSSTODO
						BindingProvider bp = (BindingProvider) portProxy;
						Map<String, Object> requestContext = bp.getRequestContext();
						WSSGenerationContext generationContext = CimServicesUtilityBean
								.getWSSGenerationContext(wss_outgoing_username,
										wss_outgoing_password);
						if (generationContext != null)
						{
							logger.debug("GENERATION CONTEXT: " + generationContext.toString());
							// encode message according to generationContext
							// setting
							try
							{
								generationContext.process(requestContext);
							}
							catch (WSSException e)
							{
								logger.error(
										"Account Sync could not set the WS-Security Username token",
										e);
							}
						}
						*/
					}
					ConsertAccountSyncAcknowledgement ack = portProxy
							.consertAccountSyncReceive(message);

					// process the successful messages
					HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>> successAccountsAndUsersInBlock = new HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>>();
					List<ConsertAcknowledgementById> acknowledgements = ack.getAcknowledgement();
					for (ConsertAcknowledgementById consertAcknowledgementById : acknowledgements)
					{
						if (consertAcknowledgementById.isSuccess())
						{
							AccountSyncCacheData accountSyncCacheData2 = dataByIdInBlock
									.get(consertAcknowledgementById.getId());
							if (accountSyncCacheData2 != null)
							{
								successAccountsAndUsersInBlock.put(accountSyncCacheData2,
										changedAccountsAndUsersInBlock.get(accountSyncCacheData2));
							}
						}
					}
					success(accountSyncCache, accountUserSyncCache, successAccountsAndUsersInBlock);

					// reset for the next block
					message = new ConsertAccountSyncMessage();
					message.setMessageTime(now);
					changedAccountsAndUsersInBlock.clear();
					dataByIdInBlock.clear();
					blockIndex = 0;
				}
			}
			while (hasNext);
		}

		if (!oldAccountKeysToRemove.isEmpty())
		{
			accountSyncCache.removeAll(oldAccountKeysToRemove);
		}

	}

	
	public Map<UserModel, Map<String, String>> handleSSORequest(String samlBase64, Integer tenantId)
			throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering handleSSORequest ");

		// this branch is for consumer login
		String accNum = null;
		String userName = null;
		Map<String, String> attrMap = new HashMap<String, String>();
		Map<UserModel, Map<String, String>> userMap = new HashMap<UserModel, Map<String, String>>();
		Map<String, String> urlMap = new HashMap<String, String>();
		UserModel user = null;
		// set the user object to allow map to be populated for early exiting
		// (exceptions)
		user = new UserModel();
		user.setUsername("tempUser");

		try
		{
			attrMap = ssoBean.parseSSOXML(samlBase64);
		}
		catch (UnrecognizedSSOPayloadReceivedException e1)
		{
			// the following URLs are optional, grab them from attrMap parsed
			// and shove them into Map to return to UI-- if available
			// contents of the map value could be "null"
			urlMap.put(OpsCenterConstants.KEEPALIVEPINGURL,
					attrMap.get(OpsCenterConstants.KEEPALIVEPINGURL));
			urlMap.put(OpsCenterConstants.SINGLELOGOUTPNGURL,
					attrMap.get(OpsCenterConstants.SINGLELOGOUTPNGURL));
			urlMap.put(OpsCenterConstants.SINGLELOGOUTRETURNURL,
					attrMap.get(OpsCenterConstants.SINGLELOGOUTRETURNURL));
			userMap.put(user, urlMap);
			logger.debug("Dumping URLs in map on exception" + userMap.get(user));

			logger.error("handleSSORequest() - Exception during parseSSOXML: " + e1.getMessage());

			throw new UnrecognizedSSOPayloadReceivedException(
					DefaultResources.UNRECOGNIZED_SSO_PAYLOAD, "No Consumer/Utility payload",
					userMap);

		}
		AccountModel accModel = null;

		// the following URLs are optional, grab them from attrMap parsed and
		// shove them into Map to return to UI-- if available
		// contents of the map value could be "null"
		urlMap.put(OpsCenterConstants.KEEPALIVEPINGURL,
				attrMap.get(OpsCenterConstants.KEEPALIVEPINGURL));
		urlMap.put(OpsCenterConstants.SINGLELOGOUTPNGURL,
				attrMap.get(OpsCenterConstants.SINGLELOGOUTPNGURL));
		urlMap.put(OpsCenterConstants.SINGLELOGOUTRETURNURL,
				attrMap.get(OpsCenterConstants.SINGLELOGOUTRETURNURL));
		userMap.put(user, urlMap);

		logger.debug("Dumping URLs in map" + userMap.get(user));

		List<Integer> roleList = new ArrayList<Integer>();
		logger.debug("Checking for Consumer login first= "
				+ attrMap.get(OpsCenterConstants.ACCOUNT_NUMBER));
		if (attrMap.containsKey(OpsCenterConstants.ACCOUNT_NUMBER))
		{
			// this is consumer request
			String ssoUserName = attrMap.get(OpsCenterConstants.USER_NAME);
			String ssoAccNum = attrMap.get(OpsCenterConstants.ACCOUNT_NUMBER);
			String ssoAccZipCode = attrMap.get(OpsCenterConstants.ACCOUNT_ZIP_CODE);
			if (ssoUserName == null || ssoUserName.isEmpty())
			{
				throw new UserNameNotFoundException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
						"User "
								+ ssoUserName + " not found in SSO payload", userMap);
			}
			try
			{
				accModel = getAccountInfoByAccountNumber(ssoAccNum, tenantId);
			}
			catch (Exception e)
			{
				logger.error("Account not found for Acc # " + accNum);
				throw new AccountNumberNotFoundException(
						DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
						"No Account found for account number " + accNum, userMap);
			}
			if (!accModel.getAddr1Zip().equals(ssoAccZipCode))
			{
				throw new UserNotUniqueException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
						"Received Zip code does not match Account Number, zipcode=  "
								+ ssoAccZipCode, userMap);
			}
			try
			{
				logger.debug("UserName parsed = " + ssoUserName);
				user = User2UserModel(findUserByUsername(ssoUserName));
				
				User usr = findUserByUsername(ssoUserName);
				user = User2UserModel(usr);
			}
			catch (Exception e)
			{
				logger.error("User name received not Unique, login failed" + userName);

				throw new UserNotUniqueException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
						"No Unique User Exist for Username  " + ssoUserName, userMap);
			}
			boolean found = false;
			List<UserAccountMap> uAccMap = userAccFacade.getUserAccountMapByAccountId(accModel
					.getAccountId());
			if (uAccMap == null && user == null)
			{
				// no user found in our system, lets go ahead and create one
				logger.debug("No Users at all found in DB, create first user" + ssoUserName);
				try
				{
					User u = createConsumerUserFromAccModel(accModel, ssoUserName);
					user = User2UserModel(u);
				}
				catch (Exception e)
				{

					throw new UserNotUniqueException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
							"No Unique User Exist for Username  " + ssoUserName, userMap);
				}
			}
			else
			{
				if (uAccMap != null)
				{
					for (UserAccountMap uMap : uAccMap)
					{

						// now we need to find the user token and ensure it
						// matches
						// with requested SSO payload
						if (uMap.getUserId().getUsername().equals(ssoUserName))
						{

							// user rec in SSO payload has matching email from
							// payload and already in our DB, all is good
							logger.debug("User name already in our DB, and has matching acc # and username, all is good"
									+ ssoUserName);
							found = true;
							break;
						}
					}
				}
			}
			if (!found)
			{
				try
				{
					logger.debug("Search complete, no user mapping found, create new user map"
							+ ssoUserName);
					User ur = createConsumerUserFromAccModel(accModel, ssoUserName);
					user = User2UserModel(ur);
				}
				catch (Exception e)
				{

					throw new UserNotUniqueException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
							"No Unique User Exist for Username  " + ssoUserName, userMap);
				}
			}
			// utility login branch
		}
		else
		{
			logger.debug("Utility branch, checking Roles");
			if (attrMap.get(OpsCenterConstants.CSRROLE) != null)
			{
				if (attrMap.get(OpsCenterConstants.CSRROLE).equals(OpsCenterConstants.BOOLEAN_TRUE))
				{
					roleList.add(OpsCenterConstants.USER_ROLE_CSR);
				}

			}
			if (attrMap.get(OpsCenterConstants.UTILITYADMINISTRATORROLE) != null)
			{
				if (attrMap.get(OpsCenterConstants.UTILITYADMINISTRATORROLE).equals(
						OpsCenterConstants.BOOLEAN_TRUE))
				{
					roleList.add(OpsCenterConstants.USER_ROLE_UTILITY_ADMIN);
				}
			}
			if (attrMap.get(OpsCenterConstants.UTILITYOBSERVERROLE) != null)
			{
				if (attrMap.get(OpsCenterConstants.UTILITYOBSERVERROLE).equals(
						OpsCenterConstants.BOOLEAN_TRUE))
				{
					roleList.add(OpsCenterConstants.USER_ROLE_UTILITY_OBSERVER);
				}
			}
			if (attrMap.get(OpsCenterConstants.UTILITYOPERATORROLE) != null)
			{
				if (attrMap.get(OpsCenterConstants.UTILITYOPERATORROLE).equals(
						OpsCenterConstants.BOOLEAN_TRUE))
				{
					roleList.add(OpsCenterConstants.USER_ROLE_UTILITY_OPERATOR);
				}
			}
			logger.debug("rolelist after extracting roles = " + roleList.size());
			if (!roleList.isEmpty())
			{
				logger.debug("Attempting to login/find Utility user ");
				logger.debug("Getting user map key = " + OpsCenterConstants.USER_NAME + " "
						+ attrMap.get(OpsCenterConstants.USER_NAME));
				String ssoUserN = attrMap.get(OpsCenterConstants.USER_NAME);
				if (ssoUserN == null || ssoUserN.isEmpty())
				{
					logger.error("User not found exception");
					throw new UserNameNotFoundException(
							DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
									+ ssoUserN + " Not Found", userMap);
				}
				User usr = findUserByUsername(ssoUserN);
				user = User2UserModel(usr);
				boolean found = false;
				if (user == null)
				{
					logger.debug("User name not found in DB, create one userName=" + ssoUserN);
					// create new Utility user here
					user = User2UserModel(createUtilityUser(ssoUserN, roleList));
					found = true;

				}
				else
				{
					List<UserRoleMap> rolesMapList = userAccFacade.getUserRoleMapByUserId(user
							.getUserId());
					if (rolesMapList == null || rolesMapList.isEmpty())
					{
						logger.error("Could not find matching Role in DB for userId = "
								+ user.getUserId());
						throw new UtilityUserRoleInvalid(
								DefaultResources.USR_UTILITY_USER_ROLE_INVALID,
								"User Role Not Found", userMap);
					}
					for (UserRoleMap userRMap : rolesMapList)
					{
						for (Integer roleId : roleList)
						{
							if (userRMap.getRoleId().getRoleId() == roleId)
							{
								found = true;

							}
							else
							{
								// sso request, but not assigned to the user,
								// bail
								break;
							}
						}
					}

				}
				if (!found)
				{
					logger.error("Roles received does not match users configured roles, exiting");
					throw new UtilityUserRoleInvalid(
							DefaultResources.USR_UTILITY_USER_ROLE_INVALID, "User roles does "
									+
									"not match existing Utility User roles assigned", userMap);
				}
				// now we need to find the user token and ensure it matches with
				// requested SSO payload
			}
			else
			{
				// unrecognized SSO payload, no consumer, no utility
				logger.error("No Valid Utility/Consumer SSO payload received, terminating");
				throw new UnrecognizedSSOPayloadReceivedException(
						DefaultResources.UNRECOGNIZED_SSO_PAYLOAD, "No Consumer/Utility payload",
						userMap);

			}
		}
		// remove any temp users in map and add real user
		userMap.clear();
		userMap.put(user, urlMap);
		logger.info("Exiting from handleSSORequest, userName ="
				+ attrMap.get(OpsCenterConstants.USER_NAME));

		return userMap;

	}

	/**
	 * Do we have a mix of VPP and Cycling device types
	 * 
	 * @param esiDcList
	 * @return
	 */
	private boolean isMixedDeviceTypes(List<EsiDc> esiDcList)
	{
		boolean cyclingOnlyDevices = false;
		boolean vppDevices = false;

		// Look at the device list we are provisioning
		for (EsiDc esiDc : esiDcList)
		{
			DeviceType deviceType = esiDc.getDeviceTypeId();
			if (deviceType != null)
			{
				if ((deviceType.getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_HVAC_SWITCH)
						|| deviceType.getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_SINGLE_HEAT)
						|| deviceType.getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_DUAL_HEAT)
					)  && esiDc.getDeviceMacId() == 00)
				{
				     //  dev-2110 only return true for legacy hvac_switch devices, we will allow prog for GS DC_HVAC_SWITCH cause
					//1 switch could have hvs and non-hvs device
					cyclingOnlyDevices = true;
				}
				else
				{
					vppDevices = true;
				}
			}
		}

		// Cannot mix cycling only and VPP devices
		if (cyclingOnlyDevices && vppDevices)
		{
			return true;
		}

		return false;
	}

	/**
	 * Indicates if user has already accepted terms and conditions
	 * 
	 * If user not valid returns false
	 * 
	 * @param user
	 *        Terms and conditions user
	 * @return Boolean Has user accepted terms and conditions
	 */
	
	public boolean isSetTermsAndConditions(User user)
	{
		User currentUser = null;
		boolean accepted = false;

		if (logger.isTraceEnabled())
		{
			logger.trace("isSetTermsAndConditions() - starting");
		}

		if (user == null)
		{
			return accepted;
		}

		currentUser = userAccFacade.findUserByUserId(user.getUserId());
		if (OpsCenterConstants.TRUE.equalsIgnoreCase(currentUser
				.getTermsAgrmntFlag()))
		{
			accepted = true;
		}

		if (logger.isTraceEnabled())
		{
			logger.trace("isSetTermsAndConditions() - ending");
		}
		return accepted;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanRemote#processSendHealthStatusMessage(java.lang.Long)
	 */
	@Override
	public void processSendHealthStatusMessage(Long devMacId, Integer tenentId) throws AbstractOpsCenterException
	{
		logger.info("Entering processSendHealthStatusMessage for macId =  " + devMacId);
		TenantContext.setCurrentTenant(tenentId);
		try
		{
			DateTime currentTime = new DateTime();

			RequestDeviceHealthMessage healthStatusRequest = new RequestDeviceHealthMessage();
			healthStatusRequest.setTimeStamp(currentTime.getMillis());
			healthStatusRequest.setMessageId(currentTime.getMillis());
			healthStatusRequest.setDeviceMacAddress(devMacId);
			healthStatusRequest.setMessageLength((short) 0);

			EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
			endpointIdentifier.setMacId(devMacId);
			publisher.publish(endpointIdentifier, healthStatusRequest.getPayload());
		}
		catch (Exception e)
		{
			logger.error("processSendHealthStatusMessage() - >>> failed for Device Mac Id = "
					+ devMacId, e);
			e.printStackTrace();
			throw new PublishMessageFailedException(e);
		}
	}
 
	@Override
	public void processSendHealthStatusGSMessageResp(RawMessage msg, Integer tenantId) throws AbstractOpsCenterException  
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("Entering processSendHealthStatusGSMessageResp");
		gsMsgGrpBean.processHealthStatusResponseGS(msg);
		
		 
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanRemote#processSendStartOtaMessage(java.lang.Long)
	 */
	@Override
	public void processSendStartOtaMessage(Long devMacId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		// this is invoked for the UI to test starting OTA
		otaBean.processSendStartOtaMessage(devMacId);

	}
	
	public void processSendHealthStatusGSResp(Long devMacId)
	{

		// this is invoked for the UI to test starting OTA
		otaBean.processSendStartOtaMessage(devMacId);

	}

	@Override
	public void processSendDeviceEventLog(Long devMacId, int startSeqNo, int endSeqNo, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		// this is invoked for the UI to test starting OTA
		try
		{
			gsEventHandlerBean.processSendDeviceEventLog(devMacId, startSeqNo, endSeqNo);
		}
		catch (AbstractOpsCenterException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * @param esi
	 * @throws ConfigurationException_Exception
	 */
	
	public void publishGwActivation(Esi esi) throws AbstractOpsCenterException
	{

		esi.setActiveFlag("1");
		logger.debug(" Updating Esi Active Flag to '1'");
		esiBeanFacade.updateEsi(esi);

		Account account = esi.getAccountId();
		logger.debug(" Retrieved Account: " + account.getAccountNumber());

		if (checkDevicesAndAssignDefaultProgramData(esi))
		{
			userProgramBean.publishMessageForSingleAccount(account.getAccountId(), false);
		}
		 
	}

	/**
	 * @param esi
	 * @throws ConfigurationException_Exception
	 */
	
	public void publishGwActivation(GsManageable esiTstat) throws AbstractOpsCenterException
	{

		// DEV-2978: For GS we now activate the ESI when the workflow completes 
		Esi esi = esiTstat.getEsiId();
//		esi.setActiveFlag("1");
//		logger.debug(" Updating Esi Active Flag to '1'");
		
		long deviceMacId = esiTstat.getDeviceMacId();
		publishGwActivation(esi, deviceMacId);
	}

	private void publishGwActivation(Esi esi, long deviceMacId)
			throws AbstractOpsCenterException
	{
		Account account = esi.getAccountId();
		logger.debug("Pushing Programs for Account: " + account.getAccountNumber() + ", macId: "
				+ deviceMacId);


		if (checkDevicesAndAssignDefaultProgramData(esi))
		{
			DateTimeZone datetimeZone = account.getTimezoneId().getDateTimeZone();
			userProgramBean.publishMessageForSingleAccountMod(
					account.getAccountId(), esi.getHardwareType(), esi.getEsiMqId(), esi.getEsiId(),
					datetimeZone, deviceMacId, false, false);
		}
	}
 

	/**
	 * Reset accepted Terms and Conditions flag
	 * 
	 * @param user
	 *        Reseted terms and conditions user
	 * @throws Exception
	 */
	
	public void resetTermsAndConditions(User user) throws Exception
	{
		User currentUser = null;
		logger.info("resetTermsAndConditions() - starting");

		if (user == null)
		{
			return;
		}

		try
		{
			currentUser = userAccFacade.findUserByUserId(user.getUserId());
			if (currentUser != null)
			{
				UserModel origUser = User2UserModel(currentUser);
				user.setTermsAgrmntFlag(OpsCenterConstants.FALSE);
				currentUser.setTermsAgrmntFlag(OpsCenterConstants.FALSE);
				currentUser.setDateModified(new DateTime());
				currentUser.setUserModified(user.getUsername());
				updateUserInDatabase(currentUser, origUser);
			}
			else
			{
				logger.error("user not found at reset terms and conditions: " + user.getUserId());
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}

		logger.info("resetTermsAndConditions() - ending");
	}

	/**
	 * Resets user password, and sends email to indicated email address
	 * 
	 * @param user
	 *        User name to reset password
	 * @return String
	 */
	
	public String resetUserPasswordSendEmail(UserModel userInfo, String toEmail)
			throws SystemUnavailableException,
			UserNotUniqueException, Exception
	{

		logger.info("resetUserPasswordSendEmail() - starting Username = "
				+ userInfo.getUsername() + " Email = " + toEmail);

		User user = userAccFacade.findUserByUserId(userInfo.getUserId());

		if (user == null)
		{
			logger.info("resetUserPasswordSendEmail() - User not Found");
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
							+ userInfo.getUsername() + " Not Found");
		}

		// Get a copy of the user info before the update
		UserModel origUser = User2UserModel(user);

		String password = generateRandomPassword();

		user.setPassword(EncryptService.getInstance().encrypt(password));
		logger.info("resetUserPasswordSendEmail user ID = "
				+ user.getUserId() + " password = " + password);
		user.setDateModified(new DateTime());
		user.setDatePasswordModified(new DateTime());
		user.setUserModified(user.getUsername());
		updateUserInDatabase(user, origUser);

		/* Send user new password */
		EmailBean emailBean = new EmailBean();
		HashMap<String, String> model = new HashMap<String, String>();
		model.put(EmailBean.MESSAGE_TAGS.FIRST_NAME, user.getFirstName());
		model.put(EmailBean.MESSAGE_TAGS.LAST_NAME, user.getLastName());
		model.put(EmailBean.MESSAGE_TAGS.USER_NAME, user.getUsername());
		model.put(EmailBean.MESSAGE_TAGS.PASSWORD, password);
		emailBean.sendMail(toEmail,
				EmailBean.MESSAGE_TEMPLATES.RESET_PASSWORD, model);

		logger.info("resetUserPasswordSendEmail - ending");

		return password;
	}

	/**
	 * Review all user account mappings and set the single accoutn with account Number to Primary
	 * for the user. Set all other account mappings to NOT primary.
	 * 
	 * @author Taylor Brockman
	 * @param user
	 * @param accountNumber
	 * @throws AccountNumberNotFoundException
	 */

	@Override
	public void setAccountToPrimaryForUser(UserModel user, String accountNumber, Integer tenantId)
			throws AccountNumberNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		// Find the specific account in the account mapping.
		// Set it to primary.
		// Set all others to not primary.

		Account account = getAccountByAccountNumber(accountNumber);
		if (account == null)
		{
			logger.info("createUser() - Account is NULL for account number: "
					+ accountNumber);

			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountNumber);
		}

		List<UserAccountMap> maps = userAccFacade
				.getUserAccountMapByUserId(user.getUserId());

		for (UserAccountMap map : maps)
		{
			if (map.getAccountId().getAccountId() == account.getAccountId())
			{
				map.setPrimaryFlag("1");
			}
			else
			{
				map.setPrimaryFlag("0");
			}

			try
			{
			userAccFacade.updateUserAccountMap(map);
			}
			catch(Exception e)
			{
				logger.error("Primary account update failed with error: "+e.getMessage());
			}
		}
	}

	public void setEntityManager(EntityManager em)
	{
		logger.info("Setting EM");
		// userAccFacade.setEntityManager(em);
	}

	/**
	 * Set accepted Terms and Conditions flag
	 * 
	 * @param user
	 *        Accepted terms and conditions user
	 * @throws Exception
	 */
	
	public void setTermsAndConditions(User user) throws Exception
	{
		User currentUser = null;
		logger.info("setTermsAndConditions() - starting");

		if (user == null)
		{
			return;
		}

		currentUser = userAccFacade.findUserByUserId(user.getUserId());
		if (currentUser != null)
		{
			// Get a copy of the user info before the update
			UserModel origUser = User2UserModel(currentUser);

			user.setTermsAgrmntFlag(OpsCenterConstants.TRUE);
			currentUser.setTermsAgrmntFlag(OpsCenterConstants.TRUE);
			currentUser.setDateModified(new DateTime());
			currentUser.setUserModified(user.getUsername());
			updateUserInDatabase(currentUser, origUser);
		}
		else
		{
			logger.error("user not found at set terms and conditions: " + user.getUserId());
		}

		logger.info("setTermsAndConditions() - ending");
	}
	/**
	 * Adds a new row to USER_HISTORY for every time a user successfully logs in
	 * @param user
	 * @throws Exception
	 */
	private void storeUserHistoryEntry(User user, String shortComment) throws Exception
	{
		logger.info("[ENTER] void UserBean.storeUserHistoryEntry(" + user.getUsername() + ")");

		HistoryAction historyAction = entityManager.getReference(HistoryAction.class,
				OpsCenterConstants.historyActionNameToIdMap.get(OpsCenterConstants.HISTORY_ACTION_LOGIN));
		User usr = entityManager.getReference(User.class, user.getUserId());

		UserHistory userHistory = new UserHistory();
		userHistory.setActionDate(new DateTime());
		userHistory.setActionUserId(usr);
		userHistory.setHistoryActionId(historyAction);
		userHistory.setUserId(usr);
		userHistory.setActionLongCommentsFlag(OpsCenterConstants.FALSE);
		userHistory.setActionShortComments(shortComment);

		// Save
		userAccFacade.createUserHistory(userHistory);

		logger.debug("USER_HISTORY added to DB for user " + user.getUsername());

		logger.info("[ EXIT] UserBean.storeUserHistoryEntry");
	}
	
	/**
	 * Adds a new row to USER_HISTORY for every time a user successfully logs in
	 * @param user
	 * @throws Exception
	 */
	@Override
	public void addSuccessfulLoginToUserHistory(UserModel userModel, String message, Integer tenantId) throws Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] void UserBean.addSuccessfulLoginToUserHistory(" + userModel.getUsername() + ")");

		HistoryAction historyAction = entityManager.getReference(HistoryAction.class,
				OpsCenterConstants.historyActionNameToIdMap.get(OpsCenterConstants.HISTORY_ACTION_LOGIN));
		User user = entityManager.getReference(User.class, userModel.getUserId());

		UserHistory userHistory = new UserHistory();
		userHistory.setActionDate(new DateTime());
		userHistory.setActionUserId(user);
		userHistory.setHistoryActionId(historyAction);
		userHistory.setUserId(user);
		userHistory.setActionLongCommentsFlag(OpsCenterConstants.FALSE);
		userHistory.setActionShortComments(message != null ? message : "Successful login");

		// Save
		userAccFacade.createUserHistory(userHistory);

		logger.debug("USER_HISTORY added to DB for user " + user.getUsername());

		logger.info("[ EXIT] UserBean.addSuccessfulLoginToUserHistory");
	}

	/**
	 * @param accountSyncCache
	 * @param accountUserSyncCache
	 * @param changedAccountsAndUsersInBlock
	 */
	private void success(Cache accountSyncCache, Cache accountUserSyncCache,
			HashMap<AccountSyncCacheData, List<AccountUserSyncCacheData>> changedAccountsAndUsersInBlock)
	{
		Set<AccountSyncCacheData> accounts = changedAccountsAndUsersInBlock.keySet();
		List<Integer> accIdList = new ArrayList<Integer>();
		for (AccountSyncCacheData account : accounts)
		{
			accIdList.add(account.getAccountId());
		}
		Results keyResults = cacheManager.getCacheDataKeysByAccIdList(accountUserSyncCache,
				accIdList);
		List<Result> keyList = keyResults.all();
		List<Object> keysToRemove = new ArrayList<Object>();
		for (Result result : keyList)
		{
			keysToRemove.add(result.getKey());
		}
		keyResults.discard();
		accountUserSyncCache.removeAll(keysToRemove);

		for (AccountSyncCacheData account : accounts)
		{
			Element e = new Element(account.getCacheKey(), account);
			accountSyncCache.put(e);

			List<AccountUserSyncCacheData> userList = changedAccountsAndUsersInBlock.get(account);
			if (userList != null)
			{
				for (AccountUserSyncCacheData user : userList)
				{
					Element eu = new Element(user.getCacheKey(), user);
					accountUserSyncCache.put(eu);
				}
			}
		}
		logger.debug("Account Sync successfully acknowledged " + accIdList.size()
				+ ", account ids: "
				+ accIdList.toString());
	}

	@Override
	public void updateDoNotManageState(int accountId, String dnm, Integer tenantId)
			throws AccountNotFoundException
	{
		TenantContext.setCurrentTenant(tenantId);
		Account account = getAccountEntityById(accountId);
		if (account == null)
		{
			throw new AccountNotFoundException(
					DefaultResources.ACC_ERR_ACCOUNT_NOT_FOUND,
					"No Account found for account id=" + accountId);
		}
		// Require that the accountId supplied has ONE and ONLY ONE ESI
		// associated with it.
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account.getAccountId());
		if (esiList == null || esiList.size() == 0)
		{
			logger.error("ERROR, No ESI found for accId = " + account.getAccountId());
			return;
		}
		else if (esiList.size() > 1)
		{
			logger.error("ERROR, More than 1 ESI assigned to accId = " + account.getAccountId());
			return;
		}

		// Use the one ESI assignment to determine the gateway.
		Esi esi = esiList.get(0);
		
		if (isAccountInDmControl(esi))
		{
			logger.info("Account {} is in DM Control ", account.getAccountId());
			return;
		}
		else
		{
			try
			{
				demandManagerBeanLocal.disableDmConfig(accountId);
			} catch (Exception e)
			{
				logger.info(e.getMessage());
			}
		}
		
		EsiGateway esiGW = esi.getEsiGatewayId();

		if (OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID == esi.getNetworkDeliveryId())
		{
			// must be a GS ESI, go ahead and set ESI to passed in mode
			logger.debug("setting the DNM mode for GS devices for accID = "
					+ account.getAccountId());
			updateGSEsiDNM(esi, dnm);
			return;
		}
		int gwMqId = esiGW.getGatewayMqId();
		String gwCacheKey = Integer.toString(gwMqId);
		int esiMQId = esi.getEsiMqId();
		String esiDevKey = getCacheKey(esiMQId, gwCacheKey);

		// krmt-4692-- set to allow ignore of first reading msg during
		// processing of reading
		Element esiElement = cacheManager.getGwEsiCache().get(esiDevKey);
		if (esiElement != null)
		{
			EsiCacheData esiCacheData = (EsiCacheData) esiElement.getObjectValue();
			esiCacheData.setFirstReadIdAfterModeChange(0);
			cacheManager.getGwEsiCache().put(esiElement);
		}

 		
			try
			{

				if (checkDevicesAndAssignDefaultProgramData(esi))
				{
					userProgramBean.publishMessageForSingleAccount(account.getAccountId(), false);
				}
				// send msg to GW to go to Normal state (required to exit
				// unmanaged mode) and push programs if necessary
				// krmt-6008-- ensure gw gets programs before getting the mode
				// change
 			}
			catch (Exception e)
			{
				logger.error(" Failed sending Programs to AccountId=" + accountId + ": "
						+ e.toString());
			}
		

 
 	}

	private boolean isAccountInDmControl(Esi esi)
	{
		for (EsiDc esiDc : esi.getEsiDcCollection())
		{
			if (OpsCenterConstants.MANAGE_MODE_DM_CONTROL == esiDc.getManageModeId().getManageModeId())
			{
				return true;
			}
		}
		return false;
	}

	private void updateGSEsiDNM(Esi esi, String dnm)
	{

		// Inactive is a weird case as it is an Ops only mode, not a GW mode

		Results results = cacheManager.getCacheDataByEsiId(cacheManager.getGsTstatCache(),
				esi.getEsiId());

		for (Result result : results.all())
		{
			GridStreamTstatCacheData tstatCacheData = (GridStreamTstatCacheData) result.getValue();
			updateGSDeviceTstatDNM(esi, tstatCacheData, dnm);

		}

		// now figure out if there are LCS devices and set them to DNM

		results = cacheManager.getCacheDataByEsiId(cacheManager.getGwDCCache(), esi.getEsiId());

		for (Result result : results.all())
		{
			EsiDcCacheData esiDcCacheData = (EsiDcCacheData) result.getValue();
			updateGSDeviceLcsDNM(esi, esiDcCacheData, dnm);
		}

	}

	
	public void updateGSDeviceTstatDNM(Esi esi, GridStreamTstatCacheData tstatCacheData, String dnm)
	{

		if (tstatCacheData == null)
		{
			logger.error("No GS Tstat cache found in cache, could not set DNM");
			return;
		}

		DateTime currTime = new DateTime();
		ArrayList<byte[]> payloadList = new ArrayList<byte[]>();
		List<EndpointIdentifier> endpointidentifierList = new ArrayList<EndpointIdentifier>();
		byte[] mode = new byte[1];
		ManageMode manageModeId = null;
		if (OpsCenterConstants.TRUE.equals(dnm))
		{
			mode[0] = OpsCenterConstants.ESI_MODE_UNMANAGED;
		}
		else
		{
			mode[0] = OpsCenterConstants.ESI_MODE_NORMAL;
		}

		// Inactive is a weird case as it is an Ops only mode, not a GW mode
		if (OpsCenterConstants.TRUE.equals(dnm))
		{
			manageModeId = esiBeanFacade.getRefManageMode(OpsCenterConstants.MANAGE_MODE_UNMANAGED);
		}
		else
		{
			manageModeId = esiBeanFacade.getRefManageMode(OpsCenterConstants.MANAGE_MODE_NORMAL);
		}
		Boolean checkForWifiTstat=false;
		EsiDc prevModeEsiDc=esiBeanFacade.findEsiDcByEsiDcId(tstatCacheData.getEsiDcId());
		if(prevModeEsiDc != null)
		{
			if(prevModeEsiDc.getDeviceTypeId().getDeviceTypeId()==OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT)
			{
				checkForWifiTstat=true;
			}	
		}
		
		if(!checkForWifiTstat)
		{
		DeviceConfigMessage devConfig = new DeviceConfigMessage();

		// here is we need to build the only table supported in3.5
		devConfig.setMessageId(currTime.getMillis());
		devConfig.setTimeStamp(currTime.getMillis());
		devConfig.setDeviceMacAddress(tstatCacheData.getDeviceMacId());
		devConfig.setNumOfConfigBlocks(UserBean.numOfConfigBlocks);
		devConfig.setTableId(UserBean.tableId);
		devConfig.setDataSize(UserBean.numOfConfigBlocks);
		devConfig.setData(mode);
		payloadList.add(devConfig.getPayload());
		EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
		endpointIdentifier.setMacId(tstatCacheData.getDeviceMacId());
		endpointidentifierList.add(endpointIdentifier);
		// now build the msg and send to the GW
		publisher.publishBulk(endpointidentifierList, payloadList);
		logger.debug("Dumping DeviceConfigMessage to be sent-->"
				+ ByteUtilityLocal.asHex(devConfig.getPayload()));
		}
		// EsiDcHistoryTable gets inserted automatically when updating EsiDc
		// (b/c extends EsiAuditable)
		// Get esiDc to check previous Mode id, get esiTstat for tstatId.
		//final EsiDc prevModeEsiDc = esiBeanFacade.findEsiDcByEsiDcId(tstatCacheData.getEsiDcId());
		
		if (prevModeEsiDc == null)
		{
			logger.error("prevModeEsiDc returned null in updateGSDeviceTstatDNM()");
			return;
		}
				
		prevModeEsiDc.setPrevManageModeId(prevModeEsiDc.getManageModeId());
		prevModeEsiDc.setManageModeId(manageModeId);

		// esiBeanFacade.updateEsiDcManageModes(tstatCacheData.getEsiDcId(),
		// manageModeId);
		/*logger.debug("updateGSEsiDNM: Updating manage mode for esi dc =  "
				+ tstatCacheData.getEsiDcId() + " mode id = " + manageModeId.getManageModeId());*/

		// if(prevModeEsiDc!=null &&
		// prevModeEsiDc.getPrevManageModeId().getManageModeId() !=
		// manageModeId.getManageModeId()){
		// //Update EsiTstatHistory table as previousManageMode and
		// newManageMode are not same, Hence there is change in mode.
		// final List<EsiTstat> esiTstatList =
		// esiBeanFacade.getEsiTstatByEsiId(tstatCacheData.getEsiId());
		// int tstatId = (esiTstatList!=null && !esiTstatList.isEmpty()) ?
		// esiTstatList.get(0).getTstatId().getTstatId() : 0;
		// genericBean.generateEsiTstatHistory(tstatCacheData.getEsiTstatId(),
		// tstatId, prevModeEsiDc.getEsiDcId(), tstatCacheData.getEsiId(),
		// 7, 7, prevModeEsiDc.getPrevManageModeId().getManageModeId(),
		// manageModeId.getManageModeId(), "Mode Change");
		// }

		// now get the esiDc for this tstat
		Results results = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(),
				tstatCacheData.getEsiHvacDcId());
		EsiDcCacheData dcCacheData = null;
		for (Result rs : results.all())
		{
			dcCacheData = (EsiDcCacheData) rs.getValue();
		}
		if (dcCacheData != null)
		{
			dcCacheData.setDcMode(mode[0]);
			//set to ignore the first read updating the mode in cache, after the mode change which may report the old mode
			dcCacheData.setFirstReadAfterDnmModeChange(true);
			logger.debug("updateGSEsiDNM: isFirstReadAfterDnmModeChange in esiDcCache set to true for "+dcCacheData.getDeviceMacId());     
			Element element = new Element(dcCacheData.getCacheKey(), dcCacheData);
			cacheManager.getGwDCCache().put(element);
		}
		if(!checkForWifiTstat)
		publishProgramPush(esi, tstatCacheData, dnm);
	}


	public void updateGSDeviceLcsDNM(Esi esi, EsiDcCacheData esiDcCacheData, String dnm)
	{

		ArrayList<byte[]> payloadList = new ArrayList<byte[]>();
		DateTime currTime = new DateTime();
		List<EndpointIdentifier> endpointidentifierList = new ArrayList<EndpointIdentifier>();
		byte[] mode = new byte[1];
		Boolean checkForWifiTstat=false;

		Element element = null;
		if (OpsCenterConstants.TRUE.equals(dnm))
		{
			mode[0] = OpsCenterConstants.ESI_MODE_UNMANAGED;
		}
		else
		{
			mode[0] = OpsCenterConstants.ESI_MODE_NORMAL;
		}

		ManageMode manageModeId;
		if (OpsCenterConstants.TRUE.equals(dnm))
		{
			manageModeId = esiBeanFacade.getRefManageMode(OpsCenterConstants.MANAGE_MODE_UNMANAGED);
		}
		else
		{
			manageModeId = esiBeanFacade.getRefManageMode(OpsCenterConstants.MANAGE_MODE_NORMAL);
		}

		if (esiDcCacheData == null)
		{
			logger.error("No GS LCS cache found in cache, could not set DNM");
			return;
		}
		if (esiDcCacheData != null && OpsCenterConstants.THIRD_PARTY_TSTAT.equals(esiDcCacheData.getDeviceType()))
		{
			checkForWifiTstat = true;
		}
		if (esiDcCacheData.getRelayNo() != 0)
		{
			// lcs must have at least 1 relay assigned
			List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiDcId(esiDcCacheData.getEsiDcId());
			EsiDc esiDc = esiDcList != null && !esiDcList.isEmpty() ? esiDcList.get(0) : null;
			// now build the msg and send to the GW
			
			
			if(!checkForWifiTstat)
			{
				DeviceConfigMessage devConfig = new DeviceConfigMessage();
				// here is we need to build the only table supported in3.5
				devConfig.setMessageId(currTime.getMillis());
				devConfig.setTimeStamp(currTime.getMillis());
				devConfig.setDeviceMacAddress(esiDcCacheData.getDeviceMacId());
				devConfig.setNumOfConfigBlocks(UserBean.numOfConfigBlocks);
				devConfig.setTableId(UserBean.tableId);
				devConfig.setDataSize(UserBean.numOfConfigBlocks);
				devConfig.setData(mode);
				payloadList.add(devConfig.getPayload());
				EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
				endpointIdentifier.setMacId(esiDcCacheData.getDeviceMacId());
				endpointidentifierList.add(endpointIdentifier);
				publisher.publishBulk(endpointidentifierList, payloadList);
				logger.debug("Dumping DeviceConfigMessage to be sent-->"
					+ ByteUtilityLocal.asHex(devConfig.getPayload()));
			}

			element = cacheManager.getGwDCCache().get(esiDcCacheData.getCacheKey());
			esiDcCacheData.setDcMode(mode[0]);
			//set to ignore the first read updating the mode in cache, after the mode change which may report the old mode
			esiDcCacheData.setFirstReadAfterDnmModeChange(true);
			logger.debug("updateGSEsiDNM: isFirstReadAfterDnmModeChange in esiDcCache set to true for "+esiDcCacheData.getDeviceMacId());

			cacheManager.getGwDCCache().put(element);
			// EsiDcHistory is updated automatically when EsiDc (b/c extends
			// EsiAuditable) is updated
			
			if (esiDc == null)
			{
				logger.error("esiDc returned null in updateGSDeviceLcsDNM()");
				return;
			}
			
			esiDc.setPrevManageModeId(esiDc.getManageModeId());
			esiDc.setManageModeId(manageModeId);
			// esiBeanFacade.updateEsiDcManageModes(esiDcCacheData.getEsiDcId(),
			// manageModeId);
			logger.debug("updateGSEsiDNM: Updating manage mode for esi dc =  "
					+ esiDcCacheData.getEsiDcId()
					+ " mode id = " + manageModeId.getManageModeId());

			// if (esiDc != null && esiDc.getManageModeId().getManageModeId() !=
			// manageModeId.getManageModeId())
			// {
			// EsiLcs esiLcs =
			// esiBeanFacade.getEsiLcsByDeviceMacId(esiDc.getDeviceMacId());
			// if (esiLcs != null)
			// {
			// genericBean.generateEsiLcsHistory(esiLcs.getEsiLcsId(),
			// esiLcs.getLcsId(), esiDc.getEsiId(), esiDc.getDeleteFlag(),
			// esiDc.getManageModeId().getManageModeId(),
			// manageModeId.getManageModeId());
			// }
			// }
		}
		if(!checkForWifiTstat)
		{
		publishProgramPush(esi, esiDcCacheData, dnm);
		}
	}
	
	@Override
	public HashMap<Integer, BitSet> getToggleRelayStatus(String serialNo,
			Integer[] relayId, Integer tenantId) {
		TenantContext.setCurrentTenant(tenantId);
		HashMap<Integer, BitSet> relayStatusHash = new HashMap<Integer, BitSet>();
		
		if (relayId == null) {
			logger.error("relayId is missing " + serialNo);
			return null;
		}		

		for (int i = 0; i < relayId.length; i++) {
			if (serialNo == null) {
				logger.error("serial Number is missing " + serialNo);
				return null;
			}
			Long deviceMacId = Long.parseLong(serialNo, 16);

			EsiDcCacheData gsLcsEsiDcCache = null;
			StringBuffer key = new StringBuffer();
			List<EsiDc> esiDc = esiBeanFacade.getEsiDcByDevMacIdAndRelay(
					deviceMacId, relayId[i].toString());
			if (esiDc == null) {
				logger.error("LCS not found in DB, serial Numberc = "
						+ serialNo);
				return null;
			}

			key.append((Long) deviceMacId);
			key.append(relayId[i].toString());

			String cacheKey = key.toString();
			Element element = cacheManager.getGwDCCache().get(cacheKey);
			if (element != null) {
				gsLcsEsiDcCache = (EsiDcCacheData) element.getObjectValue();
			} else {
				logger.error("GS LCS not found in cache, devMac = " + cacheKey);
				return null;
			}
			relayStatusHash.put(relayId[i],
					gsLcsEsiDcCache.getToggleRelayStatus());
		}

		return relayStatusHash;
	}
	
	@Override
	public void clearToggleRelayStatus(String serialNo,
			Integer[] relayId, Integer tenantId) 
	{
		TenantContext.setCurrentTenant(tenantId);
		if (relayId == null) {
			logger.error("relayId is missing " + serialNo);
			return;
		}		

		for (int i = 0; i < relayId.length; i++) {
			if (serialNo == null) {
				logger.error("serial Number is missing " + serialNo);
				return;
			}
			Long deviceMacId = Long.parseLong(serialNo, 16);

			EsiDcCacheData gsLcsEsiDcCache = null;
			StringBuffer key = new StringBuffer();
			List<EsiDc> esiDc = esiBeanFacade.getEsiDcByDevMacIdAndRelay(
					deviceMacId, relayId[i].toString());
			if (esiDc == null) {
				logger.error("LCS not found in DB, serial Numberc = "
						+ serialNo);
				return;
			}

			key.append((Long) deviceMacId);
			key.append(relayId[i]);

			String cacheKey = key.toString();
			Element element = cacheManager.getGwDCCache().get(cacheKey);
			if (element != null) {
				gsLcsEsiDcCache = (EsiDcCacheData) element.getObjectValue();
			} else {
				logger.error("GS LCS not found in cache, devMac = " + cacheKey);
				return;
			}
			gsLcsEsiDcCache.getToggleRelayStatus().clear();
		}
	}
	
	@Override
	public void processSendDeviceToggleRequest(String serialNo,
			Integer[] relayId, int userModifiedId, Integer tenantId) {
		TenantContext.setCurrentTenant(tenantId);
		if (serialNo == null || relayId.length == 0) {
			logger.error("relayId or serial no is missing " + serialNo + " "
					+ relayId);
			return;
		}
		try {
			Long devMacId = Long.parseLong(serialNo, 16);
			short toggleduration = 0;
			// retrieve toggle duration from DB
			toggleduration = getToggleDuration(tenantId);

			if (toggleduration == 0) {
				logger.error("toggle duration is 0. Not sending the DeviceToggleRequest");
				return;
			}
			if (toggleduration == -1) {
				logger.error("toggle duration cannot be retrieved from database. Not sending the DeviceToggleRequest");
				return;
			}

			DateTime currentTime = new DateTime();

			DeviceToggleRequest deviceToggleRequest = new DeviceToggleRequest();
			deviceToggleRequest.setTimeStamp(currentTime.getMillis());
			deviceToggleRequest.setMessageId(currentTime.getMillis());
			deviceToggleRequest.setDeviceMacAddress(devMacId);
			deviceToggleRequest.setNumRelays(relayId.length);
			deviceToggleRequest.setRelayId(relayId);
			deviceToggleRequest.setToggleduration(toggleduration);

			EndpointIdentifier endpointIdentifier = new EndpointIdentifier();
			endpointIdentifier.setMacId(devMacId);
			publisher.publish(endpointIdentifier,
					deviceToggleRequest.getPayload());

			// set the bit for In progress for both relays and clear others
			for (int i = 0; i < relayId.length; i++) {
				EsiDcCacheData gsLcsEsiDcCache = null;
				StringBuffer key = new StringBuffer();

				List<EsiDc> esiDc = esiBeanFacade.getEsiDcByDevMacIdAndRelay(
						devMacId, relayId[i].toString());
				if (esiDc == null) {
					logger.error("LCS not found in DB, serial Numberc = "
							+ serialNo);
					return;
				}

				key.append((Long) devMacId);
				key.append(relayId[i]);

				String cacheKey = key.toString();
				Element element = cacheManager.getGwDCCache().get(cacheKey);
				if (element != null) {
					gsLcsEsiDcCache = (EsiDcCacheData) element.getObjectValue();
				} else {
					logger.error("GS LCS not found in cache, devMac = "
							+ cacheKey);
					return;
				}
				gsLcsEsiDcCache.getToggleRelayStatus().clear();
				gsLcsEsiDcCache.setToggleRelayStatus(OpsCenterConstants.ToggleRelayStatus.IN_PROGRESS.getIndex());
				gsLcsEsiDcCache.setToggleRelayStartTime(currentTime.getMillis());
				gsLcsEsiDcCache.setToggleRelayUserModified(userModifiedId);
				// cache object must always be "put" to partner server -krmt-7634
				Element ele = new Element(gsLcsEsiDcCache.getCacheKey(), gsLcsEsiDcCache);
				cacheManager.getGwDCCache().put(ele);
			}
		} catch (Exception e) {
			logger.error(
					"processSendDeviceToggleRequest() - >>> failed for Serial No = "
							+ serialNo + "  relay id = " + relayId, e);
			e.printStackTrace();
			throw new PublishMessageFailedException(e);
		}
	}

	private void publishProgramPush(Esi esi, Macable macable, String dnm)
	{

		// not push program only if we are going out of DNM and back to NORMAL
		// state
		if (OpsCenterConstants.FALSE.equals(dnm))
		{
			try
			{
				publishGwActivation(esi, macable.getDeviceMacId());
			}
			catch (Exception e)
			{
				logger.error(" Failed sending Programs to esi=" + esi.getEsiId()
						+ ": " + e.toString());
			}
		}
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#updateRolesForUser(int, java.util.List)
	 */
	
	public void updateRolesForUser(int userId, List<RoleModel> roleModels, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		
		// This method uses a whole replacement algorithm. All existing roles
		// are deleted
		// and then all new roles are added.
		try
		{
			// First get the user
			User user = getUser(userId);
			if (user == null)
			{
				throw new Exception("updateRolesForUser: No user returned for user id: " + userId);
			}

			// We do a whole replace, so first delete existing roles
			List<UserRoleMap> oldRoles = userAccFacade.getUserRoleMapByUserId(userId);
			for (UserRoleMap mapToBeDeleted : oldRoles)
			{
				userAccFacade.deleteUserRoleMap(mapToBeDeleted);
			}

			// Now add the new roles, creating a user role map based on the role
			// model map
			for (RoleModel model : roleModels)
			{
				List<Role> rolesReturned = userAccFacade.getRoleByRoleName(model.getRoleName());
				for (Role newRole : rolesReturned)
				{
					UserRoleMap mapToBeAdded = new UserRoleMap();
					mapToBeAdded.setUserId(user);
					mapToBeAdded.setRoleId(newRole);
					userAccFacade.createUserRoleMap(mapToBeAdded);
				}
			}
		}
		catch (Exception exp)
		{
			logger.error("Exception in updateRolesForUser: " + exp.getMessage());
		}
	}

	/**
	 * Changes user info in provided reference
	 * 
	 * User name and password will not be updated.
	 * 
	 * @param user
	 *        User instance to be updated
	 * @throws SystemUnavailableException
	 * @throws Exception
	 */
	
	public void updateUser(User user) throws SystemUnavailableException,
			Exception
	{
		logger.info("updateUser() - starting");

		if (user == null)
		{
			if (logger.isTraceEnabled())
			{
				logger.trace("user is null");
			}
			return;
		}

		// Get a copy of the user info before the update
		UserModel origUser = User2UserModel(user);

		/*
		 * DEV-1292 Fetch failure count and lock flags from user model
		 * In case of password resets
		 */
		user.setFailureCount(origUser.getFailureCount());
		user.setLockFlag(origUser.getLockFlag());
		user.setPassword(EncryptService.getInstance().encrypt(user.getPassword()));
		user.setDateModified(new DateTime());
		user.setUserModified(user.getUsername());
		updateUserInDatabase(user, origUser);
		logger.info("user updated: " + user.getUsername());
		logger.info("updateUser() - ending");
	}

	// for presentation layer
	
	@Override
	public void updateUser(UserModel userInfo, Integer tenantId) throws SystemUnavailableException, UserNotUniqueException,
			Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] void UserBean.updateUser(UserModel userInfo)");

		if (userInfo == null)
		{
			logger.trace("user is null");
			return;
		}

		// handle not finding userID
		User user = userAccFacade.findUserByUserId(userInfo.getUserId());
		if (user == null)
		{
			throw new UserNotUniqueException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
					+ userInfo.getUsername() + " Not Found");
		}

		// Get a copy of the user info before the update
		UserModel origUserModel = User2UserModel(user);

		// Password
		// KRMT-1901 prevent password lock out
		if (userInfo.getPassword() != null && !userInfo.getPassword().equals(""))
		{
			user.setPassword(EncryptService.getInstance().encrypt(userInfo.getPassword()));
		}
		user.setDateModified(new DateTime());

		// update the active_flag if the user has been enabled/disabled from Utility portal UI
		user.setActiveFlag(userInfo.getActiveFlag());

		// Copy relevant fields from userInfo to currentUser

		// Security Question Info
		SecurityQuestion question = userAccFacade
				.findSecurityQuestionBySecurityQuestionId(userInfo.getSecurityQuestionId());
		user.setSecurityQuestionId(question);
		if (null != userInfo.getSecurityAnswer() && !"".equals(userInfo.getSecurityAnswer().trim()))
		{
			user.setSecurityAnswer(userInfo.getSecurityAnswer());
		}

		// Contact Info
		user.setAddr1City(userInfo.getAddr1City());
		user.setAddr1Country(userInfo.getAddr1Country());
		user.setAddr1Line1(userInfo.getAddr1Line1());
		user.setAddr1Line2(userInfo.getAddr1Line2());
		user.setAddr1State(userInfo.getAddr1State());
		user.setAddr1Zip(userInfo.getAddr1Zip());
		user.setBizPhoneNumber(userInfo.getBizPhoneNumber());
		user.setFaxNumber(userInfo.getFaxNumber());
		user.setFirstName(userInfo.getFirstName());
		user.setHomePhoneNumber(userInfo.getHomePhoneNumber());
		user.setLastName(userInfo.getLastName());
		user.setMobPhoneNumber(userInfo.getMobPhoneNumber());
		user.setTermsAgrmntFlag(userInfo.getTermsAgrmntFlag());
		user.setPasswordResetFlag(userInfo.getPasswordResetFlag());
		/*
		 * DEV-1292 Need to reset failureCount and lockFlag for a utility user on a password reset
		 */
		user.setFailureCount(userInfo.getFailureCount());
		user.setLockFlag(userInfo.getLockFlag());

		user.setEmail(userInfo.getEmail());
		user.setUserModified(userInfo.getUserModified());

		updateUserInDatabase(user, origUserModel);
		logger.info("user updated: " + user.getUsername());

		logger.info("[ EXIT] UserBean.updateUser");
	}

	
	public void updateUserAccountMapping(UserModel userInfo,
			String accountNumber, HashMap<String, String> userDet)
			throws SystemUnavailableException, AccountNumberNotFoundException,
			UserNotUniqueException, Exception
	{

		logger.info("updateUserAccountMapping() - starting");

		Account account = getAccountByAccountNumber(accountNumber);
		if (account == null)
		{
			logger.info("updateUserAccountMapping() - Account is NULL for account number: "
					+ accountNumber);
			throw new AccountNumberNotFoundException(
					DefaultResources.ACC_ERR_CODE_ACCOUNT_NO_NOT_FOUND,
					"No Account found for account number " + accountNumber);
		}

		User user = userAccFacade.findUserByUserId(userInfo.getUserId());
		if (user == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
							+ userInfo.getUsername() + " Not Found");
		}

		// Get a copy of the user info before the update
		UserModel origUser = User2UserModel(user);

		if (userDet.containsKey("homePhone"))
		{
			user.setHomePhoneNumber(userDet.get("homePhone"));
		}
		if (userDet.containsKey("cellPhone"))
		{
			user.setMobPhoneNumber(userDet.get("cellPhone"));
		}
		if (userDet.containsKey("businessPhone"))
		{
			user.setBizPhoneNumber(userDet.get("businessPhone"));
		}
		if (userDet.containsKey("fax"))
		{
			user.setFaxNumber(userDet.get("fax"));
		}

		user.setDateModified(new DateTime());
		user.setUserModified(user.getUsername());

		updateUserInDatabase(user, origUser);

		// List<UserAccountMap> userMaps =
		// userAccFacade.getUserAccountMapByUserId(userInfo.getUserId());
		// UserAccountMap userMap;
		// Iterator<UserAccountMap> it = userMaps.iterator();
		// while (it.hasNext()) {
		// userMap = it.next();
		// if (userMap.getAccountId().getAccountId() == account.getAccountId())
		// {
		// if (userDet.containsKey("email"))
		// userMap.setEmail(userDet.get("email"));
		// if (userDet.containsKey("alternateEmail"))
		// userMap.setAltEmail(userDet.get("alternateEmail"));
		// userAccFacade.updateUserAccountMap(userMap);
		// }
		// }

		logger.info("user updated: " + user.getUsername());
		logger.info("updateUser() - ending");
	}

	/**
	 * Update the user record and the user history record
	 * 
	 * @param updatedUser
	 * @throws Exception
	 */
	private void updateUserInDatabase(User updatedUser, UserModel origUser) throws Exception
	{
		logger.info("[ENTER] void UserBean.updateUserInDatabase(User updatedUser, UserModel origUser)");

		// Write the user history. This is in its own try/catch because
		// we never want an error with the history to prevent the update
		// of the actual user record.
		try
		{
			if (origUser != null)
			{
				StringBuffer fullComment = new StringBuffer(
						"Update to User: Parameter|New Value|Old Value =");
				int changeCount = 0;
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "ActiveFlag",
						updatedUser.getActiveFlag(), origUser.getActiveFlag(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Addr1Line1",
						updatedUser.getAddr1Line1(), origUser.getAddr1Line1(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Addr1Line2",
						updatedUser.getAddr1Line2(), origUser.getAddr1Line2(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Addr1City",
						updatedUser.getAddr1City(), origUser.getAddr1City(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Addr1State",
						updatedUser.getAddr1State(), origUser.getAddr1State(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Addr1Country",
						updatedUser.getAddr1Country(), origUser.getAddr1Country(), changeCount,
						false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Addr1Zip",
						updatedUser.getAddr1Zip(), origUser.getAddr1Zip(), changeCount, false);

				changeCount = addUserHistoryEntry(updatedUser, fullComment, "FirstName",
						updatedUser.getFirstName(), origUser.getFirstName(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "LastName",
						updatedUser.getLastName(), origUser.getLastName(), changeCount, false);

				changeCount = addUserHistoryEntry(updatedUser, fullComment, "HomePhoneNumber",
						updatedUser.getHomePhoneNumber(), origUser.getHomePhoneNumber(),
						changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "MobPhoneNumber",
						updatedUser.getMobPhoneNumber(), origUser.getMobPhoneNumber(), changeCount,
						false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "BizPhoneNumber",
						updatedUser.getBizPhoneNumber(), origUser.getBizPhoneNumber(), changeCount,
						false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "FaxNumber",
						updatedUser.getFaxNumber(), origUser.getFaxNumber(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Email",
						updatedUser.getEmail(), origUser.getEmail(), changeCount, false);

				// KRMT-5411 - prevent null pointer exception:
				// Make sure that something was passed before doing a toString
				String updatedDatePasswordModified = "";
				if (updatedUser.getDatePasswordModified() != null)
				{
					updatedDatePasswordModified = updatedUser.getDatePasswordModified().toString();
				}

				String origDatePasswordModified = "";
				if (origUser.getDatePasswordModified() != null)
				{
					origDatePasswordModified = origUser.getDatePasswordModified().toString();
				}

				changeCount = addUserHistoryEntry(updatedUser, fullComment, "DatePasswordModified",
						updatedDatePasswordModified, origDatePasswordModified, changeCount, false);

				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Password",
						updatedUser.getPassword(), origUser.getPassword(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "PasswordResetFlag",
						updatedUser.getPasswordResetFlag(), origUser.getPasswordResetFlag(),
						changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "DeleteFlag",
						updatedUser.getDeleteFlag(), origUser.getDeleteFlag(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "FailureCount",
						new Integer(updatedUser.getFailureCount()).toString(),
						new Integer(origUser.getFailureCount()).toString(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "LockFlag",
						updatedUser.getLockFlag(), origUser.getLockFlag(), changeCount, false);
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "SecurityAnswer",
						updatedUser.getSecurityAnswer(), origUser.getSecurityAnswer(), changeCount,
						false);

				// KRMT-5411 - prevent null pointer exception:
				// Make sure that something was passed before doing a toString
				String updatedSecurityQuestionId = "";
				if (updatedUser.getSecurityQuestionId() != null)
				{
					updatedSecurityQuestionId = new Integer(updatedUser.getSecurityQuestionId()
							.getSecurityQuestionId()).toString();
				}

				// In the model this value is an integer and therefore cannot be
				// null
				String origSecurityQuestionId = new Integer(origUser.getSecurityQuestionId())
						.toString();
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "SecurityAnswer",
						updatedSecurityQuestionId, origSecurityQuestionId, changeCount, false);

				changeCount = addUserHistoryEntry(updatedUser, fullComment, "TermsAgrmntFlag",
						updatedUser.getTermsAgrmntFlag(), origUser.getTermsAgrmntFlag(),
						changeCount, false);

				// Write and remaining on the last parameter (set flush to
				// true!!!)
				changeCount = addUserHistoryEntry(updatedUser, fullComment, "Username",
						updatedUser.getUsername(), origUser.getUsername(), changeCount, true);

				// Flush history records to the DB. This separates the history
				// save from the save of the user record and allows the user
				// record
				// save to occur even if the history record save fails.
				userAccFacade.flushToGenerateHistoryRecords();
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			logger.error("Error writing user history: " + e.getMessage());
		}

		logger.info("[ EXIT] UserBean.updateUserInDatabase");

		// After history is complete, save the user record
		userAccFacade.updateUser(updatedUser);
	}

	/**
	 * Changes user name using provided reference. Only user name will be updated.
	 * 
	 * If user name already exists it will prevent operation
	 * 
	 * @param user
	 *        Reference to user object
	 * @throws UserNameAlreadyExistsException
	 * @throws Exception
	 */
	
	public void updateUserName(User user)
			throws UserNameAlreadyExistsException, Exception
	{
		User currentUser = null;
		if (logger.isTraceEnabled())
		{
			logger.trace("updateUserName() - starting");
		}

		/* User or user name not valid will prevent updates */
		if (user == null)
		{
			return;
		}

		try
		{
			if (existUserName(user.getUsername()))
			{
				throw new UserNameAlreadyExistsException(
						DefaultResources.USR_ERR_CODE_USER_NAME_ALREADY_EXISTS,
						"User name already registered " + user.getUsername());
			}
			currentUser = userAccFacade.findUserByUserId(user.getUserId());
			if (currentUser != null)
			{
				// Get a copy of the user info before the update
				UserModel origUser = User2UserModel(currentUser);

				currentUser.setUsername(user.getUsername());
				currentUser.setDateModified(new DateTime());
				currentUser.setUserModified(user.getUsername());
				updateUserInDatabase(currentUser, origUser);
			}
			else
			{
				logger.error("user not found at update user name: " + user.getUserId());
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}

		if (logger.isTraceEnabled())
		{
			logger.trace("updateUserName() - ending");
		}
	}

	/**
	 * Changes user password using provided reference. Only password will be updated.
	 * 
	 * @param User
	 *        User reference in DB
	 * @throws SystemUnavailableException
	 * @throws Exception
	 */
	
	@Override
	public void updateUserPassword(UserModel userInfo, Integer tenantId)
			throws SystemUnavailableException, UserNotUniqueException,
			Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		String password = null;
		User currentUser = null;
		logger.info("updateUserPassword() - starting");

		/* User or user name not valid will prevent updates */
		if (userInfo == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User info is null");
		}

		currentUser = userAccFacade.findUserByUserId(userInfo.getUserId());
		if (currentUser == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
							+ userInfo.getUsername() + " Not Found");
		}

		// Get a copy of the user info before the update
		UserModel origUser = User2UserModel(currentUser);

		password = userInfo.getPassword();
		currentUser.setPassword(EncryptService.getInstance().encrypt(password));
		logger.info("updateUserPassword user ID = " + userInfo.getUserId()
				+ " currentUser ID = " + currentUser.getUserId());

		currentUser.setDateModified(new DateTime());
		currentUser.setUserModified(currentUser.getUsername());
		// KRMT-1282
		currentUser.setPasswordResetFlag(OpsCenterConstants.FALSE);
		// KRMT-4078
		currentUser.setDatePasswordModified(new DateTime());

		// KRMT 4364
		// if (userInfo.getLockFlag() != null)
		// {
		currentUser.setLockFlag(OpsCenterConstants.FALSE);
		// }

		currentUser.setFailureCount(0);

		updateUserInDatabase(currentUser, origUser);
		logger.info("user password updated " + currentUser.getPassword());
		logger.info("updateUserPassword() - ending");
	}

	private UserModel User2UserModel(User user)
	{
		UserModel userm = new UserModel();

		// System controlled fields
		userm.setActiveFlag(user.getActiveFlag());
		userm.setDateCreated(user.getDateCreated());
		userm.setDateModified(user.getDateModified());
		userm.setDeleteFlag(user.getDeleteFlag());
		userm.setFailureCount(user.getFailureCount());
		userm.setLockFlag(user.getLockFlag());
		userm.setPassword(user.getPassword());
		userm.setPasswordResetFlag(user.getPasswordResetFlag());
		userm.setUserCreated(user.getUserCreated());
		userm.setUserModified(user.getUserModified());
		userm.setDatePasswordModified(user.getDatePasswordModified());

		// Contact Info
		userm.setAddr1City(user.getAddr1City());
		userm.setAddr1Country(user.getAddr1Country());
		userm.setAddr1Line1(user.getAddr1Line1());
		userm.setAddr1Line2(user.getAddr1Line2());
		userm.setAddr1State(user.getAddr1State());
		userm.setAddr1Zip(user.getAddr1Zip());
		userm.setBizPhoneNumber(user.getBizPhoneNumber());
		userm.setFaxNumber(user.getFaxNumber());
		userm.setFirstName(user.getFirstName());
		userm.setHomePhoneNumber(user.getHomePhoneNumber());
		userm.setLastName(user.getLastName());
		userm.setMobPhoneNumber(user.getMobPhoneNumber());
		userm.setEmail(user.getEmail());

		userm.setSecurityAnswer(user.getSecurityAnswer());
		if (user.getSecurityQuestionId() != null)
		{
			userm.setSecurityQuestionId(user.getSecurityQuestionId()
					.getSecurityQuestionId());
		}
		userm.setTermsAgrmntFlag(user.getTermsAgrmntFlag());

		userm.setUserId(user.getUserId());
		userm.setUsername(user.getUsername());

		// KRMT-3359 set UserTimeZoneModel
		userm.setUserTimeZoneModel(getUserTimeZoneModelforUser(user));

		// DEV-3313 Populate Role list for user, in case this is a utility user
		List<RoleModel> userRoles = getRolesForUser(userm.getUserId(), TenantContext.getCurrentTenant());
		userm.setRoles(userRoles);

		return userm;
	}

	// KRMT-1195: You are allowed to add an account that is already on your
	// account list
	
	public boolean userAccountMapExists(int userId, int accountId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		try
		{
			List<UserAccountMap> userAccountMapping = userAccFacade
					.getUserAccountMapByUserId(userId);
			if (userAccountMapping == null || userAccountMapping.isEmpty())
			{
				return false;
			}

			for (UserAccountMap userAccountMap : userAccountMapping)
			{
				if (userAccountMap.getAccountId().getAccountId() == accountId)
				{
					return true;
				}
			}

			return false;
		}
		catch (Exception any)
		{
			return false;
		}
	}

	private User UserModel2User(UserModel userModel)
	{
		User user = new User();

		SecurityQuestion secQu = entityManager.getReference(SecurityQuestion.class,
				userModel.getSecurityQuestionId());

		user.setSecurityQuestionId(secQu);

		user.setActiveFlag(userModel.getActiveFlag());
		user.setDateCreated(userModel.getDateCreated());
		user.setDateModified(userModel.getDateModified());
		user.setDeleteFlag(userModel.getDeleteFlag());
		user.setFailureCount(userModel.getFailureCount());
		user.setLockFlag(userModel.getLockFlag());
		user.setPassword(userModel.getPassword());
		user.setPasswordResetFlag(userModel.getPasswordResetFlag());
		user.setDatePasswordModified(userModel.getDatePasswordModified());

		user.setUserCreated(userModel.getUserCreated());
		user.setUserId(userModel.getUserId());
		user.setUserModified(userModel.getUserModified());
		user.setUsername(userModel.getUsername());

		user.setAddr1City(userModel.getAddr1City());
		user.setAddr1Country(userModel.getAddr1Country());
		user.setAddr1Line1(userModel.getAddr1Line1());
		user.setAddr1Line2(userModel.getAddr1Line2());
		user.setAddr1State(userModel.getAddr1State());
		user.setAddr1Zip(userModel.getAddr1Zip());
		user.setBizPhoneNumber(userModel.getBizPhoneNumber());
		user.setFaxNumber(userModel.getFaxNumber());
		user.setFirstName(userModel.getFirstName());
		user.setHomePhoneNumber(userModel.getHomePhoneNumber());
		user.setLastName(userModel.getLastName());
		user.setMobPhoneNumber(userModel.getMobPhoneNumber());
		user.setEmail(userModel.getEmail());

		user.setSecurityAnswer(userModel.getSecurityAnswer());
		user.setTermsAgrmntFlag(userModel.getTermsAgrmntFlag());

		// prevent null insert into not-null fields
		if (user.getAddr1City() == null)
		{
			user.setAddr1City("");
		}

		if (user.getAddr1Country() == null)
		{
			user.setAddr1Country("");
		}

		if (user.getAddr1State() == null)
		{
			user.setAddr1State("");
		}

		if (user.getAddr1Zip() == null)
		{
			user.setAddr1Zip("");
		}

		if (user.getAddr1Line1() == null)
		{
			user.setAddr1Line1("");
		}

		if (user.getSecurityAnswer() == null)
		{
			user.setSecurityAnswer("");
		}

		return user;
	}

	/**
	 * Validate security question answer
	 * 
	 * If user not valid will return false
	 * 
	 * @param user
	 * @param answer
	 * @return
	 */
	
	public boolean validateSecurityQuestion(User user, String answer)
	{
		boolean validAnswer = false;
		SecurityQuestion securityQuestion = null;

		logger.info("validateSecurityQuestion() - starting");

		if (user == null)
		{
			return validAnswer;
		}

		securityQuestion = getUserSecurityQuestion(user);
		if (answer.equalsIgnoreCase(user.getSecurityAnswer()))
		{
			validAnswer = true;
		}

		if (logger.isInfoEnabled())
		{
			logger.info("getSecurityQuestionName = "
					+ securityQuestion.getSecurityQuestionName());
			logger.info("Security Answer = " + user.getSecurityAnswer());
			logger.info("validateSecurityQuestion() - ending");
		}
		return validAnswer;
	}

	// For presentation layer
	@Override
	public boolean validateSecurityQuestion(UserModel userInfo, String answer, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		boolean validAnswer = false;
		SecurityQuestionModel securityQuestion = null;

		logger.info("validateSecurityQuestion() - starting");

		if (userInfo == null)
		{
			return validAnswer;
		}

		securityQuestion = getUserSecurityQuestion(userInfo, tenantId);
		if (answer.equalsIgnoreCase(userInfo.getSecurityAnswer()))
		{
			validAnswer = true;
		}

		if (logger.isInfoEnabled())
		{
			logger.info("getSecurityQuestionName = "
					+ securityQuestion.getSecurityQuestionName());
			logger.info("Security Answer = " + userInfo.getSecurityAnswer());
			logger.info("validateSecurityQuestion() - ending");
		}
		return validAnswer;
	}

	/**
	 * Validates is provided password matches user's registered password
	 * 
	 * @param user
	 *        User to be validated
	 * @param password
	 *        Password to be tested
	 * @returns Boolean return True is password match
	 */
	
	public boolean validateUserPassword(UserModel user, String password, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		User currentUser = null;
		boolean passwordValid = false;
		logger.info("validateUserPassword() - starting");

		if (user == null || password == null)
		{
			return passwordValid;
		}
		try
		{
			String encryptedPassword = EncryptService.getInstance().encrypt(
					password);
			currentUser = userAccFacade.findUserByUserId(user.getUserId());
			if (currentUser.getPassword().equals(encryptedPassword))
			{
				logger.info("originalPassword - " + currentUser.getPassword());
				logger.info("providedPassword - " + encryptedPassword);
				passwordValid = true;
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return false;
		}

		logger.info("validateUserPassword() - ending");

		return passwordValid;
	}
	
	/**
	 * Validates is provided password matches user's registered password
	 * 
	 * @param user
	 *        User to be validated
	 * @param password
	 *        Password to be tested
	 * @returns Boolean return True is password match
	 */
	
	public boolean validateUserPassword(int userId, String password, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		boolean passwordValid = false;
		logger.info("validateUserPassword() - starting");

		if (userId == 0 || password == null)
		{
			return passwordValid;
		}
		try
		{
			String encryptedPassword = EncryptService.getInstance().encrypt(
					password);
			User currentUser = userAccFacade.findUserByUserId(userId);
			if (currentUser.getPassword().equals(encryptedPassword))
			{
				logger.info("originalPassword - " + currentUser.getPassword());
				logger.info("providedPassword - " + encryptedPassword);
				passwordValid = true;
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return false;
		}

		logger.info("validateUserPassword() - ending");

		return passwordValid;
	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.UserBeanLocal#whoAmI()
	 */
	
	public String whoAmI()
	{
		Principal principal = null;
		principal = context.getCallerPrincipal();
		String userName = principal.getName();
		return userName;
	}

	@Override
	public List<Integer> getAllActiveAccountIds(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<Integer> accountIdList = userAccFacade.getActiveAccountIdList();

		return accountIdList;
	}
	
	@Override
	public short getToggleDuration(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		short duration = -1;
		List<UtilityProperty> propertyList = genericFacade
				.getUtilityPropertyLikeKey(OpsCenterConstants.UTILITY_TOGGLE_RELAY_DURATION);
		logger.debug("getToggleDuration");
		
		if(propertyList.size() != 0){
			logger.debug(propertyList.get(0).getKey());
			
			if(propertyList.get(0).getValue()!= null){
				duration = (short) Integer.parseInt(propertyList.get(0).getValue());
				logger.debug(propertyList.get(0).getValue());
			}else{
				logger.error("propertyList.get(0).getValue() is null");
			}
		}
		else{
			logger.error("propertyList size is 0");
		}
		return duration;
	}
	
	@Override
	public AccountModel getPrimaryAccountForUser(int userId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		AccountModel account = null;
		try
		{
			UserAccountMap uam = userAccFacade.getUserAccountMapByUserIdandPrimaryFlag(userId, OpsCenterConstants.TRUE);
			if(uam !=null)
			{
				account = Account2AccountModel.convert(uam.getAccountId(), esiBeanFacade,
						userAccFacade);
			}
			
		}
		catch(Exception e)
		{
			logger.error("Exception while fetching primary account");
		}
		
		return account;
	}

	@Override
	public boolean isAccountInDNM(int accountId, Integer tenantId) throws Exception
	{
		TenantContext.setCurrentTenant(tenantId);
		return isAccountInDNM(accountId);
	}
	
	@Override
	public boolean isAccountInDNM(int accountId)
			throws Exception
	{
		logger.info("[ENTER] boolean isAccountInDNM(int accountId)");

		Account currentAccount = getAccountEntityById(accountId);
		
		if (currentAccount != null)
		{
			Set<Esi> accountEsis = currentAccount.getEsiCollection();
			for (Esi currentEsi : accountEsis)
			{
				if (OpsCenterConstants.FALSE.equals(currentEsi.getDeleteFlag()))
				{
					Set<EsiDc> esiDcs = currentEsi.getEsiDcCollection();
					for (EsiDc currentEsiDc : esiDcs)
					{
						if (OpsCenterConstants.FALSE.equals(currentEsiDc.getDeleteFlag()))
						{
							currentEsiDc.getManageModeId();
							ManageMode mngMode = currentEsiDc.getManageModeId();
							
							if (null != mngMode && mngMode.getGatewayMode() == OpsCenterConstants.ESI_MODE_UNMANAGED)
							{
								return true;
							}
						}
					}
				}
			}
			
		}
		else 
		{
			throw new AccountNotFoundException("No acount found for account ID: " + accountId);
		}


		return false;
	}


	public boolean accountHasOnlyWifiTstat(int accountId)
	{
		
		List<Esi> esilist = esiBeanFacade.getEsiByAccountId(accountId);
		for(Esi esiObject:esilist)
		{
			int countWifiTstat=0;
			List<EsiDc> esidcList=esiBeanFacade.getEsiDcByEsiId(esiObject.getEsiId());
			if(esidcList !=null &&esidcList.size()>0)
			{
				for(EsiDc esiDc:esidcList)
				{
					if(OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT==esiDc.getDeviceTypeId().getDeviceTypeId())
					{
						countWifiTstat++;
					}
	}
				if(esidcList.size()==countWifiTstat)
				{
					return true;
				}
			}
			
		}
		return false;
	}

	@Override
	public void processAsynchMessage(String message, Integer tenantId) throws Exception {
		TenantContext.setCurrentTenant(tenantId);
		String messagePayload=message.replaceAll("\"", "");
		byte[] writrTable = ByteUtilityLocal.hexStringToByteArray(messagePayload);
		ParseMessages pm = new ParseMessages( 0, writrTable);
		pm.process();		
	}

	@Override
	public List<PortalUserModel> getPortalPersonalUserInfoSortedByUserId() {
		
		// for presentation layer
		List<PortalUserModel> usersM = new ArrayList<PortalUserModel>();
		LinkedHashMap<MasterPortalUser, Set<MasterPortalUserRoleMap>> userRoleMapsByUser = getPortalPersonalUserInfo();
		Set<MasterPortalUser> users = userRoleMapsByUser.keySet();

		for (MasterPortalUser user : users)
		{
			PortalUserModel userM = Portal2UserModel(user);
			usersM.add(userM);

			List<PortalRoleModel> roles = getRolesFor(userRoleMapsByUser.get(user));
			Collections.sort(roles, Comparator.comparing(PortalRoleModel::getRoleName));
			userM.setRoles(roles);
		}
		return usersM;
	}

	private List<PortalRoleModel> getRolesFor(Set<MasterPortalUserRoleMap> userRoleMapList) {
		
		List<PortalRoleModel> rolesForUser = new ArrayList<PortalRoleModel>();
		Set<Integer> uniqueSet = new HashSet<Integer>();
		for (MasterPortalUserRoleMap map : userRoleMapList)
		{
			MasterPortalRole role = map.getRoleId();
			if(!uniqueSet.add(role.getRoleId())){
				continue;
			}
			PortalRoleModel roleModel = new PortalRoleModel();
			roleModel.setRoleId(role.getRoleId());
			roleModel.setRoleName(role.getRoleName());
			roleModel.setMasterPortalFlag(role.getMasterPortalFlag());
			roleModel.setComments(role.getComments());
			roleModel.setDefaultFlag( role.getDefaultFlag());
			rolesForUser.add(roleModel);
		}

		return rolesForUser;
	}

	private LinkedHashMap<MasterPortalUser, Set<MasterPortalUserRoleMap>> getPortalPersonalUserInfo() {
		
		LinkedHashMap<MasterPortalUser, Set<MasterPortalUserRoleMap>> users = new LinkedHashMap<MasterPortalUser, Set<MasterPortalUserRoleMap>>();
		List<MasterPortalUserRoleMap> userRoleMaps = portalUserFacade.getPortalPersonalUserRoleMapsSortedByUserId();
		if (userRoleMaps == null || userRoleMaps.isEmpty())
		{
			return users;
		}

		for (MasterPortalUserRoleMap map : userRoleMaps)
		{
			MasterPortalUser user = map.getUserId();
			Set<MasterPortalUserRoleMap> mapSet = users.get(user);
			if (mapSet == null)
			{
				mapSet = new HashSet<MasterPortalUserRoleMap>();
				users.put(user, mapSet);
			}
			mapSet.add(map);
		}

		return users;
	}
	
	private PortalUserModel Portal2UserModel(MasterPortalUser user)
	{
		PortalUserModel userm = new PortalUserModel();

		// System controlled fields
		userm.setActiveFlag(user.getActiveFlag());
		userm.setDateCreated(user.getDateCreated());
		userm.setDateModified(user.getDateModified());
		userm.setDeleteFlag(user.getDeleteFlag());
		userm.setFailureCount(user.getFailureCount());
		userm.setLockFlag(user.getLockFlag());
		userm.setPassword(user.getPassword());
		userm.setPasswordResetFlag(user.getPasswordResetFlag());
		userm.setUserCreated(user.getUserCreated());
		userm.setUserModified(user.getUserModified());
		userm.setDatePasswordModified(user.getDatePasswordModified());

		// Contact Info
		userm.setAddr1City(user.getAddr1City());
		userm.setAddr1Country(user.getAddr1Country());
		userm.setAddr1Line1(user.getAddr1Line1());
		userm.setAddr1Line2(user.getAddr1Line2());
		userm.setAddr1State(user.getAddr1State());
		userm.setAddr1Zip(user.getAddr1Zip());
		userm.setBizPhoneNumber(user.getBizPhoneNumber());
		userm.setFaxNumber(user.getFaxNumber());
		userm.setFirstName(user.getFirstName());
		userm.setHomePhoneNumber(user.getHomePhoneNumber());
		userm.setLastName(user.getLastName());
		userm.setMobPhoneNumber(user.getMobPhoneNumber());
		userm.setEmail(user.getEmail());

		userm.setSecurityAnswer(user.getSecurityAnswer());
		if (user.getSecurityQuestionId() != null)
		{
			userm.setSecurityQuestionId(user.getSecurityQuestionId()
					.getSecurityQuestionId());
		}
		userm.setTermsAgrmntFlag(user.getTermsAgrmntFlag());

		userm.setUserId(user.getUserId());
		userm.setUsername(user.getUsrname());

		// DEV-3313 Populate Role list for user, in case this is a utility user
		List<PortalRoleModel> userRoles = portalUserFacade.getRolesForUser(user.getUserId());
		userm.setRoles(userRoles);

		return userm;
	}

	private Map<FunctionModel, String> populateFunctionMapForRole(int roleId,
			Map<FunctionModel, String> functionsForUserMap) {
		
		List<MasterPortalFunctionRoleMap> functionRoleMapList = portalUserFacade.getPortalFunctionRoleMapByRoleIdLocal(roleId);
		for (MasterPortalFunctionRoleMap functionRoleMapObject : functionRoleMapList)
		{
			MasterPortalFunction function = functionRoleMapObject.getFunctionId();
			FunctionModel functionModel = new FunctionModel();

			// HMNBRD-716 initialize the permission value to avoid a NPE when comparing the map
			// value to the function in case the FUNCTION_ROLE_MAP record has a 0 for both read and write.
			String permission = "none";
			if (functionRoleMapObject.getReadFlag().equalsIgnoreCase(OpsCenterConstants.TRUE))
			{
				permission = "read";
			}
			if (functionRoleMapObject.getWriteFlag().equalsIgnoreCase(OpsCenterConstants.TRUE))
			{
				permission = "write";
			}

			functionModel.setComments(function.getComments());
			functionModel.setFunctionGroupId(function.getFunctionGroupId().getFunctionGroupId());
			functionModel.setFunctionId(function.getFunctionId());
			functionModel.setFunctionName(function.getFunctionName());

			// KRMT-2362: upgrade read permission with write permission if
			// applicable
			if (functionsForUserMap.containsKey(functionModel))
			{
				String currentPermission = functionsForUserMap.get(functionModel);
				// Null implies neither read nor write - any permission is an
				// upgrade
				if (currentPermission == null)
				{
					functionsForUserMap.put(functionModel, permission);
				}
				// Write is highest permission,always use it when applicable
				else if (permission != null && permission.equals("write"))
				{
					functionsForUserMap.put(functionModel, permission);
				}
			}
			else
			{
				functionsForUserMap.put(functionModel, permission);
			}
		}
		return functionsForUserMap;
	
	}

	@Override
	public Map<FunctionModel, String> getFunctionsForRoleId(int roleId) {
		
		Map<FunctionModel, String> functionsForRole = new HashMap<FunctionModel, String>();

		logger.info("Method::>getFunctionsForRoleId, Start roleId = " + roleId);

		Map<FunctionModel, String> functionsForUserMap = new HashMap<FunctionModel, String>();

		functionsForRole = populateFunctionMapForRole(roleId, functionsForUserMap);

		logger.info("Method::>getFunctionsForRoleId, End");

		return functionsForRole;

	}


	@Override
	public void createPortalUser(PortalUserModel userInfo, String email, String accountNumber)
			throws UserNameAlreadyExistsException, AccountNumberNotFoundException, Exception {

		logger.info("createPortalUser() - starting.  userInfo: " + userInfo + "  email: " + email
				+ "  accountNumber: "
				+ accountNumber);
		MasterPortalUser user = portalModel2Usr(userInfo);
		String forcePasswordReset = OpsCenterConstants.FALSE;

		// Check for existing user in the database.
		if (existPortalUserName(user.getUsrname()))
		{
			logger.info("createPortalUser() - User Name already Exists: "
					+ user.getUsrname());
			throw new UserNameAlreadyExistsException(
					DefaultResources.USR_ERR_CODE_USER_NAME_ALREADY_EXISTS,
					"User name already registered " + user.getUsrname());

		}

		if (!UserBean.matchEmail(email.trim()))
		{
			logger.info("createPortalUser() - Invalid Email format: " + email);
			return;
		}

		forcePasswordReset = OpsCenterConstants.TRUE;
		logger.info("createPortalUser() - Building user in-memory object");
		user.setDeleteFlag(OpsCenterConstants.FALSE);
		user.setFailureCount(0);
		user.setLockFlag(OpsCenterConstants.FALSE);
		user.setActiveFlag(OpsCenterConstants.TRUE);
		user.setPasswordResetFlag(forcePasswordReset);
		user.setDateCreated(new DateTime());
		// User Modified is a non-null field, so it must be set
		user.setUserModified(user.getUserCreated());
		user.setDateModified(user.getDateCreated());

		// KRMT-1717, Primary email now lives in the user table in Rev 3.1
		if (userInfo.getEmail() != null)
		{
			user.setEmail(userInfo.getEmail());
		}

		user.setEmail(email);

		if (user.getTermsAgrmntFlag() == null)
		{
			user.setTermsAgrmntFlag(OpsCenterConstants.FALSE);
		}

		if (userInfo.getSecurityQuestionId() != 0)
		{
			List<MasterPortalSecurityQuestion> questions = portalUserFacade
					.getPortalSecurityQuestionBySecurityQuestionId(userInfo.getSecurityQuestionId());
			if (questions == null || questions.size() == 0)
			{
				logger.error("createPortalUser() - Security question not found for question number: "
						+ userInfo.getSecurityQuestionId());
				throw new SecurityQuestionNumberNotFoundException(
						DefaultResources.SEC_CODE_QUESTION_NO_NOT_FOUND,
						"No Security Question found for question number "
								+ userInfo.getSecurityQuestionId());
			}

			// For a given security question ID there will never be more
			// than one question.
			user.setSecurityQuestionId(questions.get(0));
		}
		else
		{
			user.setSecurityQuestionId(null);
		}

		user.setPassword(EncryptService.getInstance().encrypt(
				user.getPassword()));

		try
		{
			logger.info("createPortalUser() - Calling create() on userAccFacade");
			portalUserFacade.createPortalUser(user);
			logger.info("createPortalUser() - Created User! : " + user.getUserId()
					+ " : " + user.getUsrname());
		}
		catch (Exception ex)
		{
			logger
					.error("createPortalUser() !! Caught Exception while creating user: "
							+ ex.getClass().getSimpleName()
							+ ": "
							+ ex.getMessage());
			ex.printStackTrace();
			throw ex;
		}

		logger.info("createPortalUser() - ending");
	}

	private MasterPortalUser portalModel2Usr(PortalUserModel userModel)
	{
		MasterPortalUser user = new MasterPortalUser();

		MasterPortalSecurityQuestion secQu = entityManager1.getReference(MasterPortalSecurityQuestion.class,
				userModel.getSecurityQuestionId());

		user.setSecurityQuestionId(secQu);

		user.setActiveFlag(userModel.getActiveFlag());
		user.setDateCreated(userModel.getDateCreated());
		user.setDateModified(userModel.getDateModified());
		user.setDeleteFlag(userModel.getDeleteFlag());
		user.setFailureCount(userModel.getFailureCount());
		user.setLockFlag(userModel.getLockFlag());
		user.setPassword(userModel.getPassword());
		user.setPasswordResetFlag(userModel.getPasswordResetFlag());
		user.setDatePasswordModified(userModel.getDatePasswordModified());

		user.setUserCreated(userModel.getUserCreated());
		user.setUserId(userModel.getUserId());
		user.setUserModified(userModel.getUserModified());
		user.setUsrname(userModel.getUsername());

		user.setAddr1City(userModel.getAddr1City());
		user.setAddr1Country(userModel.getAddr1Country());
		user.setAddr1Line1(userModel.getAddr1Line1());
		user.setAddr1Line2(userModel.getAddr1Line2());
		user.setAddr1State(userModel.getAddr1State());
		user.setAddr1Zip(userModel.getAddr1Zip());
		user.setBizPhoneNumber(userModel.getBizPhoneNumber());
		user.setFaxNumber(userModel.getFaxNumber());
		user.setFirstName(userModel.getFirstName());
		user.setHomePhoneNumber(userModel.getHomePhoneNumber());
		user.setLastName(userModel.getLastName());
		user.setMobPhoneNumber(userModel.getMobPhoneNumber());
		user.setEmail(userModel.getEmail());

		user.setSecurityAnswer(userModel.getSecurityAnswer());
		user.setTermsAgrmntFlag(userModel.getTermsAgrmntFlag());

		// prevent null insert into not-null fields
		if (user.getAddr1City() == null)
		{
			user.setAddr1City("");
		}

		if (user.getAddr1Country() == null)
		{
			user.setAddr1Country("");
		}

		if (user.getAddr1State() == null)
		{
			user.setAddr1State("");
		}

		if (user.getAddr1Zip() == null)
		{
			user.setAddr1Zip("");
		}

		if (user.getAddr1Line1() == null)
		{
			user.setAddr1Line1("");
		}

		if (user.getSecurityAnswer() == null)
		{
			user.setSecurityAnswer("");
		}

		return user;
	}

	@Override
	public void updateRolesForPortalUser(int userId, List<PortalRoleModel> roleModels) {

		
		// This method uses a whole replacement algorithm. All existing roles
		// are deleted
		// and then all new roles are added.
		try
		{
			// First get the user
			MasterPortalUser user = getPortalUser(userId);
			if (user == null)
			{
				throw new Exception("updateRolesForPortalUser: No user returned for user id: " + userId);
			}

			// We do a whole replace, so first delete existing roles
			List<MasterPortalUserRoleMap> oldRoles = portalUserFacade.getPortalUserRoleMapByUserId(userId);
			for (MasterPortalUserRoleMap mapToBeDeleted : oldRoles)
			{
				portalUserFacade.deletePortalUserRoleMap(mapToBeDeleted);
			}

			// Now add the new roles, creating a user role map based on the role
			// model map
			for (PortalRoleModel model : roleModels)
			{
				List<MasterPortalRole> rolesReturned = portalUserFacade.getPortalRoleByRoleName(model.getRoleName());
				for (MasterPortalRole newRole : rolesReturned)
				{
					MasterPortalUserRoleMap mapToBeAdded = new MasterPortalUserRoleMap();
					mapToBeAdded.setUserId(user);
					mapToBeAdded.setRoleId(newRole);
					portalUserFacade.createPortalUserRoleMap(mapToBeAdded);
				}
			}
		}
		catch (Exception exp)
		{
			logger.error("Exception in updateRolesForPortalUser: " + exp.getMessage());
		}
	
		
	}
  
	
	
	/**
	 * @param userId
	 * @return
	 */
	public MasterPortalUser getPortalUser(int userId)
	{
		// First get the user
		List<MasterPortalUser> users = portalUserFacade.getPortalUserByUserId(userId);
		if (users != null && users.size() > 0)
		{
			return users.get(0);
		}

		return null;
	}

	
	public boolean existPortalUserName(String userName)
	{
		boolean existUser = false;
		logger.info("existPortalUserName() - starting");
		logger.info("Username: " + userName);

		if (userName == null || "".equals(userName))
		{
			return false;
		}
		/* Get User object based on user name */
		List<MasterPortalUser> users = portalUserFacade.getPortalUserByUserName(userName);
		if (users == null || users.isEmpty())
		{
			existUser = false;
		}
		else
		{
			existUser = true;
		}

		logger.info("usernamee exists " + existUser);
		logger.info("existPortalUserName() - ending");

		return existUser;
	}

	@Override
	public List<PortalRoleModel> findAllPoralPersonUserRoles() {
		List<MasterPortalRole> utilityRoles = portalUserFacade.getRolesByPortalFlag();
		List<PortalRoleModel> utilityRoleModels = new ArrayList<PortalRoleModel>();
		for (MasterPortalRole role : utilityRoles)
		{
			PortalRoleModel roleModel = new PortalRoleModel();

			roleModel.setRoleId(role.getRoleId());
			roleModel.setRoleName(role.getRoleName());
			roleModel.setMasterPortalFlag(role.getMasterPortalFlag());
			roleModel.setComments(role.getComments());
			roleModel.setDefaultFlag(role.getDefaultFlag());
			
			utilityRoleModels.add(roleModel);
		}

		return utilityRoleModels;
	}

	@Override
	public void updatePortalUser(PortalUserModel userInfo) throws UserNotUniqueException, SystemUnavailableException {

		logger.info("[ENTER] void UserBean.updatePortalUser(UserModel userInfo)");

		if (userInfo == null)
		{
			logger.debug("user is null");
			return;
		}

		// handle not finding userID
		MasterPortalUser user = portalUserFacade.findUserByUserId(userInfo.getUserId());
		if (user == null)
		{
			throw new UserNotUniqueException(DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
					+ userInfo.getUsername() + " Not Found");
		}

		// Get a copy of the user info before the update
		PortalUserModel origUserModel = Portal2UserModel(user);

		// Password
		// KRMT-1901 prevent password lock out
		if (userInfo.getPassword() != null && !userInfo.getPassword().equals(""))
		{
			user.setPassword(EncryptService.getInstance().encrypt(userInfo.getPassword()));
		}
		user.setDateModified(new DateTime());

		// update the active_flag if the user has been enabled/disabled from Utility portal UI
		user.setActiveFlag(userInfo.getActiveFlag());

		// Copy relevant fields from userInfo to currentUser

		// Security Question Info
		MasterPortalSecurityQuestion question = portalUserFacade
				.findSecurityQuestionBySecurityQuestionId(userInfo.getSecurityQuestionId());
		user.setSecurityQuestionId(question);
		if (null != userInfo.getSecurityAnswer() && !"".equals(userInfo.getSecurityAnswer().trim()))
		{
			user.setSecurityAnswer(userInfo.getSecurityAnswer());
		}

		// Contact Info
		user.setAddr1City(userInfo.getAddr1City());
		user.setAddr1Country(userInfo.getAddr1Country());
		user.setAddr1Line1(userInfo.getAddr1Line1());
		user.setAddr1Line2(userInfo.getAddr1Line2());
		user.setAddr1State(userInfo.getAddr1State());
		user.setAddr1Zip(userInfo.getAddr1Zip());
		user.setBizPhoneNumber(userInfo.getBizPhoneNumber());
		user.setFaxNumber(userInfo.getFaxNumber());
		user.setFirstName(userInfo.getFirstName());
		user.setHomePhoneNumber(userInfo.getHomePhoneNumber());
		user.setLastName(userInfo.getLastName());
		user.setMobPhoneNumber(userInfo.getMobPhoneNumber());
		user.setTermsAgrmntFlag(userInfo.getTermsAgrmntFlag());
		user.setPasswordResetFlag(userInfo.getPasswordResetFlag());
		/*
		 * DEV-1292 Need to reset failureCount and lockFlag for a utility user on a password reset
		 */
		user.setFailureCount(userInfo.getFailureCount());
		user.setLockFlag(userInfo.getLockFlag());

		user.setEmail(userInfo.getEmail());
		user.setUserModified(userInfo.getUserModified());

		updatePortalUserInDatabase(user, origUserModel);
		logger.info("user updated: " + user.getUsrname());

		logger.info("[ EXIT] UserBean.updatePortalUser");
	}

	private void updatePortalUserInDatabase(MasterPortalUser updatedUser, PortalUserModel origUser) {
		logger.info("[ENTER] void UserBean.updatePortalUserInDatabase(User updatedUser, UserModel origUser)");

		// Write the user history. This is in its own try/catch because
		// we never want an error with the history to prevent the update
		// of the actual user record.
		try
		{
			if (origUser != null)
			{
				StringBuffer fullComment = new StringBuffer(
						"Update to User: Parameter|New Value|Old Value =");
				int changeCount = 0;
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "ActiveFlag",
						updatedUser.getActiveFlag(), origUser.getActiveFlag(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Addr1Line1",
						updatedUser.getAddr1Line1(), origUser.getAddr1Line1(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Addr1Line2",
						updatedUser.getAddr1Line2(), origUser.getAddr1Line2(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Addr1City",
						updatedUser.getAddr1City(), origUser.getAddr1City(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Addr1State",
						updatedUser.getAddr1State(), origUser.getAddr1State(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Addr1Country",
						updatedUser.getAddr1Country(), origUser.getAddr1Country(), changeCount,
						false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Addr1Zip",
						updatedUser.getAddr1Zip(), origUser.getAddr1Zip(), changeCount, false);

				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "FirstName",
						updatedUser.getFirstName(), origUser.getFirstName(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "LastName",
						updatedUser.getLastName(), origUser.getLastName(), changeCount, false);

				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "HomePhoneNumber",
						updatedUser.getHomePhoneNumber(), origUser.getHomePhoneNumber(),
						changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "MobPhoneNumber",
						updatedUser.getMobPhoneNumber(), origUser.getMobPhoneNumber(), changeCount,
						false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "BizPhoneNumber",
						updatedUser.getBizPhoneNumber(), origUser.getBizPhoneNumber(), changeCount,
						false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "FaxNumber",
						updatedUser.getFaxNumber(), origUser.getFaxNumber(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Email",
						updatedUser.getEmail(), origUser.getEmail(), changeCount, false);

				// KRMT-5411 - prevent null pointer exception:
				// Make sure that something was passed before doing a toString
				String updatedDatePasswordModified = "";
				if (updatedUser.getDatePasswordModified() != null)
				{
					updatedDatePasswordModified = updatedUser.getDatePasswordModified().toString();
				}

				String origDatePasswordModified = "";
				if (origUser.getDatePasswordModified() != null)
				{
					origDatePasswordModified = origUser.getDatePasswordModified().toString();
				}

				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "DatePasswordModified",
						updatedDatePasswordModified, origDatePasswordModified, changeCount, false);

				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Password",
						updatedUser.getPassword(), origUser.getPassword(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "PasswordResetFlag",
						updatedUser.getPasswordResetFlag(), origUser.getPasswordResetFlag(),
						changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "DeleteFlag",
						updatedUser.getDeleteFlag(), origUser.getDeleteFlag(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "FailureCount",
						new Integer(updatedUser.getFailureCount()).toString(),
						new Integer(origUser.getFailureCount()).toString(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "LockFlag",
						updatedUser.getLockFlag(), origUser.getLockFlag(), changeCount, false);
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "SecurityAnswer",
						updatedUser.getSecurityAnswer(), origUser.getSecurityAnswer(), changeCount,
						false);

				// KRMT-5411 - prevent null pointer exception:
				// Make sure that something was passed before doing a toString
				String updatedSecurityQuestionId = "";
				if (updatedUser.getSecurityQuestionId() != null)
				{
					updatedSecurityQuestionId = new Integer(updatedUser.getSecurityQuestionId()
							.getSecurityQuestionId()).toString();
				}

				// In the model this value is an integer and therefore cannot be
				// null
				String origSecurityQuestionId = new Integer(origUser.getSecurityQuestionId())
						.toString();
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "SecurityAnswer",
						updatedSecurityQuestionId, origSecurityQuestionId, changeCount, false);

				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "TermsAgrmntFlag",
						updatedUser.getTermsAgrmntFlag(), origUser.getTermsAgrmntFlag(),
						changeCount, false);

				// Write and remaining on the last parameter (set flush to
				// true!!!)
				changeCount = addPortalUserHistoryEntry(updatedUser, fullComment, "Username",
						updatedUser.getUsrname(), origUser.getUsername(), changeCount, true);
			}
		}
				catch (Exception e)
				{
					e.printStackTrace();
					logger.error("Error writing user history: " + e.getMessage());
				}

				logger.info("[ EXIT] UserBean.updatePortalUserInDatabase");

				// After history is complete, save the user record
		
		
		
		portalUserFacade.updateUser(updatedUser);
	}
			
			
			private int addPortalUserHistoryEntry(MasterPortalUser user, StringBuffer fullComment, String paramName, String newParam,
					String oldParam, int changeCount, boolean flush) throws Exception
			{   
				PortalUserModel userModel = Portal2UserModel(user);
				int baseLength = new String("Update to User: Parameter|New Value|Old Value =").length();

				if (paramName == null)
				{
					paramName = "";
				}

				if (newParam == null)
				{
					newParam = "";
				}

				if (oldParam == null)
				{
					oldParam = "";
				}

				// No change
				if (newParam.equals(oldParam))
				{
					// Handle the flush with no change scenario
					if (flush)
					{
						if (changeCount > 0)
						{   
							
							portalUserFacade.updatePortalHistory(userModel,OpsCenterConstants.HISTORY_ACTION_LOGIN, fullComment.toString());
							changeCount = 0;
							fullComment.deleteCharAt(baseLength); // it is important to
																	// operate on the
																	// passed
																	// StringBuffer
																	// instance
						}
					}

					return changeCount;
				}

				// If we get here then the entry has changed
				String newEntry = " " + paramName + "|" + newParam + "|" + oldParam;

				// If the total record length exceeds the DB field length,
				// flush what we have and start a new entry.
				if (fullComment.length() + newEntry.length() > 254)
				{
					portalUserFacade.updatePortalHistory(userModel,OpsCenterConstants.HISTORY_ACTION_LOGIN, fullComment.toString());
					changeCount = 0;
					fullComment.delete(baseLength, fullComment.length()); // it is
																			// important
																			// to
																			// operate
																			// on the
																			// passed
																			// StringBuffer
																			// instance
				}

				// Append the the new entry to the buffer
				fullComment.append(newEntry);
				++changeCount;

				// Last history entry - flush the record
				if (flush)
				{
					// Handle the flush with change scenario
					portalUserFacade.updatePortalHistory(userModel,OpsCenterConstants.HISTORY_ACTION_LOGIN, fullComment.toString());
					changeCount = 0;
					fullComment.deleteCharAt(baseLength); // it is important to operate
															// on the passed
															// StringBuffer instance
				}

				return changeCount;
			}

	@Override
	public List<SecurityQuestionModel> getSecurityQuestions() {

		List<MasterPortalSecurityQuestion> securityQuestions = null;
		List<SecurityQuestionModel> securityQuestionModels = new ArrayList<SecurityQuestionModel>();

		logger.info("getSecurityQuestions() - starting");

		securityQuestions = portalUserFacade.getSecurityQuestion();

		for (MasterPortalSecurityQuestion question : securityQuestions)
		{
			SecurityQuestionModel questionM = new SecurityQuestionModel();
			questionM.setSecurityQuestionId(question.getSecurityQuestionId());
			questionM.setSecurityQuestionName(question
					.getSecurityQuestionName());
			securityQuestionModels.add(questionM);
		}

		logger.info("getAvailableQuestions() - ending");
		/* Get security question based on user */
		return securityQuestionModels;
	}

	@Override
	public void updatePortalUserPassword(PortalUserModel userInfo)
			throws SystemUnavailableException, UserNotUniqueException, Exception {

		String password = null;
		MasterPortalUser currentUser = null;
		logger.info("updateUserPassword() - starting");

		/* User or user name not valid will prevent updates */
		if (userInfo == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User info is null");
		}

		currentUser = portalUserFacade.findUserByUserId(userInfo.getUserId());
		if (currentUser == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "User "
							+ userInfo.getUsername() + " Not Found");
		}

		// Get a copy of the user info before the update
		PortalUserModel origUser = Portal2UserModel(currentUser);

		password = userInfo.getPassword();
		currentUser.setPassword(EncryptService.getInstance().encrypt(password));
		logger.info("updateUserPassword user ID = " + userInfo.getUserId()
				+ " currentUser ID = " + currentUser.getUserId());

		currentUser.setDateModified(new DateTime());
		currentUser.setUserModified(currentUser.getUsrname());
		// KRMT-1282
		currentUser.setPasswordResetFlag(OpsCenterConstants.FALSE);
		// KRMT-4078
		currentUser.setDatePasswordModified(new DateTime());

		// KRMT 4364
		// if (userInfo.getLockFlag() != null)
		// {
		currentUser.setLockFlag(OpsCenterConstants.FALSE);
		// }

		currentUser.setFailureCount(0);
		updatePortalUserInDatabase(currentUser, origUser);
		logger.info("user password updated " + currentUser.getPassword());
		logger.info("updateUserPassword() - ending");
	}
	
	@Override
	public void deletePortalUser(int userId)
			throws UserNotUniqueException
	{
		
		logger.info("deletePortalUser() - starting for userId = " + userId);

		MasterPortalUser user = portalUserFacade.findUserByUserId(userId);
		if (user == null)
		{
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND, "UserId "
							+ userId + " Not Found");
		}

		try
		{
			PortalUserModel origUser =Portal2UserModel(user);

			user.setDateModified(new DateTime());
			user.setUserModified(user.getUsrname());
			user.setDeleteFlag(OpsCenterConstants.TRUE);
			user.setActiveFlag(OpsCenterConstants.FALSE);
			updatePortalUserInDatabase(user, origUser);
			logger.info("user updated successfuly to delete: " + user.getUsrname());
		}
		catch (Exception x)
		{
			logger.error("Internal exception while deleting user: " + x.getMessage(), x);
			throw new UserNotUniqueException(
					DefaultResources.USR_ERR_CODE_USER_NOT_FOUND,
					"Internal exception while deleting user: " + x);
		}
		logger.info("deletePortalUser() - ending");

	}
}
