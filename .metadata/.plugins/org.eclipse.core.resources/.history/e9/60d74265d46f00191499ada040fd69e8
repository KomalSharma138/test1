/**
 * 
 */
package com.consert.core.ejb.session;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import javax.annotation.Resource;
import javax.ejb.Asynchronous;
import javax.ejb.EJB;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;

import net.sf.ehcache.Cache;
import net.sf.ehcache.Element;
import net.sf.ehcache.search.Attribute;
import net.sf.ehcache.search.Query;
import net.sf.ehcache.search.Result;
import net.sf.ehcache.search.Results;

import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.LocalDate;
import org.joda.time.LocalTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.consert.core.ejb.cache.CEAccountMapCacheData;
import com.consert.core.ejb.cache.CEDevicesCacheData;
import com.consert.core.ejb.cache.CEGroupCacheData;
import com.consert.core.ejb.cache.CEGroupMapCacheData;
import com.consert.core.ejb.cache.CEGroupPowerCacheData;
import com.consert.core.ejb.cache.ControlEventCacheData;
import com.consert.core.ejb.cache.EsiCacheData;
import com.consert.core.ejb.cache.EsiDcCacheData;
import com.consert.core.ejb.cache.EsiDcFlagCacheData;
import com.consert.core.ejb.cache.GridStreamTstatCacheData;
import com.consert.core.ejb.constant.DefaultResources;
import com.consert.core.ejb.constant.OpsCenterConstants;
import com.consert.core.ejb.constant.OpsCenterConstants.OptOutReason;
import com.consert.core.ejb.constant.OpsCenterConstants.eventMode;
import com.consert.core.ejb.exception.AbstractOpsCenterException;
import com.consert.core.ejb.exception.ControlEventAllSpecifiedGroupsInControlEventException;
import com.consert.core.ejb.exception.ControlEventDeviceClassAlreadyInControl;
import com.consert.core.ejb.exception.ControlEventDurationNotAllowed;
import com.consert.core.ejb.exception.ControlEventGroupNotFoundException;
import com.consert.core.ejb.exception.ControlEventModeChangeNotAllowed;
import com.consert.core.ejb.exception.ControlEventNoPowerToRemoveProvidedException;
import com.consert.core.ejb.exception.ControlEventNotFoundException;
import com.consert.core.ejb.exception.ControlEventOptOutNotAllowed;
import com.consert.core.ejb.exception.ControlEventPercentPowerToRemoveExceeded;
import com.consert.core.ejb.exception.ControlEventStartNotAllowedNoDevClassSet;
import com.consert.core.ejb.exception.ControlEventStoppedException;
import com.consert.core.ejb.exception.DatabaseUpdateFailed;
import com.consert.core.ejb.exception.UserNotUniqueException;
import com.consert.core.ejb.multitenant.TenantContext;
import com.consert.core.ejb.multitenant.interfaces.MultiTenantEntityManagerWrapper;
import com.consert.core.ejb.session.facade.interfaces.ControlEventBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.DeviceBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.EsiBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.GenericFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.UserAccountBeanFacadeLocal;
import com.consert.core.ejb.session.interfaces.ControlEventPowerBeanRemote;
import com.consert.core.ejb.session.interfaces.DemandManagerBeanLocal;
import com.consert.core.ejb.session.interfaces.PublisherBeanRemote;
import com.consert.core.ejb.session.interfaces.local.AutoControlEventBeanLocal;
import com.consert.core.ejb.session.interfaces.local.CeDefinitionBeanLocal;
import com.consert.core.ejb.session.interfaces.local.CeGroupAccountBeanLocal;
import com.consert.core.ejb.session.interfaces.local.ControlEventPowerBeanLocal;
import com.consert.core.ejb.session.interfaces.local.GenericBeanLocal;
import com.consert.core.entities.Account;
import com.consert.core.entities.CeAccountMap;
import com.consert.core.entities.CeDefinition;
import com.consert.core.entities.CeDevices;
import com.consert.core.entities.CeDevicesLog;
import com.consert.core.entities.CeEsiLog;
import com.consert.core.entities.CeEsiStatus;
import com.consert.core.entities.CeGroup;
import com.consert.core.entities.CeGroupMap;
import com.consert.core.entities.CeLog;
import com.consert.core.entities.CeStatus;
import com.consert.core.entities.ControlEvent;
import com.consert.core.entities.DefinitionEventMap;
import com.consert.core.entities.DeviceType;
import com.consert.core.entities.Esi;
import com.consert.core.entities.EsiDc;
import com.consert.core.entities.User;
import com.consert.core.entities.UtilityProperty;
import com.consert.core.model.AccountID;
import com.consert.core.model.AutoControlEventModel;
import com.consert.core.model.CeAccountMapModel;
import com.consert.core.model.CeCycleStrategyModel;
import com.consert.core.model.CeDayGroupModel;
import com.consert.core.model.CeDefinitionModel;
import com.consert.core.model.CeDeviceTypeModel;
import com.consert.core.model.CeDevicesLogData;
import com.consert.core.model.CeDevicesLogModel;
import com.consert.core.model.CeEsiLogModel;
import com.consert.core.model.CeGroupID;
import com.consert.core.model.CeGroupMapModel;
import com.consert.core.model.CeLogModel;
import com.consert.core.model.ControlEventBroadCastWindow;
import com.consert.core.model.ControlEventDataFilterCriteriaModel;
import com.consert.core.model.ControlEventEditModel;
import com.consert.core.model.ControlEventModel;
import com.consert.core.model.ControlEventPowerModel;
import com.consert.core.model.ControlEventStartModel;
import com.consert.core.model.ControlEventSummaryCountModel;
import com.consert.core.model.ControlEventSummaryModel;
import com.consert.core.model.GroupPowerModel;
import com.consert.core.model.RemoveGroupFromCeResponse;
import com.consert.core.model.multiscada.dto.AutoScadaConfigDT;
import com.consert.core.model.multiscada.dto.CEStart;
import com.consert.core.multiscada.rest.MultiscadaAPI;
import com.consert.core.utils.PersistenceUtilities;

// import com.consert.core.ejb.session.messages.CacheManagerStub;

/**
 * @author brodriguez
 * 
 */
@Stateless(name = "ControlEventPowerBean")
public class ControlEventPowerBean implements ControlEventPowerBeanRemote, ControlEventPowerBeanLocal
{

	private static final int BATCH_SIZE_FLUSH = 20; // 20;
	private static final int BATCH_SIZE_ESI = 2500; // 5000;
	private static final long BUFFER_SP_STOP_TIME = 30;
	private static final long MANUAL_BUFFER_RAMPOUT = 5;
	private static final double MINUTE_CONVERSION = 60000.0D;

	private Logger logger = LoggerFactory.getLogger(getClass());

	@Resource
	private SessionContext sessionContext;

	@EJB
	private CacheManagerBean cacheManager;

	@EJB
	private ControlEventBeanFacadeLocal controlEventBeanFacade;

	@EJB
	private EsiBeanFacadeLocal esiBeanFacade;

	@EJB
	private UserAccountBeanFacadeLocal userAccBeanFacade;

	@EJB
	private ControlEventBean controlEventBean;

	@EJB
	private ControlEventPowerBeanLocal controlEventPowerBean;

	@EJB
	private PublisherBeanRemote publisher;

	@EJB
	private CeGroupAccountBeanLocal accountBean;

	@EJB
	private GenericBeanLocal genericBean;

	@EJB
	private ControlEventBroadcastBean controlEventBroadcastBean;

	@EJB
	private CeDefinitionBeanLocal ceDefinitionBean;

	@EJB
	private GenericFacadeLocal genericFacade;

	@EJB
	private AutoControlEventBeanLocal autoControlBean;

	@EJB
	private ControlEventNotificationBean ceNotificationBean;
	
	@EJB
	private DeviceBeanFacadeLocal deviceBeanFacade;
	
	@EJB
	private MultiscadaAPI multiScadaAPI;

	@EJB
	private MultiTenantEntityManagerWrapper entityManager;
	
	@EJB
	private DemandManagerBeanLocal demandManagerBeanLocal;

	private static Map<Integer, Map<Integer, Double>> powerAvailForCEsMap = new HashMap<>();
	private static Map<Integer, DateTime> lastTSPowerAvailForCEsCalculatedMap = new HashMap<Integer, DateTime>();
	private static Map<Integer, DateTime> lastTSPowerAvailCalculatedMap = new HashMap<Integer, DateTime>();
	
	private static Map<Integer, ControlEventPowerModel> totalPowerAvailMap = new HashMap<Integer, ControlEventPowerModel>();
	private static Map<Integer, Boolean> lastTSPowerAvailCalculatedForDefinedGroupsMap = new HashMap<Integer, Boolean>();

	public static final double EXTRA_POWER_FACTOR = 1.1;

	private static class GroupPowerGatewayData
	{
		private double grpPowerToRemove;
		private double grpPowerRemoved;
		private int numGws;
		private boolean gatheringNewlyAddedEsis;
		private List<EsiCacheData> newEsiCacheDataList;

		public GroupPowerGatewayData()
		{
		}

		/**
		 * @return the grpPowerRemoved
		 */
		public double getGrpPowerToRemove()
		{
			return grpPowerToRemove;
		}

		/**
		 * @param grpPowerRemoved
		 *            the grpPowerRemoved to set
		 */
		public void setGrpPowerToRemove(double grpPowerToRemove)
		{
			this.grpPowerToRemove = grpPowerToRemove;
		}

		/**
		 * @return the grpPowerRemoved
		 */
		public double getGrpPowerRemoved()
		{
			return grpPowerRemoved;
		}

		/**
		 * @param grpPowerRemoved
		 *            the grpPowerRemoved to set
		 */
		public void setGrpPowerRemoved(double grpPowerRemoved)
		{
			this.grpPowerRemoved = grpPowerRemoved;
		}

		/**
		 * @return the numGws
		 */
		public int getNumGws()
		{
			return numGws;
		}

		/**
		 * @param numGws
		 *            the numGws to set
		 */
		public void setNumGws(int numGws)
		{
			this.numGws = numGws;
		}

		/**
		 * @return the gatherNewlyAddedEsis
		 */
		public boolean isGatheringNewlyAddedEsis()
		{
			return gatheringNewlyAddedEsis;
		}

		/**
		 * @param gatherNewlyAddedEsis
		 *            the gatherNewlyAddedEsis to set
		 */
		public void setGatheringNewlyAddedEsis(boolean gatherNewlyAddedEsis)
		{
			gatheringNewlyAddedEsis = gatherNewlyAddedEsis;
		}

		/**
		 * @return the newEsiCacheDataList
		 */
		public List<EsiCacheData> getNewEsiCacheDataList()
		{
			return newEsiCacheDataList;
		}

		/**
		 * @param newEsiCacheDataList
		 *            the newEsiCacheDataList to set
		 */
		public void setNewEsiCacheDataList(List<EsiCacheData> newEsiCacheDataList)
		{
			this.newEsiCacheDataList = newEsiCacheDataList;
		}
	}

	private static class DeviceClassPowerData
	{
		private ArrayList<String> typeList;

		public DeviceClassPowerData()
		{
		}

		/**
		 * @return the devClassList
		 */
		public ArrayList<String> getDevClassList()
		{
			return typeList;
		}

		/**
		 * @param devClassList
		 *            the list of deviceTypeName
		 */
		public void setDevClassList(ArrayList<String> devClassList)
		{
			typeList = devClassList;
		}
	}

	private static class DeviceClassPowerSummaryData
	{
		public DeviceClassPowerSummaryData()
		{
		}

		public double powerAvailable = 0;
		public double powerConsumed = 0;
		public int deviceCount = 0;
	}

	private static class DcCacheData
	{
		private List<Integer> ceGrpPowerIdList;
		private double actEnergyAvail;
		private double actEnergyConsumed;
		private int esiId;
		private String devType;
		private long readingTime;
		private int deviceCount;

		public DcCacheData()
		{
		}

		/**
		 * @return the deviceCount
		 */
		public int getDeviceCount()
		{
			return deviceCount;
		}

		/**
		 * @param deviceCount
		 *            the deviceCount to set
		 */
		public void setDeviceCount(int deviceCount)
		{
			this.deviceCount = deviceCount;
		}

		/**
		 * @return the ceGrpPowerIdList
		 */
		public List<Integer> getCeGrpPowerIdList()
		{
			return ceGrpPowerIdList;
		}

		/**
		 * @param ceGrpPowerIdList
		 *            the ceGrpPowerIdList to set
		 */
		public void setCeGrpPowerIdList(List<Integer> ceGrpPowerIdList)
		{
			this.ceGrpPowerIdList = ceGrpPowerIdList;
		}

		/**
		 * @return the esiId
		 */
		public int getEsiId()
		{
			return esiId;
		}

		/**
		 * @param esiId
		 *            the esiId to set
		 */
		public void setEsiId(int esiId)
		{
			this.esiId = esiId;
		}

		/**
		 * @return the devType
		 */
		public String getDevType()
		{
			return devType;
		}

		/**
		 * @param devType
		 *            the devType to set
		 */
		public void setDevType(String devType)
		{
			this.devType = devType;
		}

		/**
		 * @return the readingTime
		 */
		public long getReadingTime()
		{
			return readingTime;
		}

		/**
		 * @param readingTime
		 *            the readingTime to set
		 */
		public void setReadingTime(long readingTime)
		{
			this.readingTime = readingTime;
		}

		/**
		 * @return the actEnergyAvail
		 */
		public double getActEnergyAvail()
		{
			return actEnergyAvail;
		}

		/**
		 * @param actEnergyAvail
		 *            the actEnergyAvail to set
		 */
		public void setActEnergyAvail(double actEnergyAvail)
		{
			this.actEnergyAvail = actEnergyAvail;
		}

		/**
		 * @return the actEnergyConsumed
		 */
		public double getActEnergyConsumed()
		{
			return actEnergyConsumed;
		}

		/**
		 * @param actEnergyConsumed
		 *            the actEnergyConsumed to set
		 */
		public void setActEnergyConsumed(double actEnergyConsumed)
		{
			this.actEnergyConsumed = actEnergyConsumed;
		}

	}

	private static class PowerAvailData
	{
		private double utilPowerAvail;
		private double utilHvacAvail;
		private double utilWhAvail;
		private double utilPpAvail;
		private double utilHvacSwitchAvail;
		private double utilSingleHeatAvailable;
		private double utilDualHeatAvailable;
		private double utilEvChargerAvail;
		private double utilIrrigationPumpAvailable;
		private double utilCropHeatAvailable;
		private double utilGeneratorAvailable;

		private int utilHvacCount;
		private int utilWhCount;
		private int utilPpCount;
		private int utilHvacSwitchCount;
		private int utilSingleHeatCount;
		private int utilDualHeatCount;
		private int utilEvChargerCount;
		private int utilIrrigationCount;
		private int utilCropHeatCount;
		private int utilGeneratorCount;

		public PowerAvailData()
		{
		}

		/**
		 * @return the utilHvacAvail
		 */
		public double getUtilHvacAvail()
		{
			return utilHvacAvail;
		}

		/**
		 * @param utilHvacAvail
		 *            the utilHvacAvail to set
		 */
		public void setUtilHvacAvail(double utilHvacAvail)
		{
			this.utilHvacAvail = utilHvacAvail;
		}

		/**
		 * @return the utilWhAvail
		 */
		public double getUtilWhAvail()
		{
			return utilWhAvail;
		}

		/**
		 * @param utilWhAvail
		 *            the utilWhAvail to set
		 */
		public void setUtilWhAvail(double utilWhAvail)
		{
			this.utilWhAvail = utilWhAvail;
		}

		/**
		 * @return the utilPpAvail
		 */
		public double getUtilPpAvail()
		{
			return utilPpAvail;
		}

		/**
		 * @param utilPpAvail
		 *            the utilPpAvail to set
		 */
		public void setUtilPpAvail(double utilPpAvail)
		{
			this.utilPpAvail = utilPpAvail;
		}

		/**
		 * @return the utilHvacSwitchAvail
		 */
		public double getUtilHvacSwitchAvail()
		{
			return utilHvacSwitchAvail;
		}

		/**
		 * @param utilHvacSwitchAvail
		 *            the utilHvacSwitchAvail to set
		 */
		public void setUtilHvacSwitchAvail(double utilHvacSwitchAvail)
		{
			this.utilHvacSwitchAvail = utilHvacSwitchAvail;
		}

		public void setUtilIrrigationPumpAvailable(double utilIrrigationPumpAvailable)
		{
			this.utilIrrigationPumpAvailable = utilIrrigationPumpAvailable;
		}

		public double getUtilIrrigationPumpAvailable()
		{
			return utilIrrigationPumpAvailable;
		}

		/**
		 * @return the utilHvacCount
		 */
		public int getUtilHvacCount()
		{
			return utilHvacCount;
		}

		/**
		 * @param utilHvacCount
		 *            the utilHvacCount to set
		 */
		public void setUtilHvacCount(int utilHvacCount)
		{
			this.utilHvacCount = utilHvacCount;
		}

		/**
		 * @return the utilWhCount
		 */
		public int getUtilWhCount()
		{
			return utilWhCount;
		}

		/**
		 * @param utilWhCount
		 *            the utilWhCount to set
		 */
		public void setUtilWhCount(int utilWhCount)
		{
			this.utilWhCount = utilWhCount;
		}

		/**
		 * @return the utilPpCount
		 */
		public int getUtilPpCount()
		{
			return utilPpCount;
		}

		/**
		 * @param utilPpCount
		 *            the utilPpCount to set
		 */
		public void setUtilPpCount(int utilPpCount)
		{
			this.utilPpCount = utilPpCount;
		}

		/**
		 * @return the utilHvacSwitchCount
		 */
		public int getUtilHvacSwitchCount()
		{
			return utilHvacSwitchCount;
		}

		/**
		 * @param utilHvacSwitchCount
		 *            the utilHvacSwitchCount to set
		 */
		public void setUtilHvacSwitchCount(int utilHvacSwitchCount)
		{
			this.utilHvacSwitchCount = utilHvacSwitchCount;
		}

		/**
		 * @return the utilEvChargerCount
		 */
		public int getUtilEvChargerCount()
		{
			return utilEvChargerCount;
		}

		/**
		 * @param utilEvChargerCount
		 *            the utilEvChargerCount to set
		 */
		public void setUtilEvChargerCount(int utilEvChargerCount)
		{
			this.utilEvChargerCount = utilEvChargerCount;
		}

		public int getUtilIrrigationCount()
		{
			return utilIrrigationCount;
		}

		public void setUtilIrrigationCount(int utilIrrigationCount)
		{
			this.utilIrrigationCount = utilIrrigationCount;
		}

		/**
		 * @return the utilEvChargerAvail
		 */
		public double getUtilEvChargerAvail()
		{
			return utilEvChargerAvail;
		}

		/**
		 * @param utilEvChargerAvail
		 *            the utilEvChargerAvail to set
		 */
		public void setUtilEvChargerAvail(double utilEvChargerAvail)
		{
			this.utilEvChargerAvail = utilEvChargerAvail;
		}

		/**
		 * @return the utilPowerAvail
		 */
		public double getUtilPowerAvail()
		{
			return utilPowerAvail;
		}

		/**
		 * @param utilPowerAvail
		 *            the utilPowerAvail to set
		 */
		public void setUtilPowerAvail(double utilPowerAvail)
		{
			this.utilPowerAvail = utilPowerAvail;
		}
		
		public double getUtilSingleHeatAvailable() {
			return utilSingleHeatAvailable;
		}

		public void setUtilSingleHeatAvailable(double utilSingleHeatAvailable) {
			this.utilSingleHeatAvailable = utilSingleHeatAvailable;
		}

		public double getUtilDualHeatAvailable() {
			return utilDualHeatAvailable;
		}

		public void setUtilDualHeatAvailable(double utilDualHeatAvailable) {
			this.utilDualHeatAvailable = utilDualHeatAvailable;
		}

		public double getUtilCropHeatAvailable() {
			return utilCropHeatAvailable;
		}

		public void setUtilCropHeatAvailable(double utilCropHeatAvailable) {
			this.utilCropHeatAvailable = utilCropHeatAvailable;
		}

		public double getUtilGeneratorAvailable() {
			return utilGeneratorAvailable;
		}

		public void setUtilGeneratorAvailable(double utilGeneratorAvailable) {
			this.utilGeneratorAvailable = utilGeneratorAvailable;
		}

		public int getUtilSingleHeatCount() {
			return utilSingleHeatCount;
		}

		public void setUtilSingleHeatCount(int utilSingleHeatCount) {
			this.utilSingleHeatCount = utilSingleHeatCount;
		}

		public int getUtilDualHeatCount() {
			return utilDualHeatCount;
		}

		public void setUtilDualHeatCount(int utilDualHeatCount) {
			this.utilDualHeatCount = utilDualHeatCount;
		}

		public int getUtilCropHeatCount() {
			return utilCropHeatCount;
		}

		public void setUtilCropHeatCount(int utilCropHeatCount) {
			this.utilCropHeatCount = utilCropHeatCount;
		}

		public int getUtilGeneratorCount() {
			return utilGeneratorCount;
		}

		public void setUtilGeneratorCount(int utilGeneratorCount) {
			this.utilGeneratorCount = utilGeneratorCount;
		}

		@Override
		public String toString()
		{
			StringBuilder builder = new StringBuilder();
			builder.append("[PowerAvailData] [utilPowerAvail = ");
			builder.append(utilPowerAvail);
			builder.append("\n\tutilHvacAvail = ");
			builder.append(utilHvacAvail);
			builder.append("\n\tutilWhAvail = ");
			builder.append(utilWhAvail);
			builder.append("\n\tutilPpAvail = ");
			builder.append(utilPpAvail);
			builder.append("\n\tutilHvacSwitchAvail = ");
			builder.append(utilHvacSwitchAvail);
			builder.append("\n\tutilEvChargerAvail = ");
			builder.append(utilEvChargerAvail);
			builder.append("\n\tutilIrrigationPumpAvailable = ");
			builder.append(utilIrrigationPumpAvailable);
			builder.append("\n\tutilCropHeatAvailable = ");
			builder.append(utilCropHeatAvailable);
			builder.append("\n\tutilGeneratorAvailable = ");
			builder.append(utilGeneratorAvailable);
			builder.append("\n\tutilSingleHeatAvailable = ");
			builder.append(utilSingleHeatAvailable);
			builder.append("\n\tutilDualHeatAvailable = ");
			builder.append(utilDualHeatAvailable);
			builder.append("\n\tutilHvacCount = ");
			builder.append(utilHvacCount);
			builder.append("\n\tutilWhCount = ");
			builder.append(utilWhCount);
			builder.append("\n\tutilPpCount = ");
			builder.append(utilPpCount);
			builder.append("\n\tutilHvacSwitchCount = ");
			builder.append(utilHvacSwitchCount);
			builder.append("\n\tutilEvChargerCount = ");
			builder.append(utilEvChargerCount);
			builder.append("\n\tutilIrrigationCount = ");
			builder.append(utilIrrigationCount);
			builder.append("\n\tutilCropHeatCount = ");
			builder.append(utilCropHeatCount);
			builder.append("\n\tutilGeneratorCount = ");
			builder.append(utilGeneratorCount);
			builder.append("\n\tutilSingleHeatCount = ");
			builder.append(utilSingleHeatCount);
			builder.append("\n\tutilDualHeatCount = ");
			builder.append(utilDualHeatCount);
			builder.append("]");
			return builder.toString();
		}
	}

	private static class AccumulateDcPower
	{
		private double targetPowerAtDc;
		private double totalDcPowerConsumed;
		private double remainPowerToRemove;
		private int accountId;
		private EsiCacheData esiCache;

		public AccumulateDcPower()
		{
		}

		/**
		 * @return the targetPowerAtDc
		 */
		public double getTargetPowerAtDc()
		{
			return targetPowerAtDc;
		}

		/**
		 * @param targetPowerAtDc
		 *            the targetPowerAtDc to set
		 */
		public void setTargetPowerAtDc(double targetPowerAtDc)
		{
			this.targetPowerAtDc = targetPowerAtDc;
		}

		/**
		 * @return the totalDcPowerConsumed
		 */
		public double getTotalDcPowerConsumed()
		{
			return totalDcPowerConsumed;
		}

		/**
		 * @param totalDcPowerConsumed
		 *            the totalDcPowerConsumed to set
		 */
		public void setTotalDcPowerConsumed(double totalDcPowerConsumed)
		{
			this.totalDcPowerConsumed = totalDcPowerConsumed;
		}

		/**
		 * @return the remainPowerToRemove
		 */
		public double getRemainPowerToRemove()
		{
			return remainPowerToRemove;
		}

		/**
		 * @param remainPowerToRemove
		 *            the remainPowerToRemove to set
		 */
		public void setRemainPowerToRemove(double remainPowerToRemove)
		{
			this.remainPowerToRemove = remainPowerToRemove;
		}

		/**
		 * @return the accountId
		 */
		public int getAccountId()
		{
			return accountId;
		}

		/**
		 * @param accountId
		 *            the accountId to set
		 */
		public void setAccountId(int accountId)
		{
			this.accountId = accountId;
		}

		/**
		 * @return the esiCache
		 */
		public EsiCacheData getEsiCache()
		{
			return esiCache;
		}

		/**
		 * @param esiCache
		 *            the esiCache to set
		 */
		public void setEsiCache(EsiCacheData esiCache)
		{
			this.esiCache = esiCache;
		}

	}

	private static class OptOutIds
	{

		private Set<Integer> stoppedCeAccMapIds = new HashSet<Integer>();

		private CeEsiStatus stoppingCeEsiStatusId;
		private CeEsiStatus stoppedCeEsiStatusId;
		private CeEsiStatus optingOutCeEsiStatusId;
		private List<Integer> ceAccountOptOuts = new ArrayList<Integer>();

		public OptOutIds()
		{
		}

		/**
		 * @return the stoppingCeEsiStatusId
		 */
		public CeEsiStatus getStoppingCeEsiStatusId()
		{
			return stoppingCeEsiStatusId;
		}

		/**
		 * @param stoppingCeEsiStatusId
		 *            the stoppingCeEsiStatusId to set
		 */
		public void setStoppingCeEsiStatusId(CeEsiStatus stoppingCeEsiStatusId)
		{
			this.stoppingCeEsiStatusId = stoppingCeEsiStatusId;
		}

		/**
		 * @return the stoppedCeEsiStatusId
		 */
		@SuppressWarnings("unused")
		public CeEsiStatus getStoppedCeEsiStatusId()
		{
			return stoppedCeEsiStatusId;
		}

		/**
		 * @param stoppedCeEsiStatusId
		 *            the stoppedCeEsiStatusId to set
		 */
		public void setStoppedCeEsiStatusId(CeEsiStatus stoppedCeEsiStatusId)
		{
			this.stoppedCeEsiStatusId = stoppedCeEsiStatusId;
		}

		/**
		 * @return the optingOutCeEsiStatusId
		 */
		public CeEsiStatus getOptingOutCeEsiStatusId()
		{
			return optingOutCeEsiStatusId;
		}

		/**
		 * @param optingOutCeEsiStatusId
		 *            the optingOutCeEsiStatusId to set
		 */
		public void setOptingOutCeEsiStatusId(CeEsiStatus optingOutCeEsiStatusId)
		{
			this.optingOutCeEsiStatusId = optingOutCeEsiStatusId;
		}

		/**
		 * @return the stoppedCeAccMapIds
		 */
		public Set<Integer> getStoppedCeAccMapIds()
		{
			return stoppedCeAccMapIds;
		}

		/**
		 * @param stoppedCeAccMapIds
		 *            the stoppedCeAccMapIds to set
		 */
		public void setStoppedCeAccMapIds(Set<Integer> stoppedCeAccMapIds)
		{
			this.stoppedCeAccMapIds = stoppedCeAccMapIds;
		}

		/**
		 * @return the ceAccountOptOuts
		 */
		public List<Integer> getCeAccountOptOuts()
		{
			return ceAccountOptOuts;
		}

		/**
		 * @param ceAccountOptOuts
		 *            the ceAccountOptOuts to set
		 */
		public void setCeAccountOptOuts(List<Integer> ceAccountOptOuts)
		{
			this.ceAccountOptOuts = ceAccountOptOuts;
		}

	}

	private static class GroupPowerDeviceData
	{
		private double powerAvail;
		private int ceDef;

		public double getPowerAvail()
		{
			return powerAvail;
		}

		public void setPowerAvail(double powerAvail)
		{
			this.powerAvail = powerAvail;
		}

		public int getCeDef()
		{
			return ceDef;
		}

		public void setCeDef(int ceDef)
		{
			this.ceDef = ceDef;
		}

	}

	public ControlEventPowerBean()
	{
		// Here to satisfy java constructor requirements
	}

	/**
	 * @param cacheManagerStub
	 *            protected ControlEventPowerBean(CacheManagerBeanLocal
	 *            cacheManagerStub) { cacheManager = cacheManagerStub; }
	 */

	@Override
	public void testStartPowerEvent()
	{

		ControlEventPowerModel model = new ControlEventPowerModel();
		model.setNumberOfGateways(0);
		model.setPowerAvailable(0.0);
		model.setPowerRemoved(0.0);
		model.setUserName("billr");
		model.setPowerRequestedInPercent(OpsCenterConstants.FALSE);
		logger.info("Entering  testStartPowerEvent ");
		LinkedHashMap<String, String> ceTypeMap = new LinkedHashMap<String, String>();
		ceTypeMap.put("HVAC", "1");
		ceTypeMap.put("WH", "1");
		ceTypeMap.put("PP", "1");
		ceTypeMap.put("HVAC_SWITCH", "1");

		double totalPwr = 0.0;
		model = getPowerAvail(OpsCenterConstants.eventMode.CYCLING, TenantContext.getCurrentTenant());
		model.setPowerRequestedInPercent(OpsCenterConstants.FALSE);
		if (model.getGroupPowerList().isEmpty())
		{
			System.out.println("No Groups returned from DB, no Pwr Avail ");
			return;
		}
		System.out.println("Got Model object back, PC" + model.getPowerRemoved());
		System.out.println("Got Model # of grps" + model.getGroupPowerList().size());
		System.out.println("Got Model object back # of GWs " + model.getNumberOfGateways());

		List<GroupPowerModel> grpList = model.getGroupPowerList();
		for (Iterator<GroupPowerModel> iterator = grpList.iterator(); iterator.hasNext();)
		{
			GroupPowerModel grp = iterator.next();

			if (grp.getGrpId() != 1)
			{
				iterator.remove();
			}
			else
			{
				// grp.setPowerToRemove(grp.getProjPowerConsumed());
				grp.setPowerToRemove(10.0);
				System.out.println("pwer to remove for grp = " + grp.getPowerToRemove() + " " + grp.getGrpId());
				totalPwr = totalPwr + grp.getPowerToRemove();
			}
		}

		if (grpList.isEmpty())
		{
			System.out.println("All grps already in CE, exiting");
			return;
		}
		DateTime now = new DateTime();

		// ControlEventPowerModel startObject = new ControlEventPowerModel();
		ControlEventStartModel ceStart = new ControlEventStartModel();
		ceStart.setUserId(2);
		ceStart.setCriticalCE("0");
		ceStart.setDuration(30);
		ceStart.setGroupPowerList(grpList);
		ceStart.setTotalPowerToRemove(totalPwr);
		ceStart.setStartDate(now);
		ceStart.setTargetDeviceTypeIDs(ceTypeMap);
		ceStart.setPowerRequestedInPercent(model.getPowerRequestedInPercent());

		ControlEventModel controlEventModel;
		try
		{
			controlEventModel = startControlEvent(ceStart, TenantContext.getCurrentTenant());

			System.out.println("Started event, Status = " + controlEventModel.getCeStatus());
			System.out.println("Started event, Power To Remove = " + controlEventModel.getPowerToRemove());
			System.out.println("Started event, Power Removed = " + controlEventModel.getPowerRemoved());
			System.out.println("Started event, CE Id = " + controlEventModel.getCeId());
		} catch (AbstractOpsCenterException e)
		{
			e.printStackTrace();
		}
	}

	@Override
	public void testGetPowerAvail()
	{
		ControlEventPowerModel model = new ControlEventPowerModel();

		model = getPowerAvail(OpsCenterConstants.eventMode.CYCLING, TenantContext.getCurrentTenant());
		if (model != null)
		{
			System.out.println("testGetPowerAvail, power avail = " + model.getPowerAvailable());
			System.out.println("testGetPowerAvail, power removed= " + model.getPowerRemoved());
			System.out.println("testGetPowerAvail, # of GWs= " + model.getNumberOfGateways());
		}
		else
		{
			System.out.println("testGetPowerAvail, no readings rec yet, hence no power avail ");
		}

	}

	@Override
	public void testEditPowerEvent(int ceId, int groupId, double powerToRemove) throws AbstractOpsCenterException
	{

		LinkedHashMap<String, String> devClass = new LinkedHashMap<String, String>();
		devClass.put("HVAC", OpsCenterConstants.TRUE);
		ControlEventEditModel ceEditModel = new ControlEventEditModel();
		ceEditModel.setCeId(ceId);
		ceEditModel.setAdditionalPowerToRemoveTotal(powerToRemove);
		ceEditModel.setUserId(1);
		ceEditModel.setTargetDeviceTypeIDs(devClass);
		ceEditModel.setPowerRequestedInPercent(OpsCenterConstants.TRUE);
		List<GroupPowerModel> groupPowerList = new ArrayList<GroupPowerModel>();
		GroupPowerModel groupPowerModel = new GroupPowerModel();
		groupPowerModel.setGrpId(groupId);
		groupPowerModel.setCeId(ceId);
		groupPowerModel.setPowerToRemove(powerToRemove);
		groupPowerList.add(groupPowerModel);

		ceEditModel.setGroupPowerList(groupPowerList);

		editControlEvent(ceEditModel, TenantContext.getCurrentTenant());
	}

	@Override
	public void testManaulStopCE(int ceId)
	{
		try
		{
			stopControlEvent(Arrays.asList(ceId), TenantContext.getCurrentTenant());
		} catch (AbstractOpsCenterException e)
		{
			e.printStackTrace();
		}
	}

	@Override
	public void testStopCE()
	{

		List<Integer> ceList = new ArrayList<Integer>();

		ControlEventPowerModel model = new ControlEventPowerModel();
		model.setNumberOfGateways(0);
		model.setPowerAvailable(0.0);
		model.setPowerRemoved(0.0);
		model.setUserName("billr");
		logger.info("Entering  testStopPowerEvent ");

		model = getPowerAvail(OpsCenterConstants.eventMode.VPP, TenantContext.getCurrentTenant());
		System.out.println("Got Model object back, PA " + model.getPowerAvailable());
		System.out.println("Got Model # of grps" + model.getGroupPowerList().size());
		System.out.println("Got Model object back # of GWs " + model.getNumberOfGateways());
		List<GroupPowerModel> grpList = model.getGroupPowerList();

		for (GroupPowerModel grp : grpList)
		{
			if (grp.getCeId() != 0)
			{
				ceList.add(grp.getCeId());
				System.out.println("CE is running , stopping CE now " + grp.getCeId());

				try
				{
					stopControlEvent(ceList, TenantContext.getCurrentTenant());
				} catch (AbstractOpsCenterException e)
				{
					e.printStackTrace();
				}
				break;
			}
		}

	}

	@Override
	public void testAddAccount(int accid, int grpId)
	{

		AccountID accId = new AccountID();
		accId.setAccountId(accid);
		Account account = userAccBeanFacade.findAccountByAccountId(accid);
		accId.setAccountNumber(account.getAccountNumber());
		CeGroupID grp = new CeGroupID();
		grp.setCeGrpId(grpId);
		try
		{
			accountBean.addAccountToCeGroup(accId, grp, TenantContext.getCurrentTenant());

		} catch (AbstractOpsCenterException e)
		{
			e.printStackTrace();
		}

	}

	/**
	 * @see com.consert.core.ejb.session.interfaces.ControlEventPowerBean#getPowerAvail()
	 */

	@Override
	public ControlEventPowerModel getPowerAvail(Integer tenantId)
	{
		// trick : pass cycling as event mode to force PA logic to grab all
		// devices
		TenantContext.setCurrentTenant(tenantId);
		ControlEventPowerModel ceModel = getPowerAvail(null, null, OpsCenterConstants.eventMode.CYCLING);
		return ceModel;
	}

	@Override
	public ControlEventPowerModel getPowerAvail(OpsCenterConstants.eventMode eventMode, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		ControlEventPowerModel ceModel = getPowerAvail(null, null, eventMode);
		return ceModel;
	}

	/**
	 * @param cacheData
	 * @param ceGroupIdByEsiIdInControl
	 * @param ceGrpPowerIdToCeGrp
	 * @param consumingEsiIds
	 * @param eventMode
	 * @param powerByCeGroupId
	 * @param consumingEsiByGrp
	 * @param uniqueEsiIds
	 * @param powerAvail
	 * 
	 * @return
	 */
	private PowerAvailData determineDcPower(DcCacheData cacheData, Map<Integer, Integer> ceGroupIdByEsiIdInControl, Map<Integer, Integer> ceGrpPowerIdToCeGrp,
			Set<Integer> consumingEsiIds, OpsCenterConstants.eventMode eventMode, Map<Integer, Map<String, DeviceClassPowerSummaryData>> powerByCeGroupId,
			HashMap<Integer, Integer> consumingEsiByGrp, Set<Integer> uniqueEsiIds, PowerAvailData powerAvail)
	{
		int utilHvacCount = 0;
		int utilWhCount = 0;
		int utilPpCount = 0;
		int utilHvacSwitchCount = 0;
		int utilSingleHeatCount = 0;
		int utilDualHeatCount = 0;
		int utilEvChargerCount = 0;
		int utilIrrigationPumpCount = 0;
		int utilCropHeatCount = 0;
		int utilGeneratorCount = 0;

		DateTime currTime = new DateTime();
		int staleTimeMin = cacheManager.getStaleTimeMin();
		long staleTimeInMillis = currTime.minusMinutes(staleTimeMin).getMillis();

		// only accumulate power if the esi has been assigned to a grp
		// List<CeGroupAccountMap>ceGrpAccMapList =
		// controlEventBeanFacade.getCeGroupAccountMapByAccountId(eCache.getAccountId());
		List<Integer> ceGrpPowerIdList = cacheData.getCeGrpPowerIdList();
		// only accumulate reads which are inside of last 15 minutes
		if (cacheData.getReadingTime() >= staleTimeInMillis && !ceGrpPowerIdList.isEmpty())
		{
			String deviceType = cacheData.getDevType();
			double energyAvail = cacheData.getActEnergyAvail();

			// This dc belongs to an esi in this group that is under control
			Integer myCeGroupId = ceGroupIdByEsiIdInControl.get(cacheData.getEsiId());
			boolean addToTotal = false;
			for (Integer ceGrpPowerId : ceGrpPowerIdList)
			{
				Integer ceGroupId = ceGrpPowerIdToCeGrp.get(ceGrpPowerId);

				// this means that this is a group that we are filtering out
				if (ceGroupId == null)
				{
					continue;
				}

				addToTotal = true;

				Map<String, DeviceClassPowerSummaryData> powerByDevice = powerByCeGroupId.get(ceGroupId);
				if (powerByDevice == null)
				{
					powerByDevice = new HashMap<String, DeviceClassPowerSummaryData>();
					powerByCeGroupId.put(ceGroupId, powerByDevice);
				}

				DeviceClassPowerSummaryData power = powerByDevice.get(deviceType);
				if (power == null)
				{
					power = new DeviceClassPowerSummaryData();
					powerByDevice.put(cacheData.getDevType(), power);
				}

				power.powerAvailable += energyAvail;
				power.powerConsumed += cacheData.getActEnergyConsumed();
				power.deviceCount += cacheData.getDeviceCount();

				if (cacheData.getActEnergyConsumed() > 0.0)
				{
					consumingEsiIds.add(cacheData.getEsiId());
				}
				consumingEsiByGrp.put(ceGroupId, consumingEsiIds.size());
			}
			if (addToTotal)
			{
				powerAvail.setUtilPowerAvail(powerAvail.getUtilPowerAvail() + energyAvail);
				if (OpsCenterConstants.DC_HVAC.equals(deviceType))
				{
					powerAvail.setUtilHvacAvail(powerAvail.getUtilHvacAvail() + energyAvail);
					powerAvail.setUtilHvacCount(powerAvail.getUtilHvacCount() + utilHvacCount);
				}
				else if (OpsCenterConstants.DC_WATER_HEATER.equals(deviceType))
				{
					powerAvail.setUtilWhAvail(powerAvail.getUtilWhAvail() + energyAvail);
					powerAvail.setUtilWhCount(powerAvail.getUtilWhCount() + utilWhCount);
				}
				else if (OpsCenterConstants.DC_POOL_PUMP.equals(deviceType))
				{
					powerAvail.setUtilPpAvail(powerAvail.getUtilPpAvail() + energyAvail);
					powerAvail.setUtilPpCount(powerAvail.getUtilPpCount() + utilPpCount);
				}
				else if (OpsCenterConstants.DC_EV_CHARGER.equals(deviceType))
				{
					powerAvail.setUtilEvChargerAvail(powerAvail.getUtilEvChargerAvail() + energyAvail);
					powerAvail.setUtilEvChargerCount(powerAvail.getUtilEvChargerCount() + utilEvChargerCount);
				}
				else if (OpsCenterConstants.DC_IRRIGATION_PUMP.equals(deviceType))
				{
					powerAvail.setUtilIrrigationPumpAvailable(powerAvail.getUtilIrrigationPumpAvailable() + energyAvail);
					powerAvail.setUtilIrrigationCount(powerAvail.getUtilIrrigationCount() + utilIrrigationPumpCount);
				}
				else if (OpsCenterConstants.DC_HVAC_SWITCH.equals(deviceType))
				{
					powerAvail.setUtilHvacSwitchAvail(powerAvail.getUtilHvacSwitchAvail() + energyAvail);
					powerAvail.setUtilHvacSwitchCount(powerAvail.getUtilHvacSwitchCount() + utilHvacSwitchCount);
				}
				else if (OpsCenterConstants.DC_CROP_HEAT.equals(deviceType))
				{
					powerAvail.setUtilCropHeatAvailable(powerAvail.getUtilCropHeatAvailable() + energyAvail);
					powerAvail.setUtilCropHeatCount(powerAvail.getUtilCropHeatCount() + utilCropHeatCount);
				}
				else if (OpsCenterConstants.DC_GENERATOR.equals(deviceType))
				{
					powerAvail.setUtilGeneratorAvailable(powerAvail.getUtilGeneratorAvailable() + energyAvail);
					powerAvail.setUtilGeneratorCount(powerAvail.getUtilGeneratorCount() + utilGeneratorCount);
				}
				else if (OpsCenterConstants.DC_SINGLE_HEAT.equals(deviceType))
				{
					powerAvail.setUtilSingleHeatAvailable(powerAvail.getUtilSingleHeatAvailable() + energyAvail);
					powerAvail.setUtilSingleHeatCount(powerAvail.getUtilSingleHeatCount() + utilSingleHeatCount);
				}
				else if (OpsCenterConstants.DC_DUAL_HEAT.equals(deviceType))
				{
					powerAvail.setUtilDualHeatAvailable(powerAvail.getUtilDualHeatAvailable() + energyAvail);
					powerAvail.setUtilDualHeatCount(powerAvail.getUtilDualHeatCount() + utilDualHeatCount);
				}

				uniqueEsiIds.add(cacheData.getEsiId());
			}
		}

		return powerAvail;
	}

	@Override
	public ControlEventPowerModel getPowerAvail(Set<Integer> ceGroupIdSet, OpsCenterConstants.eventMode eventMode)
	{
		Integer tenantId = TenantContext.getCurrentTenant();
		logger.info("[ENTER] ControlEventPowerModel ControlEventPowerBean.getPowerAvail(ceGroupIdSet = " + ceGroupIdSet + ", eventMode = " + eventMode + ")");
		
		boolean lastTSPowerAvailCalculatedForDefinedGroups = false;
		if(lastTSPowerAvailCalculatedForDefinedGroupsMap.get(tenantId) == null) {
			lastTSPowerAvailCalculatedForDefinedGroupsMap.put(tenantId, lastTSPowerAvailCalculatedForDefinedGroups);
		} else {
			lastTSPowerAvailCalculatedForDefinedGroups = lastTSPowerAvailCalculatedForDefinedGroupsMap.get(tenantId);
		}
		logger.info("lastTSPowerAvailCalculatedForDefinedGroups = "+lastTSPowerAvailCalculatedForDefinedGroups);
		
		DateTime lastTSPowerAvailCalculated = new DateTime();
		if(lastTSPowerAvailCalculatedMap.get(tenantId) == null) {
			lastTSPowerAvailCalculatedMap.put(tenantId, lastTSPowerAvailCalculated);
		} else {
			lastTSPowerAvailCalculated = lastTSPowerAvailCalculatedMap.get(tenantId);
		}
		
		DateTime currentTS = new DateTime();
		if (null == totalPowerAvailMap.get(tenantId) || lastTSPowerAvailCalculated.getMillis() + 120000 < currentTS.getMillis() || lastTSPowerAvailCalculatedForDefinedGroups)
		{			
			if(lastTSPowerAvailCalculatedForDefinedGroups && ceGroupIdSet == null) {
				lastTSPowerAvailCalculatedForDefinedGroups = false;
			}
			
			ControlEventPowerModel ceModel = calculatePowerAvail(null, ceGroupIdSet, eventMode);
			
			if(ceGroupIdSet != null) {
				logger.info("Setting lastTSPowerAvailCalculatedForDefinedGroups = true for the next call");
				lastTSPowerAvailCalculatedForDefinedGroups = true;
			}

			lastTSPowerAvailCalculatedForDefinedGroupsMap.put(tenantId, lastTSPowerAvailCalculatedForDefinedGroups);
			logger.info("[ EXIT] ControlEventPowerBean.getPowerAvail");
			return ceModel;
		}
		
		logger.info("[ EXIT] ControlEventPowerBean.getPowerAvail");

		return totalPowerAvailMap.get(tenantId);
	}

	private ControlEventPowerModel getPowerAvail(Integer controlEventId, Set<Integer> ceGroupIdSet, OpsCenterConstants.eventMode eventMode)
	{
		Integer tenantId = TenantContext.getCurrentTenant();
		logger.info("[ENTER] ControlEventPowerModel ControlEventPowerBean.getPowerAvail(controlEventId = " + controlEventId + ", ceGroupIdSet = "
				+ ceGroupIdSet + ", eventMode = " + eventMode + ")");
		
		boolean lastTSPowerAvailCalculatedForDefinedGroups = false;
		if(lastTSPowerAvailCalculatedForDefinedGroupsMap.get(tenantId) == null) {
			lastTSPowerAvailCalculatedForDefinedGroupsMap.put(tenantId, lastTSPowerAvailCalculatedForDefinedGroups);
		} else {
			lastTSPowerAvailCalculatedForDefinedGroups = lastTSPowerAvailCalculatedForDefinedGroupsMap.get(tenantId);
		}
		logger.info("lastTSPowerAvailCalculatedForDefinedGroups = "+lastTSPowerAvailCalculatedForDefinedGroups);

		DateTime lastTSPowerAvailCalculated = new DateTime();
		if(lastTSPowerAvailCalculatedMap.get(tenantId) == null) {
			lastTSPowerAvailCalculatedMap.put(tenantId, lastTSPowerAvailCalculated);
		} else {
			lastTSPowerAvailCalculated = lastTSPowerAvailCalculatedMap.get(tenantId);
		}

		
		DateTime currentTS = new DateTime();
		if ((controlEventId != null && controlEventId != 0) || totalPowerAvailMap.get(tenantId) == null
				|| lastTSPowerAvailCalculated.getMillis() + 120000 < currentTS.getMillis() || lastTSPowerAvailCalculatedForDefinedGroups)
		{
			if(lastTSPowerAvailCalculatedForDefinedGroups && ceGroupIdSet == null) {
				lastTSPowerAvailCalculatedForDefinedGroups = false;
			}
			
			ControlEventPowerModel ceModel = calculatePowerAvail(controlEventId, ceGroupIdSet, eventMode);
			
			if(ceGroupIdSet != null) {
				logger.info("Setting lastTSPowerAvailCalculatedForDefinedGroups = true for the next call");
				lastTSPowerAvailCalculatedForDefinedGroups = true;
			}
			
			lastTSPowerAvailCalculatedForDefinedGroupsMap.put(tenantId, lastTSPowerAvailCalculatedForDefinedGroups);
			logger.info("[ EXIT] ControlEventPowerBean.getPowerAvail");
			return ceModel;
		}

		logger.info("[ EXIT] ControlEventPowerBean.getPowerAvail");

		return totalPowerAvailMap.get(tenantId);
	}

	/**
	 * @param grpPwr
	 * @param dutyCycleByDeviceTypeMap
	 */
	private void setDutyCycleByDeviceTypeForGroupPowerModel(GroupPowerModel grpPwr, Map<Integer, Integer> dutyCycleByDeviceTypeMap)
	{
		LinkedHashMap<String, Integer> dutyCycleByDeviceType = new LinkedHashMap<String, Integer>();

		// initialize the values to zero for each device type
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.HVAC.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.WATER_HEATER.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.POOL_PUMP.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.ELECTRIC_VEHICLE.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.IRRIGATION_PUMP.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.AC_SWITCH.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.CROP_HEAT.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.GENERATOR.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.SINGLE_HEAT.getCeValue(), 0);
		dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.DUAL_HEAT.getCeValue(), 0);

		if (dutyCycleByDeviceTypeMap != null && !dutyCycleByDeviceTypeMap.isEmpty())
		{
			for (Integer deviceTypeId : dutyCycleByDeviceTypeMap.keySet())
			{
				for (OpsCenterConstants.DeviceType dType : OpsCenterConstants.DeviceType.values())
				{
					if (deviceTypeId == dType.getId())
					{
						// 0 and 19 both refer to TSTAT (HVAC) in this context
						if (deviceTypeId == OpsCenterConstants.DeviceType.THERMOSTAT.getId())
						{
							dutyCycleByDeviceType.put(OpsCenterConstants.DeviceType.HVAC.getCeValue(), dutyCycleByDeviceTypeMap.get(deviceTypeId));
						}
						else
						{
							dutyCycleByDeviceType.put(dType.getCeValue(), dutyCycleByDeviceTypeMap.get(deviceTypeId));
						}
					}
				}
			}
		}

		grpPwr.setDutyCycleByDeviceType(dutyCycleByDeviceType);
	}

	/*
	 * Get power for a given CE group broken down by device type. Only HVAC,
	 * Water Hater, and PoolPump are considered.
	 */

	@Override
	public LinkedHashMap<String, Double> getPowerAvailForGrpByDevType(int grpId)
	{

		logger.info("Entering  getPowerAvailForGrpByDevType , grpId " + grpId);

		LinkedHashMap<String, Double> grpPowerByDev = new LinkedHashMap<String, Double>();

		if (grpId == 0)
		{
			logger.error("Invalid grpId received, could not determine power for grp");
			return grpPowerByDev;
		}

		DateTime currTime = new DateTime();

		// Get all of the GroupPower ids for this group
		ArrayList<Integer> grpPowerIdList = getGroupPowerIdsForGroup(grpId);

		Results dcResults = cacheManager.getCacheData(cacheManager.getGwDCCache());

		Map<String, Double> powerByDev = new LinkedHashMap<String, Double>();
		powerByDev.put(OpsCenterConstants.DC_HVAC, 0.0);
		powerByDev.put(OpsCenterConstants.DC_WATER_HEATER, 0.0);
		powerByDev.put(OpsCenterConstants.DC_POOL_PUMP, 0.0);
		powerByDev.put(OpsCenterConstants.DC_IRRIGATION_PUMP, 0.0);
		powerByDev.put(OpsCenterConstants.DC_CROP_HEAT, 0.0);
		powerByDev.put(OpsCenterConstants.DC_GENERATOR, 0.0);
		powerByDev.put(OpsCenterConstants.DC_SINGLE_HEAT, 0.0);
		powerByDev.put(OpsCenterConstants.DC_DUAL_HEAT, 0.0);
		powerByDev.put(OpsCenterConstants.DC_HVAC_SWITCH, 0.0);
		// powerByDev.put(OpsCenterConstants.DC_EV_CHARGER, 0.0);

		int staleTimeMin = cacheManager.getStaleTimeMin();

		for (Result dcResult : dcResults.all())
		{
			EsiDcCacheData dcCache = (EsiDcCacheData) dcResult.getValue();
			if (dcCache != null)
			{
				// only accumulate power if the esi has been assigned to a grp
				List<Integer> ceGrpPowerIdList = dcCache.getGrpPowerIdList();
				// only accumulate reads which are inside of last staleTimeMin
				// minutes
				// add macId check for GS dcs since we dont care about stale
				// time for GS-DEV-1659
				if ((dcCache.getReadingTime() >= currTime.minusMinutes(staleTimeMin).getMillis() || dcCache.getDeviceMacId() != 0)
						&& !ceGrpPowerIdList.isEmpty())
				{
					double energyAvail = dcCache.getActEnergyAvail();
					String deviceType = dcCache.getDeviceType();
					// If there is a match between the Group Power IDs in the
					// ESI
					// and the Group Power IDs for the group, use this ESI
					if (isInList(grpPowerIdList, ceGrpPowerIdList))
					{
						if (powerByDev.containsKey(dcCache.getDeviceType()))
						{
							Double power = powerByDev.get(deviceType);
							power += energyAvail;
							powerByDev.put(dcCache.getDeviceType(), power);
						}
					}
				}
			}
		} // for (Result dcResult : dcResults.all()) {

		LinkedHashMap<String, Double> projPowerAvailList = new LinkedHashMap<String, Double>();
		projPowerAvailList.put(OpsCenterConstants.HVAC, powerByDev.get(OpsCenterConstants.DC_HVAC));
		projPowerAvailList.put(OpsCenterConstants.WH, powerByDev.get(OpsCenterConstants.DC_WATER_HEATER));
		projPowerAvailList.put(OpsCenterConstants.PP, powerByDev.get(OpsCenterConstants.DC_POOL_PUMP));
		projPowerAvailList.put(OpsCenterConstants.IP, powerByDev.get(OpsCenterConstants.DC_IRRIGATION_PUMP));
		projPowerAvailList.put(OpsCenterConstants.HS, powerByDev.get(OpsCenterConstants.DC_HVAC_SWITCH));
		projPowerAvailList.put(OpsCenterConstants.CH, powerByDev.get(OpsCenterConstants.DC_CROP_HEAT));
		projPowerAvailList.put(OpsCenterConstants.GEN, powerByDev.get(OpsCenterConstants.DC_GENERATOR));
		projPowerAvailList.put(OpsCenterConstants.SH, powerByDev.get(OpsCenterConstants.DC_SINGLE_HEAT));
		projPowerAvailList.put(OpsCenterConstants.DH, powerByDev.get(OpsCenterConstants.DC_DUAL_HEAT));
		// projPowerAvailList.put(OpsCenterConstants.EV,
		// powerByDev.get(OpsCenterConstants.DC_EV_CHARGER));

		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for HVAC: " + powerByDev.get(OpsCenterConstants.DC_HVAC));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for WH: " + powerByDev.get(OpsCenterConstants.DC_WATER_HEATER));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for PP: " + powerByDev.get(OpsCenterConstants.DC_POOL_PUMP));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for Irrigation Pump: " + powerByDev.get(OpsCenterConstants.DC_IRRIGATION_PUMP));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for AC Switch: " + powerByDev.get(OpsCenterConstants.DC_HVAC_SWITCH));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for Crop Heat: " + powerByDev.get(OpsCenterConstants.DC_CROP_HEAT));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for Generator: " + powerByDev.get(OpsCenterConstants.DC_GENERATOR));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for Single Heat: " + powerByDev.get(OpsCenterConstants.DC_SINGLE_HEAT));
		logger.debug("getPowerAvailForGrpByDevType: energy found in cache for Dual Heat: " + powerByDev.get(OpsCenterConstants.DC_DUAL_HEAT));
		// logger.debug("getPowerAvailForGrpByDevType: energy found in cache for EV Charger: "
		// + powerByDev.get(OpsCenterConstants.DC_EV_CHARGER));

		return projPowerAvailList;
	}

	/**
	 * Check to see if something from one list is in the other list.
	 * 
	 * @param source
	 * @param target
	 * @return
	 */
	private boolean isInList(List<Integer> source, List<Integer> target)
	{
		for (Integer sourceInt : source)
		{
			if (target.contains(sourceInt))
			{
				return true;
			}
		}

		return false;
	}

	/**
	 * @param grpId
	 * @return
	 */

	@Override
	public double getPowerAvailForGrp(int grpId)
	{

		logger.debug("Entering  getPowerAvailForGrp , grpId " + grpId);

		double groupPower = 0.0;

		if (grpId == 0)
		{
			logger.error("Invalid grpId received, could not determine power for grp");
			return groupPower;
		}

		DateTime currTime = new DateTime();

		// Get all of the GroupPower ids for this group
		ArrayList<Integer> grpPowerIdList = getGroupPowerIdsForGroup(grpId);

		// Look at all ESIs ...
		Results dcResults = cacheManager.getCacheData(cacheManager.getGwDCCache());

		int staleTimeMin = cacheManager.getStaleTimeMin();

		for (Result dcResult : dcResults.all())
		{
			EsiDcCacheData dcCache = (EsiDcCacheData) dcResult.getValue();
			if (dcCache != null)
			{
				// only accumulate power if the esi has been assigned to this
				// group
				List<Integer> esiGrpPowerIdList = dcCache.getGrpPowerIdList();

				// only accumulate reads which are inside of last staleTimeMin
				// minutes
				// add macId check for GS dcs since we dont care about stale
				// time for GS-DEV-1659

				if ((dcCache.getReadingTime() >= currTime.minusMinutes(staleTimeMin).getMillis() || dcCache.getDeviceMacId() != 0)
						&& !esiGrpPowerIdList.isEmpty())
				{
					// If any CE Power Group in the ESI list matches any
					// CE Power Group for this CE Group, use it
					for (Integer ceGrpPowerId : esiGrpPowerIdList)
					{
						// Accumulate on any match but only one time per ESI
						if (grpPowerIdList.contains(ceGrpPowerId))
						{
							groupPower += dcCache.getActEnergyAvail();
							logger.debug("getPowerAvailForGrp: energy found in cache = " + dcCache.getActEnergyAvail());
							break;
						}
					}
				}
			}
		}

		return groupPower;
	}

	/**
	 * @param ceId
	 * @return
	 */

	@Override
	public double getPowerAvailForCE(int ceId)
	{

		return calculatePowerAvailForCE(ceId);

	}

	/**
	 * @param groupId
	 * @return
	 */
	private ArrayList<Integer> getGroupPowerIdsForGroup(int groupId)
	{
		// Get all of the GroupPower ids for this group
		ArrayList<Integer> grpPowerIdList = new ArrayList<Integer>();
		Results ceGrpPowerResults = cacheManager.getCacheData(cacheManager.getCeGrpPowerCache());
		for (Result result : ceGrpPowerResults.all())
		{
			CEGroupPowerCacheData ceGroupPowerCache = (CEGroupPowerCacheData) result.getValue();
			if (ceGroupPowerCache != null)
			{
				if (ceGroupPowerCache.getCeGrpId() == groupId)
				{
					grpPowerIdList.add(ceGroupPowerCache.getGrpPowerId());
					logger.debug("Found GrpPowerId from GrpPowerCache, id = " + ceGroupPowerCache.getGrpPowerId());
				}
			}
		}

		return grpPowerIdList;
	}

	/**
	 * This method will drill into an existing running CE and figure out how
	 * much power is available from other devices which are not involved in the
	 * running CE for every grp in the event. If no power is avail, a 0.0 is
	 * returned for the specified device class
	 * 
	 * @param integer
	 *            (ceId) = currently active CE
	 * @param List
	 *            devClass(String) = one or several of the following:
	 * 
	 *            //OpsCenterConstants.HVAC //OpsCenterConstants.WH
	 *            //OpsCenterConstants.PP
	 * @return LinkedHashMap <String, Double> ( device class from above),(
	 *         powerAvailable)
	 */

	@Override
	public LinkedHashMap<String, Double> getPowerAvailForDevClass(int ceId, List<String> devClass) throws AbstractOpsCenterException
	{

		logger.info("Entering  getPowerAvailForDevClass ");

		Results grpResult = cacheManager.getCacheData(cacheManager.getCeGrpCache());

		if (grpResult.size() == 0)
		{
			logger.error("No GRP entries found in cache,  cant compute power avail");
			return null;
		}

		DateTime currTime = new DateTime();
		if (ceId == 0)
		{
			logger.error("Invalid " + OpsCenterConstants.CE_NAME + " Id received, cannot determine power avail");
			return null;
		}
		if (devClass == null)
		{
			logger.error("Device class not valid, cannot compute device class power");
			return null;
		}

		Results ceResults = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(), ceId);
		if (ceResults == null || ceResults.size() == 0)
		{
			throw new ControlEventNotFoundException(OpsCenterConstants.CE_NAME + " " + ceId + " does not exit.  Cannot add device classes.");
		}
		ControlEventCacheData ceCache = null;
		Collection<String> ceTypeMap = new ArrayList<String>();
		for (Result ceResult : ceResults.all())
		{
			ceCache = (ControlEventCacheData) ceResult.getValue();
			if (ceCache == null)
			{
				logger.error("Null CEAccountMapCacheData entry trying to retrieve powerRemoved");
				throw new ControlEventNotFoundException(OpsCenterConstants.CE_NAME + " " + ceId + " not found in cache");
			}
			Collection<String> ceTypeSet = ceCache.getCEMapping().keySet();
			for (String dev : devClass)
			{
				if (ceTypeSet.contains(dev))
				{
					throw new ControlEventDeviceClassAlreadyInControl("Requested device class " + dev + "already in control for CEId = " + ceCache.getCeId());
				}
				ceTypeMap.add(dev);
				logger.debug("Added devClass to map =  " + dev);
			}
		}

		Map<Integer, Integer> ceGrpPowerIdToCeGrp = new HashMap<Integer, Integer>();
		Results grpMapResults = cacheManager.getCacheDataControlEventId(cacheManager.getCeGrpMapCache(), ceId);
		for (Result grpMap : grpMapResults.all())
		{
			CEGroupMapCacheData ceGrpMapCache = (CEGroupMapCacheData) grpMap.getValue();
			if (ceGrpMapCache == null)
			{
				logger.error("Null CEGrpMapCacheData entry trying to retrieve Ce Groups");
				continue;
			}
			// now add the grps to the map in order to computer power for the
			// grps
			Results ceGrpPowerResults = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpPowerCache(), ceGrpMapCache.getCeGrpId());
			for (Result result : ceGrpPowerResults.all())
			{
				CEGroupPowerCacheData ceGroupPowerCache = (CEGroupPowerCacheData) result.getValue();
				if (ceGroupPowerCache != null)
				{
					ceGrpPowerIdToCeGrp.put(ceGroupPowerCache.getGrpPowerId(), ceGroupPowerCache.getCeGrpId());
					logger.debug("Added grp power cache entry to map for grp =   " + ceGroupPowerCache.getCeGrpId());
				}
			}

		}
		grpMapResults.discard();

		double utilHvacAvail = 0.0;
		double utilWhAvail = 0.0;
		double utilPpAvail = 0.0;
		double utilIpAvail = 0.0;
		double utilCropHeatAvail = 0.0;
		double utilGeneratorAvail = 0.0;
		Results dcResults = cacheManager.getCacheData(cacheManager.getGwDCCache());

		int staleTimeMin = cacheManager.getStaleTimeMin();

		for (Result dcResult : dcResults.all())
		{
			EsiDcCacheData dcCache = (EsiDcCacheData) dcResult.getValue();
			if (dcCache != null)
			{
				// only accumulate power if the esi has been assigned to a grp
				List<Integer> ceGrpPowerIdList = dcCache.getGrpPowerIdList();
				// only accumulate reads which are inside of last staleTimeMin
				// minutes
				// add macId check for GS dcs since we dont care about stale
				// time for GS-DEV-1659
				if ((dcCache.getReadingTime() >= currTime.minusMinutes(staleTimeMin).getMillis() || dcCache.getDeviceMacId() != 0)
						&& !ceGrpPowerIdList.isEmpty())
				{
					double energyAvail = dcCache.getActEnergyAvail();
					String deviceType = dcCache.getDeviceType();
					for (Integer ceGrpPowerId : ceGrpPowerIdList)
					{
						Integer ceGroupId = ceGrpPowerIdToCeGrp.get(ceGrpPowerId);
						if (ceGroupId == null)
						{
							continue; // should never happen, unless cache out
										// of synch
						}
						if (ceTypeMap.contains(OpsCenterConstants.HVAC) && deviceType.equals(OpsCenterConstants.DC_HVAC))
						{
							utilHvacAvail += energyAvail;
						}
						if (ceTypeMap.contains(OpsCenterConstants.WH) && deviceType.equals(OpsCenterConstants.DC_WATER_HEATER))
						{
							utilWhAvail += energyAvail;
						}
						if (ceTypeMap.contains(OpsCenterConstants.PP) && deviceType.equals(OpsCenterConstants.DC_POOL_PUMP))
						{
							utilPpAvail += energyAvail;
						}
						if (ceTypeMap.contains(OpsCenterConstants.IP) && deviceType.equals(OpsCenterConstants.DC_IRRIGATION_PUMP))
						{
							utilIpAvail += energyAvail;
						}
						if (ceTypeMap.contains(OpsCenterConstants.CH) && deviceType.equals(OpsCenterConstants.DC_CROP_HEAT))
						{
							utilCropHeatAvail += energyAvail;
						}
						if (ceTypeMap.contains(OpsCenterConstants.GEN) && deviceType.equals(OpsCenterConstants.DC_GENERATOR))
						{
							utilGeneratorAvail += energyAvail;
						}
					}
				}
			}
		}
		dcResults.discard();

		LinkedHashMap<String, Double> devClassPowerAvail = new LinkedHashMap<String, Double>();
		if (ceTypeMap.contains(OpsCenterConstants.HVAC))
		{
			devClassPowerAvail.put(OpsCenterConstants.HVAC, utilHvacAvail);
		}
		if (ceTypeMap.contains(OpsCenterConstants.WH))
		{
			devClassPowerAvail.put(OpsCenterConstants.WH, utilWhAvail);
		}
		if (ceTypeMap.contains(OpsCenterConstants.PP))
		{
			devClassPowerAvail.put(OpsCenterConstants.PP, utilPpAvail);
		}
		if (ceTypeMap.contains(OpsCenterConstants.IP))
		{
			devClassPowerAvail.put(OpsCenterConstants.IP, utilIpAvail);
		}
		if (ceTypeMap.contains(OpsCenterConstants.CH))
		{
			devClassPowerAvail.put(OpsCenterConstants.CH, utilCropHeatAvail);
		}
		if (ceTypeMap.contains(OpsCenterConstants.GEN))
		{
			devClassPowerAvail.put(OpsCenterConstants.GEN, utilGeneratorAvail);
		}
		logger.debug("Got power for device class, hvac =  " + utilHvacAvail);
		logger.debug("Got power for device class, wh =  " + utilWhAvail);
		logger.debug("Got power for device class, PP =  " + utilPpAvail);
		logger.debug("Got power for device class, IP =  " + utilIpAvail);
		logger.debug("Got power for device class, CH =  " + utilCropHeatAvail);
		logger.debug("Got power for device class, GEN =  " + utilGeneratorAvail);

		return devClassPowerAvail;

	}

	/*
	 * Start a Control Event which had been previously requested by Presentation
	 * Layer and now it has been scheduled to run by the CE scheduler
	 * 
	 * @param ControlEvent
	 */
	@Override
	public double computePowerInPercent(ControlEvent ce, int grpId, double pwrRequested)
	{
		logger.info("Entering computePowerInPercent, powerRequested: " + pwrRequested);

		double power = 0.0;
		LinkedHashMap<String, Double> powerByDev = new LinkedHashMap<String, Double>();

		powerByDev = getPowerAvailForGrpByDevType(grpId);

		if (ce.getCEMapping().containsKey(OpsCenterConstants.HVAC))
		{
			power = powerByDev.get(OpsCenterConstants.HVAC);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.WH))
		{
			power += powerByDev.get(OpsCenterConstants.WH);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.PP))
		{
			power += powerByDev.get(OpsCenterConstants.PP);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.EV))
		{
			power += powerByDev.get(OpsCenterConstants.EV);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.IP))
		{
			power += powerByDev.get(OpsCenterConstants.IP);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.CH))
		{
			power += powerByDev.get(OpsCenterConstants.CH);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.GEN))
		{
			power += powerByDev.get(OpsCenterConstants.GEN);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.HS))
		{
			power += powerByDev.get(OpsCenterConstants.HS);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.SH))
		{
			power += powerByDev.get(OpsCenterConstants.SH);
		}
		if (ce.getCEMapping().containsKey(OpsCenterConstants.DH))
		{
			power += powerByDev.get(OpsCenterConstants.DH);
		}

		logger.debug("computed power for all dev Class, power equals " + power);

		// KRMT-6517: Ran in to instability when exceeding 100%, but getting an
		// additional 10% is so
		// ingrained in the code, the least risky solution was for me to divide
		// by EXTRA_POWER_FACTOR
		// b/c I know that we will multiply by EXTRA_POWER_FACTOR later
		pwrRequested = Math.min(pwrRequested, 100.0 / EXTRA_POWER_FACTOR);

		return power == 0.0 ? 0.0 : power * (pwrRequested / 100.0);
	}

	@Override
	public ControlEventModel startControlEvent(ControlEventStartModel ceStartModel, Integer tenantId) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] ControlEventModel ControlEventPowerBean.startControlEvent:\t" + ceStartModel);
		TenantContext.setCurrentTenant(tenantId);
		// For VPP percentage events, check the initialPowerToRemove
		// to make sure it's a valid value
		if (ceStartModel.getPowerRequestedInPercent().equals(OpsCenterConstants.TRUE))
		{
			for (GroupPowerModel group : ceStartModel.getGroupPowerList())
			{
				if (group.getInitialPowerToRemove() <= 0.0 || group.getInitialPowerToRemove() > 100.0)
				{
					logger.error("Cannot start VPP percentage event with initial power to remove less than 0 or greater than 100");
					logger.info("[ EXIT] ControlEventPowerBean.startControlEvent");
					throw new ControlEventPercentPowerToRemoveExceeded(DefaultResources.CEV_ERR_CODE_CE_PERCENT_POWER_EXCEEDED,
							"Cannot start VPP percentage event with initial power to remove less than 0 or greater than 100");
				}
			}
		}

		DateTime currTime = new DateTime();
		// now determine what kind of CE to start
		List<GroupPowerModel> grpList = ceStartModel.getGroupPowerList();
		if (grpList == null || grpList.isEmpty())
		{
			logger.error("Group list is empty, cannot start CE");
			return null;
		}
		if (ceStartModel.getTargetDeviceTypeIDs() == null)
		{
			logger.error("TargetDeviceType are not set in CE start request, event not started");
			return null;
		}

		boolean anyGrpPowerToRemove = false;
		// Check for power to remove
		for (GroupPowerModel reqGrps : grpList)
		{
			if (reqGrps.getPowerToRemove() > 0.0 || reqGrps.getDutyCycle() >= 0 || reqGrps.getInitialPowerToRemove() > 0.0)
			{
				anyGrpPowerToRemove = true;
			}
		}

		// group power to remove and group duty cycle do not apply for duty
		// cycle by device type
		if (ceStartModel.getDutyCycle() != OpsCenterConstants.dutyCycle.DEVICE && !anyGrpPowerToRemove)
		{
			throw new ControlEventNoPowerToRemoveProvidedException(DefaultResources.CEV_ERR_CODE_CE_NO_POWER_TO_REMOVE_PROVIDED,
					"No power provided in request to start CE");
		}
		if (ceStartModel.getDuration() > OpsCenterConstants.CE_DURATION_MAX_MINUTES)
		{
			// duration cannot be longer than 6 hrs( in minutes) then block
			// starting the event
			throw new ControlEventDurationNotAllowed(DefaultResources.CEV_ERR_CODE_CE_DURATION_NOT_ALLOWED, "Cannot start an event with duration longer than "
					+ OpsCenterConstants.CE_DURATION_MAX_MINUTES + " minutes");
		}
		if (ceStartModel.getDuration() <= 0)
		{
			// duration cannot be <= 0
			throw new ControlEventDurationNotAllowed(DefaultResources.CEV_ERR_CODE_CE_DURATION_NOT_ALLOWED,
					"Cannot start an event with duration less than 1 min");
		}

		// Check for conflicting use of CE groups
		DateTime stopTime = new DateTime(ceStartModel.getStartDate().plusMinutes(ceStartModel.getDuration()));
		checkForConflictedCEGroups(-1, ceStartModel.getStartDate(), stopTime, grpList);

		/*
		 * determine what kind of CE to set in DB //possible combos are
		 * HVAC+WH+PP,HVAC, HVAC+WH, HVAC+PP,WH, WH+PP,PP HVAC+WH+PP+HS+EVC,
		 * HVAC+HS+EVC, WH+HS+EVC, PP+HS+EVC..etc...
		 */
		LinkedHashMap<String, String> ceTypeMap = new LinkedHashMap<String, String>();

		Map<Integer, double[]> grpAvailPowerList = new HashMap<Integer, double[]>();
		// create an instance of the entity
		final ControlEvent ce = new ControlEvent();
		ceTypeMap.putAll(ceStartModel.getTargetDeviceTypeIDs());
		ce.setCEMapping(ceTypeMap);
		// ce.getCEMapping() removes any false from the map
		ceTypeMap = ce.getCEMapping();

		if (ceTypeMap.isEmpty())
		{
			throw new ControlEventStartNotAllowedNoDevClassSet(DefaultResources.CEV_ERR_CODE_CE_NO_DEVICE_CLASS_SET,
					"Cannot start an event with no device class set");
		}

		ce.setAutoCe(OpsCenterConstants.FALSE);
		if (ceStartModel.getAutoCe() != null)
		{
			ce.setAutoCe(ceStartModel.getAutoCe());
			ce.setScadaReferenceId(ceStartModel.getiScadaReferenceId());
			
		}
		// set the ControlEvent entity
		logger.debug("Creating ControlEvent entries in DB");

		CeStatus statusInProgress = entityManager.getReference(CeStatus.class, OpsCenterConstants.ceStatusNameToCEStatusID.get(OpsCenterConstants.IN_PROGRESS)
				.intValue());

		CeStatus statusNew = entityManager.getReference(CeStatus.class, OpsCenterConstants.ceStatusNameToCEStatusID.get(OpsCenterConstants.NEW).intValue());

		CeStatus currentCEStatus = statusInProgress;

		ce.setName(ceStartModel.getName());
		ce.setCriticalFlag(ceStartModel.getCriticalCE());
		ce.setStartTime(ceStartModel.getStartDate());
		if (stopTime.compareTo(currTime) < 0)
		{
			throw new ControlEventDurationNotAllowed("Stop time cannot be in the past");
		}
		ce.setStopTime(stopTime);
		ce.setPowerToRemove(ceStartModel.getTotalPowerToRemove());
		ce.setManageAllGroupsFlag(OpsCenterConstants.FALSE);
		ce.setCeStatusId(currentCEStatus);

		String username = userAccBeanFacade.findUserByUserId(ceStartModel.getUserId()).getUsername();
		ce.setDateCreated(new DateTime());
		ce.setUserCreated(username);
		ce.setDateModified(new DateTime());
		ce.setUserModified(username);
		ce.setModifiedCount(0);
		logger.debug("ceStartModel from UI for powerInPercent = " + ceStartModel.getPowerRequestedInPercent());

		if (OpsCenterConstants.TRUE.equals(ceStartModel.getPowerRequestedInPercent()) && ceStartModel.getMode() == OpsCenterConstants.eventMode.CYCLING)
		{
			logger.error("Cannot start event as cycling and percent, exception thrown");
			throw new DatabaseUpdateFailed(DefaultResources.CEV_ERR_CODE_CYCLING_PERCENT_CE_NOT_ALLOWED, "Cannot start event as cycling and percent "
					+ OpsCenterConstants.CE_NAME);
		}
		ce.setPowerToRemoveInPercent(ceStartModel.getPowerRequestedInPercent());
		ce.setCycling(OpsCenterConstants.eventMode.CYCLING == ceStartModel.getMode() ? OpsCenterConstants.TRUE : OpsCenterConstants.FALSE);
		logger.debug("PowerToRemoved received from UI = " + ce.getPowerToRemove());
		logger.debug("ceStartModel from UI for cycling = " + ce.getCycling());
		if (ceStartModel.getStartDate().getMillis() > currTime.getMillis())
		{
			// this means this event is scheduled sometime in the future
			// schedule it now and exit, once event starts the rest of the CE
			// tables will be populated by the scheduler

			currentCEStatus = statusNew;
			ce.setCeStatusId(currentCEStatus);
			try
			{
				controlEventBeanFacade.createControlEvent(ce);
				entityManager.flush();
				entityManager.refresh(ce);
				updateCeDefinitionData(ceStartModel.getCeDefinitionId(), ceStartModel.getDutyCycleByDeviceType(), ce, ceStartModel.getMode(),
						ceStartModel.getDutyCycle());
			} catch (Exception e1)
			{
				logException(e1, "At create future control event");
				logger.info("[ EXIT] ControlEventPowerBean.startControlEvent");
				throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for " + OpsCenterConstants.CE_NAME);
			}
			grpAvailPowerList = createCeGroupMaps(grpList, ce, 1);
			ControlEventPowerModel powerModelData = new ControlEventPowerModel();
			powerModelData.setNumberOfGateways(0);
			powerModelData.setPowerAvailable(0.0);
			powerModelData.setPowerRemoved(ceStartModel.getTotalPowerToRemove());
			powerModelData.setGroupPowerList(ceStartModel.getGroupPowerList());
			controlEventBean.scheduleControlEvent(ce.getControlEventId());
			// return powerModelData;
			logger.info("[ EXIT] ControlEventPowerBean.startControlEvent");
			return getControlEventDetails(ce.getControlEventId(), grpAvailPowerList);
		}

		try
		{
			controlEventBeanFacade.createControlEvent(ce);
		} catch (Exception e1)
		{
			logException(e1, "At create control event");

			throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for " + OpsCenterConstants.CE_NAME);
		}
		ceNotificationBean.notifyStatusChange(ce.getName(), OpsCenterConstants.IN_PROGRESS);

		// now record in the log table that a CE has started
		CeLog ceLog = new CeLog();
		ceLog.setControlEventId(ce);
		ceLog.setDateCreated(currTime);
		ceLog.setCeStatusId(currentCEStatus);

		ceLog.setLogMessage(OpsCenterConstants.CE_NAME + " is " + currentCEStatus.getCeStatusName());
		try
		{
			controlEventBeanFacade.createCeLog(ceLog);
		} catch (Exception e1)
		{
			logException(e1, ceLog.getLogMessage());

			throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for " + OpsCenterConstants.CE_NAME);
		}
		// now update CE Cache
		cacheManager.updateControlEventCache(ce);

		final int userId = ceStartModel.getUserId();
		final DateTime startTime = ce.getStartTime();
		final ControlEventPowerModel powerModelData = new ControlEventPowerModel();
		powerModelData.setUserName(username);
		logger.debug("size of ceGrps passed in from UI = " + grpList.size());

		entityManager.flush();
		entityManager.refresh(ce);

		// Need to flush & refresh before I call getControlEventDetails...
		// dev-2941 update ce_definition now into DB..
		updateCeDefinitionData(ceStartModel.getCeDefinitionId(), ceStartModel.getDutyCycleByDeviceType(), ce, ceStartModel.getMode(),
				ceStartModel.getDutyCycle());

		ControlEventModel controlEventModel = getControlEventDetails(ce.getControlEventId(), grpAvailPowerList);

		final List<GroupPowerModel> grpRunList = ceStartModel.getGroupPowerList();
		final Map<Integer, double[]> grpAvailPowerRunList = new HashMap<Integer, double[]>();
		grpAvailPowerRunList.putAll(grpAvailPowerList);

		ControlEvent controlEvent = ce;

		// rdrn-204-- do not create external threads
		controlEventPowerBean.populateGrpDataAddingGroupsNewThread(grpAvailPowerRunList, grpRunList, powerModelData, controlEvent, startTime, userId, 0, TenantContext.getCurrentTenant());

		logger.info("[ EXIT] ControlEventPowerBean.startControlEvent");

		return controlEventModel;
	}

	/**
	 * @param powerModelData
	 * @param reqGrp
	 * @param ce
	 * @param startTime
	 * @param userId
	 * @throws DatabaseUpdateFailed
	 * @throws AbstractOpsCenterException
	 */

	@Asynchronous
	public void populateGrpDataAddingGroupsNewThread(Map<Integer, double[]> grpAvailPowerRunList, List<GroupPowerModel> grpRunList,
			ControlEventPowerModel powerModelData, ControlEvent ce, DateTime startTime, int userId, int grpMapSize, Integer tenantId) throws DatabaseUpdateFailed,
			AbstractOpsCenterException
	{

		logger.debug("creating CE grps for grp size" + grpRunList.size());
		TenantContext.setCurrentTenant(tenantId);
		/*
		 * ControlEvent controlEvent = controlEventBeanFacade
		 * .findControlEventByControlEventId(controlEventId);
		 */
		ControlEvent controlEvent = ce;
		for (GroupPowerModel reqGrps : grpRunList)
		{
			double[] power = new double[] { 0.0, 0.0 };
			if (OpsCenterConstants.TRUE.equals(controlEvent.getCycling()))
			{
				power[0] = 0.0;
				power[1] = 0.0;
				grpAvailPowerRunList.put(reqGrps.getGrpId(), power);
				populateCyclingDataAddingGroups(powerModelData, reqGrps, controlEvent, startTime, userId, 0);

			}
			else
			{
				// need these values so UI can apply range checks when power is
				// requested in %
				// these values will be passed back upon returning from this
				// method in getControlEventDetails..
				power[0] = reqGrps.getPowerToRemove();
				power[1] = reqGrps.getInitialPowerToRemove();
				grpAvailPowerRunList.put(reqGrps.getGrpId(), power);
				populatePowerModelDataAddingGroups(powerModelData, reqGrps, controlEvent, startTime, userId, 0);
			}
			// krmt-5040-- do not worry about CE power to remove, as we need to
			// meet the requested power for each group
			/*
			 * if (powerModelData.getPowerRemoved() >= ce.getPowerToRemove()) {
			 * //we have met the desired power to remove, go ahead an exit now
			 * break; }
			 */
		}// for (GroupPowerModel reqGrps:grpList)

		controlEventBean.scheduleControlEvent(controlEvent.getControlEventId());

	}

	private void populatePowerModelDataAddingGroups(ControlEventPowerModel powerModelData, GroupPowerModel reqGrp, ControlEvent ce, DateTime startTime,
			int userId, int grpMapSize) throws DatabaseUpdateFailed, AbstractOpsCenterException
	{
		logger.info("[ENTER] void ControlEventPowerBean.populatePowerModelDataAddingGroups(...)");

		logger.debug("reqGrp = " + reqGrp);

		LinkedHashMap<String, String> ceTypeMap = ce.getCEMapping();
		GroupPowerGatewayData grpPowerData = new GroupPowerGatewayData();
		CeGroupMap grpMap = null;
		logger.debug("power in % delivered by UI = " + ce.getPowerToRemoveInPercent());
		boolean powerInPercent = ce.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE);
		double grpPowerToRemove = 0.0;
		double grpReqPwrToRem = 0.0;
		double grpPowerToRemoveInPercent = 0.0;

		// find this grp in CE_GROUP cache
		int grpKey = reqGrp.getGrpId();
		if (!cacheManager.getCeGrpCache().isKeyInCache(grpKey))
		{
			// not in cache--what to do??
			logger.error("Grp request from UI not in grp cache--error??");
		}
		else
		{
			if (powerInPercent)
			{
				grpPowerToRemoveInPercent = reqGrp.getInitialPowerToRemove();
				grpPowerToRemove = computePowerInPercent(ce, reqGrp.getGrpId(), grpPowerToRemoveInPercent);
				logger.debug("Power request by % (" + grpPowerToRemoveInPercent + "%), convert to Watts avail = " + grpPowerToRemove);
			}
			else
			{
				grpPowerToRemove = reqGrp.getPowerToRemove();
				logger.debug("Power requested in WATTS for GrpId/reqGrpPwrToRemove = " + reqGrp.getGrpId() + "/" + grpPowerToRemove);
			}
			// we did not find any power to remove, so set grpReqPwrToRem to
			// store in GRP table
			// in the DB as percent of power available as rec from UI
			if (powerInPercent && grpPowerToRemove == 0.0)
			{
				grpReqPwrToRem = reqGrp.getPowerToRemove() * EXTRA_POWER_FACTOR;
			}
			else
			{
				// did we request more power than avail?
				// add additional 10 % more power in case we cant meet the
				// request amount at start
				grpReqPwrToRem = grpPowerToRemove * EXTRA_POWER_FACTOR;
			}
			logger.debug("Power requested to remove for GrpId/ReqPwrToRemove = " + reqGrp.getGrpId() + "/" + grpReqPwrToRem);

			Element element = cacheManager.getCeGrpCache().get(grpKey);
			CEGroupCacheData grpCacheData = (CEGroupCacheData) element.getObjectValue();
			// Added for Wifi Tstat Devices
			int iGroupId = grpCacheData.getCeGrpId();
			List<Integer> grpAccIdListGS = controlEventBeanFacade.getActiveCeGroupAccountMapIdListByCeGroupId(iGroupId,
					OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID);
			ControlEventCacheData ceControlEventCacheData = null;
			String strHoneywellEnabled = null;
			Results ceControlEventCache = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(), ce.getControlEventId());
			if (ceControlEventCache == null || ceControlEventCache.size() == 0)
			{
				logger.error("ControlEventPowerBean:populatePowerModelDataAddingGroups ControlEvent cache is null");
				return;
			}
			for (Result ceResult : ceControlEventCache.all())
			{
				ceControlEventCacheData = (ControlEventCacheData) ceResult.getValue();
				strHoneywellEnabled = ceControlEventCacheData.getStrHoneywellEnabled();
			}
			logger.debug("ControlEventPowerBean:addDevicesToCe:The Honeywell enableddd is" + strHoneywellEnabled);
			boolean isWifiThirdPartyGroup = false;
			if (strHoneywellEnabled != null && strHoneywellEnabled.length() >0 && strHoneywellEnabled.equalsIgnoreCase("Y")) {
			 
		    Results dcAvail = cacheManager.getAllCacheDataDcModeAndAccId(cacheManager.getGwDCCache(), grpAccIdListGS);
			logger.warn("dcAvail size= " + dcAvail.size());
			for (Result dc : dcAvail.all())
			{
				EsiDcCacheData dcCacheData = (EsiDcCacheData) dc.getValue();
				logger.debug("The Device Type is" + dcCacheData.getDeviceType());
				if (dcCacheData.getDeviceType().equalsIgnoreCase(OpsCenterConstants.THIRD_PARTY_TSTAT))
				{
					isWifiThirdPartyGroup = true;
					break;
				}
			}
			 }
			//KRMT-7634 this flag is not used anywhere for now, but if it is intended to be used put must be invoked.
			// Setting in cache that Group has wifi tsat or not
			grpCacheData.setWifiTstat(isWifiThirdPartyGroup);
			// Modified for Wifi Tstats for Handling No Power cases
			if ((grpReqPwrToRem > 0.0 && grpCacheData.getProjPowerConsumed() > 0.0) || (powerInPercent && grpPowerToRemoveInPercent > 0.0)
					|| isWifiThirdPartyGroup)
			{
				// we have met all requested power to remove, exit from this
				// group
				// have enough power, figure out what kind of event it is
				// first update DB for Group_Map

				grpMap = new CeGroupMap();
				grpMap.setCeGroupId(controlEventBeanFacade.getRefCeGroupByCeGroupId(grpKey));
				grpMap.setControlEventId(ce);
				grpMap.setPowerToRemoveInPercent(ce.getPowerToRemoveInPercent());
				grpMap.setPowerToRemove(grpMap.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE) ? grpPowerToRemoveInPercent * EXTRA_POWER_FACTOR
						: grpReqPwrToRem);
				grpMap.setInitialPowerToRemove(grpMap.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE) ? reqGrp.getInitialPowerToRemove() : reqGrp
						.getPowerToRemove());

				grpMap.setAdditionalPowerToRemove(0.0);
				grpMap.setModifiedCount(0);
				grpMap.setCeGroupOrder(++grpMapSize);
				grpMap.setGroupPowerFallenFlag(OpsCenterConstants.FALSE);

				if (grpMap.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE))
				{
					grpMap.setDutyCycle(100);
				}

				try
				{
					controlEventBeanFacade.createCeGroupMap(grpMap);
				} catch (Exception e1)
				{
					logException(e1, "At populatePowerModelDataAddingGroups create CE Group Map");

					logger.info("[ EXIT] ControlEventPowerBean.populatePowerModelDataAddingGroups");

					throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeGroupMap for GRPid = "
							+ grpMap.getCeGroupId());
				}
				logger.debug("Created CeGroupMap entries in DB for grp= " + grpMap.getCeGroupId().getCeGroupId());
				// now update the GRP Map Cache
				try
				{
					// power to remove initially should be 0.0 , as ESI are
					// added this value will increment
					cacheManager.updateCEGrpMapCache(grpMap.getCeGroupMapId(), grpMap.getAdditionalPowerToRemove(), grpMap.getPowerToRemove(),
							ce.getPowerToRemoveInPercent());
				} catch (InterruptedException e)
				{
					e.printStackTrace();
				}
				// Modified for Wifi Tstats for Handling No Power cases
				if (grpPowerToRemove == 0.0 && !isWifiThirdPartyGroup)
				{
					// when the above value is 0.0, that means power was
					// requested as % and no power was
					// avail, so dont even try and get power. Let the Power
					// scheduler monitor...
					logger.info("[ EXIT] ControlEventPowerBean.populatePowerModelDataAddingGroups");

					return;
				}

				grpPowerData.setGrpPowerToRemove(grpReqPwrToRem);

				Collection<String> ceTypeSet = ceTypeMap.keySet();
				logger.debug("Looking for ESIs with power for types: " + ceTypeSet);
				// now determine which ESIs / DCs to include in CE
				grpPowerData = addDevicesToCe(grpMap, grpPowerData, startTime, userId, grpAccIdListGS, isWifiThirdPartyGroup);

				double grpPwrRemoved = grpPowerData.getGrpPowerRemoved();

				// this is total power avail for group
				double grpPowerAvail = Math.max(grpCacheData.getProjPowerAvailable() - grpPwrRemoved, 0.0);

				reqGrp.setPowerRemoved(grpPwrRemoved);
				reqGrp.setProjPowerAvailable(grpPowerAvail);

				powerModelData.setNumberOfGateways(powerModelData.getNumberOfGateways() + grpPowerData.getNumGws());
				powerModelData.setPowerAvailable(powerModelData.getPowerAvailable() + grpPowerAvail);
				powerModelData.setPowerRemoved(powerModelData.getPowerRemoved() + grpReqPwrToRem);

				logger.info("[ EXIT] ControlEventPowerBean.populatePowerModelDataAddingGroups");
			}
		}
		controlEventBean.scheduleControlEvent(ce.getControlEventId());

	}

	/**
	 * @param reqGrps
	 * @param ce
	 * @param startTime
	 * @param userId
	 * @throws DatabaseUpdateFailed
	 * @throws AbstractOpsCenterException
	 */
	private void populateCyclingDataAddingGroups(ControlEventPowerModel powerModelData, GroupPowerModel reqGrps, ControlEvent ce, DateTime startTime,
			int userId, int grpMapSize) throws DatabaseUpdateFailed, AbstractOpsCenterException
	{
		logger.info("Entering  populateCyclingDataAddingGroups");

		LinkedHashMap<String, String> ceTypeMap = ce.getCEMapping();
		GroupPowerGatewayData grpPowerData = new GroupPowerGatewayData();
		CeGroupMap grpMap = null;
		// find this grp in CE_GROUP cache
		int grpKey = reqGrps.getGrpId();
		if (!cacheManager.getCeGrpCache().isKeyInCache(grpKey))
		{
			// not in cache--what to do??
			logger.error("Grp request from UI not in grp cache--error??");
		}
		else
		{
			Element element = cacheManager.getCeGrpCache().get(grpKey);
			CEGroupCacheData grpCacheData = (CEGroupCacheData) element.getObjectValue();

			logger.debug("Duty Cycle for grpId/dutyCycle = " + reqGrps.getGrpId() + "/" + reqGrps.getDutyCycle());

			grpMap = new CeGroupMap();
			grpMap.setCeGroupId(controlEventBeanFacade.getRefCeGroupByCeGroupId(grpKey));
			grpMap.setControlEventId(ce);
			grpMap.setPowerToRemove(reqGrps.getDutyCycle());
			grpMap.setInitialPowerToRemove(reqGrps.getDutyCycle());
			// TODO -- get metered power from DB --where??

			grpMap.setAdditionalPowerToRemove(0.0);
			grpMap.setModifiedCount(0);
			grpMap.setCeGroupOrder(++grpMapSize);
			grpMap.setGroupPowerFallenFlag(OpsCenterConstants.FALSE);
			grpMap.setPowerToRemoveInPercent(OpsCenterConstants.FALSE);
			grpMap.setDutyCycle(reqGrps.getDutyCycle());
			try
			{
				controlEventBeanFacade.createCeGroupMap(grpMap);
			} catch (Exception e1)
			{
				logException(e1, "At populatePowerModelDataAddingGroups create CE Group Map");

				throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeGroupMap for GRPid = "
						+ grpMap.getCeGroupId());
			}
			logger.debug("Created CeGroupMap entries in DB for grp= " + grpMap.getCeGroupId().getCeGroupId());
			// now update the GRP Map Cache
			try
			{
				// power to remove initially should be 0.0 , as ESI are added
				// this value will increment
				cacheManager.updateCEGrpMapCache(grpMap.getCeGroupMapId(), grpMap.getAdditionalPowerToRemove(), grpMap.getPowerToRemove(),
						ce.getPowerToRemoveInPercent());
			} catch (InterruptedException e)
			{
				e.printStackTrace();
			}

			logger.debug("Looking for ESIs for types: " + ceTypeMap.keySet());

			logger.debug("now add all ESI in this grp to cycling event ");
			grpPowerData = addDevicesToCyclingCE(grpMap, grpPowerData, startTime, userId);

			reqGrps.setPowerRemoved(0.0);
			reqGrps.setProjPowerAvailable(grpCacheData.getProjPowerAvailable());

			powerModelData.setNumberOfGateways(powerModelData.getNumberOfGateways() + grpPowerData.getNumGws());
			powerModelData.setPowerAvailable(grpCacheData.getProjPowerAvailable());
			powerModelData.setPowerRemoved(0.0);

		}
		logger.info("Exiting  populateCyclingDataAddingGroups");

	}

	private void updateCeDefinitionData(Integer ceDefId, Map<String, Integer> dcByDevType, ControlEvent ce, OpsCenterConstants.eventMode mode,
			OpsCenterConstants.dutyCycle dc)
	{

		/*
		 * DEV-2874 Add CE_DEFN_EVENT_MAPs in this thread as opposed to from the
		 * UI controller thread, to prevent race conditions
		 */
		if (ceDefId != null && mode == OpsCenterConstants.eventMode.CYCLING)
		{
			if (dc == OpsCenterConstants.dutyCycle.GROUP)
			{
				try
				{
					ceDefinitionBean.addDefinitionEventEntry(ceDefId, ce.getControlEventId());
				} catch (AbstractOpsCenterException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			else
			{

				for (String deviceType : dcByDevType.keySet())
				{
					logger.info("iterating, devtype =" + deviceType);

					int deviceTypeId = OpsCenterConstants.DeviceType.fromCeValue(deviceType).getId();

					// back end code is expecting 19 (TSTAT), not 0 (HVAC)
					if (deviceTypeId == OpsCenterConstants.DEVICE_TYPE_ID_HVAC)
					{
						deviceTypeId = OpsCenterConstants.DEVICE_TYPE_ID_TSTAT;
					}

					try
					{
						ceDefinitionBean.addDefinitionEventEntry(ceDefId, ce.getControlEventId(), deviceTypeId, dcByDevType.get(deviceType));
					} catch (AbstractOpsCenterException e)
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		}

	}

	/**
	 * @param ceId
	 * @param startTime
	 * @param stopTime
	 */
	private void checkForConflictedCEGroups(int ceId, DateTime startTime, DateTime stopTime, List<GroupPowerModel> grpList) throws AbstractOpsCenterException
	{
		List<Integer> conflictedCEGroups = new ArrayList<Integer>();

		List<ControlEvent> ceList = controlEventBeanFacade.getActiveAndFutureControlEventByTime(new DateTime());

		// Check each group in the CE request
		for (GroupPowerModel reqGrps : grpList)
		{

			for (ControlEvent ce : ceList)
			{
				// No comparison if it is the same CE
				if (ce.getControlEventId() != ceId)
				{
					// Check to see if the CEs overlap
					if (startTime.getMillis() >= ce.getStartTime().getMillis() && startTime.getMillis() <= ce.getStopTime().getMillis()
							|| stopTime.getMillis() >= ce.getStartTime().getMillis() && stopTime.getMillis() <= ce.getStopTime().getMillis())
					{
						// Check for the same group
						List<CeGroupMap> ceGroupMapList = ce.getCeGroupMapCollection();
						for (CeGroupMap ceGrpMap : ceGroupMapList)
						{
							if (ceGrpMap.getCeGroupId().getCeGroupId() == reqGrps.getGrpId())
							{
								conflictedCEGroups.add(reqGrps.getGrpId());
							}
						}
					}
				}
			}
		}

		// Throw an exception if we have any conflicts
		if (conflictedCEGroups.size() > 0)
		{
			String message = "Some specified groups are already in a CE: ";
			for (int i = 0; i < conflictedCEGroups.size(); ++i)
			{
				if (i != 0)
				{
					message += ",";
				}
				message += conflictedCEGroups.get(i);
			}

			throw new ControlEventAllSpecifiedGroupsInControlEventException(DefaultResources.CEV_ERR_CODE_CE_ALL_SPECIFIED_GROUPS_IN_CE, message);
		}
	}

	/**
	 * @param grpList
	 * @param ce
	 * @param startingGroupOrder
	 * @param powerInPercent
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	private Map<Integer, double[]> createCeGroupMaps(List<GroupPowerModel> grpList, ControlEvent ce, int startingGroupOrder) throws AbstractOpsCenterException
	{
		int order = startingGroupOrder;
		double grpPowerToRemove;
		Map<Integer, double[]> grpAvailPowerList = new HashMap<Integer, double[]>();
		boolean cycling = ce.getCycling().equals(OpsCenterConstants.TRUE);
		boolean powerInPercentage = ce.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE);

		for (GroupPowerModel reqGrps : grpList)
		{
			if (reqGrps.getPowerToRemove() <= 0 && !cycling)
			{
				logger.debug("GRP passed in from UI powerToRemove = 0, skipped - GRP id = " + reqGrps.getGrpId());
			}
			else
			{
				if (cycling)
				{
					grpPowerToRemove = 0.0;
				}
				else if (powerInPercentage)
				{
					double[] power = new double[] { 0.0, 0.0 };
					power[0] = reqGrps.getAdditionalPowerToRemove();
					power[1] = reqGrps.getInitialPowerToRemove();
					grpAvailPowerList.put(reqGrps.getGrpId(), power);
					grpPowerToRemove = reqGrps.getInitialPowerToRemove();
					logger.debug("Power for grpId / reqGrpPwrToRemove = " + reqGrps.getGrpId() + "/" + grpPowerToRemove + "%");
				}
				else
				{
					double[] power = new double[] { 0.0, 0.0 };
					power[0] = reqGrps.getPowerToRemove();
					power[1] = reqGrps.getInitialPowerToRemove();
					grpAvailPowerList.put(reqGrps.getGrpId(), power);
					grpPowerToRemove = reqGrps.getPowerToRemove();
					logger.debug("Power for grpId / reqGrpPwrToRemove = " + reqGrps.getGrpId() + "/" + grpPowerToRemove);
				}
				// first update DB for Group_Map
				CeGroupMap grpMap = new CeGroupMap();
				grpMap.setCeGroupId(controlEventBeanFacade.getRefCeGroupByCeGroupId(reqGrps.getGrpId()));
				grpMap.setControlEventId(ce);
				grpMap.setInitialPowerToRemove(grpPowerToRemove);
				grpMap.setPowerToRemove(grpPowerToRemove * EXTRA_POWER_FACTOR);
				// Setting this when CE starts
				// grpMap.setInitialMeteredPowerConsumed(getLatestEMReading(grpMap.getCeGroupId().getCeGroupId()));
				grpMap.setAdditionalPowerToRemove(0.0);
				grpMap.setModifiedCount(0);
				grpMap.setCeGroupOrder(order);
				order++;
				grpMap.setGroupPowerFallenFlag(OpsCenterConstants.FALSE);
				grpMap.setPowerToRemoveInPercent(ce.getPowerToRemoveInPercent());
				grpMap.setDutyCycle(reqGrps.getDutyCycle());
				try
				{
					controlEventBeanFacade.createCeGroupMap(grpMap);
				} catch (Exception e1)
				{
					logException(e1, "At createCeGroupMaps create CE Group Map");

					throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeGroupMap for GRPid = "
							+ grpMap.getCeGroupId().getCeGroupId());
				}
			}
		}
		return grpAvailPowerList;
	}

	/*
	 * Add account maps to a CE
	 */
	@Override
	public void addCeAccountMapEntries(int ceId, List<Integer> esiList, Map<Integer, CeAccountMapModel> esiToAcctMapModel, Collection<String> deviceNameList)
	{

		final int runCeId = ceId;
		final List<Integer> runEsiList = esiList;
		final Map<Integer, CeAccountMapModel> runEsiToAcctMapModel = esiToAcctMapModel;
		final Collection<String> runDeviceNameList = deviceNameList;

		// RDRN-204 do not create external threads
		controlEventPowerBean.addCeAccountMapEntriesThreadRun(runCeId, runEsiList, runEsiToAcctMapModel, runDeviceNameList, TenantContext.getCurrentTenant());

	}

	@Asynchronous
	public void addCeAccountMapEntriesThreadRun(int ceId, List<Integer> esiList, Map<Integer, CeAccountMapModel> esiToAcctMapModel,
			Collection<String> deviceNameList, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceId);

		int clearCount = 0;
		for (int esiId : esiList)
		{
			CeAccountMap ceAccMap = new CeAccountMap();
			CeAccountMapModel ceAccMapModel = esiToAcctMapModel.get(esiId);

			Account account = userAccBeanFacade.getRefAccountByAccountId(ceAccMapModel.getAccountId());

			CeGroup ceGrp = controlEventBeanFacade.getRefCeGroupByCeGroupId(ceAccMapModel.getCeGroupId());
			ceAccMap.setCeGroupId(ceGrp);
			ceAccMap.setAccountId(account);
			ceAccMap.setInitialPowerRemovable(ceAccMapModel.getInitialPowerRemovable());
			ceAccMap.setPowerConsumed(ceAccMapModel.getPowerConsumed());
			ceAccMap.setPowerToRemove(ceAccMapModel.getPowerToRemove());
			// If this account was added at the start of the CE then this value
			// must
			// equal the CE start time
			ceAccMap.setStartTime(ceAccMapModel.getStartTime());
			ceAccMap.setStopTime(ceAccMapModel.getStopTime());
			ceAccMap.setUserId(userAccBeanFacade.getRefUserByUserId(ceAccMapModel.getUserId()));
			ceAccMap.setControlEventId(ce);
			ceAccMap.setOptOutFlag(ceAccMapModel.getOptOutFlag());
			ceAccMap.setMissingReadsFlag(OpsCenterConstants.FALSE);
			ceAccMap.setGuiOptOutFlag(OpsCenterConstants.FALSE);
			ceAccMap.setTstatOptOutFlag(OpsCenterConstants.FALSE);
			ceAccMap.setReleasedFlag(OpsCenterConstants.FALSE);
			ceAccMap.setOutOfSyncFlag(OpsCenterConstants.FALSE);
			ceAccMap.setDoNotManageFlag(OpsCenterConstants.FALSE);
			ceAccMap.setLostCommsFlag(OpsCenterConstants.FALSE);
			ceAccMap.setRejectedCeStartRequest(OpsCenterConstants.FALSE);
			ceAccMap.setDutyCycle(ceAccMapModel.getDutyCycle());
			controlEventBeanFacade.createCeAccountMap(ceAccMap);

			// now update CeAccountMapCache
			cacheManager.updateCEAccountMapCache(ceAccMap, ceAccMapModel.getCeGroupMapId(), esiId, ce);

			// Update esiCache with CeAccountMapId
			int ceAccMapId = ceAccMap.getCeAccountMapId();

			logger.debug("Added ceAccMapId=" + ceAccMapId + " to database and cache for ceId=" + ceId);

			ceAccMapModel.setCeAccountMapId(ceAccMapId);

			// now do a put to push cache update to far cache
			String cacheKey = ceAccMapModel.getEsiCacheKey();
			Element esiElement = cacheManager.getGwEsiCache().get(cacheKey);
			EsiCacheData esiCacheData = (EsiCacheData) esiElement.getObjectValue();
			esiCacheData.setCeAccountMapId(ceAccMap.getCeAccountMapId());
			cacheManager.getGwEsiCache().put(esiElement);
			// the mode of GS devices is managed at the device level, so check
			// here for VPP and dont set mode if = GS
			// @JPN- do we need to update the manage mode for the ESI here since
			// we do this on the next reading
			// as well as on the set mode response from the device? A: This
			// isn't needed. Removing this code...
			// if
			// (esiCacheData.getNwType().equals(OpsCenterConstants.VERIZON_CELLULAR_DELIVERY))
			// {
			// esiBeanFacade.updateEsiManageModes(esiCacheData.getEsiId(),
			// esiBeanFacade
			// .getRefManageModeByManageModeId(OpsCenterConstants.ESI_MODE_CONTROL));
			// }
			clearCount++;
			if (clearCount > BATCH_SIZE_FLUSH)
			{
				clearCount = 0;
				controlEventBeanFacade.flush();

			}

		}

		clearCount = 0;

		ControlEvent cevent = controlEventBeanFacade.getRefControlEventByControlEventId(ceId);
		for (int esiId : esiList)
		{

			controlEventPowerBean.addEsiCELog(esiId, cevent);
			clearCount++;
			if (clearCount > BATCH_SIZE_FLUSH)
			{
				clearCount = 0;
				controlEventBeanFacade.flush();
			}
		}
		controlEventBeanFacade.flush();

		List<Integer> esiRunList = new ArrayList<Integer>();
		for (int esiId : esiList)
		{
			esiRunList.add(esiId);

			if ((BATCH_SIZE_ESI / 2) < esiRunList.size())
			{
				controlEventPowerBean.addAllDevicesToCEFromEsiList(ce.getControlEventId(), esiRunList, esiToAcctMapModel, deviceNameList, TenantContext.getCurrentTenant());
				esiRunList = new ArrayList<Integer>();
			}

		}

		if (0 < esiRunList.size())
		{
			controlEventPowerBean.addAllDevicesToCEFromEsiList(ce.getControlEventId(), esiRunList, esiToAcctMapModel, deviceNameList, TenantContext.getCurrentTenant());

		}

		// We need to flush the CE_ACCOUNT_MAP entries to the DB before we try
		// to insert the CE_DEVICES

	}

	@Override
	public CeDevicesLogData addTheDevices(Result result, String devType, ControlEvent cevent, int esiId, char virtualFlag,
			Map<Integer, CeAccountMapModel> esiToAcctMapModel, Collection<String> deviceNameList)
	{

		CeDevicesLogData ceDevicesLogData = null;
		// New check - Don't add non-virtual HVAC, b/c it never consumes power
		if (OpsCenterConstants.DC_HVAC.equals(devType) && OpsCenterConstants.FALSE.charAt(0) == virtualFlag)
		{
			return null;
		}
		DateTime currentTime = new DateTime();

		if (deviceNameList.contains(devType))
		{

			CeAccountMapModel ceAccountMapModel = esiToAcctMapModel.get(esiId);
			CeAccountMap ceAcctMap = controlEventBeanFacade.getRefCeAccountMapByCeAccountMapId(ceAccountMapModel.getCeAccountMapId());
			try
			{
				ceDevicesLogData = controlEventPowerBean.addDeviceToCE(result, ceAcctMap, esiId, cevent, ceAccountMapModel.getCeGroupMapId(),
						ceAccountMapModel.getStartTime(), currentTime);
			} catch (AbstractOpsCenterException e)
			{
				logger.error("Unable to add device to CE", e);
			}
		}

		return ceDevicesLogData;
	}

	@Override
	@Asynchronous
	public void addAllDevicesToCEFromEsiList(int ceId, List<Integer> esiList, Map<Integer, CeAccountMapModel> esiToAcctMapModel,
			Collection<String> deviceNameList, Integer tenantId)
	{
		// now create CeGroupPower data for every DC in this list of ESIs
		logger.warn("Querying for DCs in CE");
		TenantContext.setCurrentTenant(tenantId);

		final Results dcResults = cacheManager.getAllCacheByEsiIdList(cacheManager.getGwDCCache(), esiList);

		logger.warn("dcResults size= " + dcResults.size());

		ControlEvent cevent = controlEventBeanFacade.getRefControlEventByControlEventId(ceId);

		addDevicesToCE(dcResults, cevent, esiToAcctMapModel, deviceNameList);

	}

	@Override
	public void addDevicesToCE(Results dcResults, ControlEvent cevent, Map<Integer, CeAccountMapModel> esiToAcctMapModel, Collection<String> deviceNameList)
	{
		// first cycle thru legacy DC values in cache
		Cache ceDevCache = cacheManager.getCeDevCache();
		EsiDcCacheData dcCache = null;
		int clearCount = 0;
		Map<Integer, Integer> esiDcToEsi = new HashMap<Integer, Integer>();
		List<CeDevicesLog> ceDevicesList = new ArrayList<CeDevicesLog>();
		for (Result esiDc : dcResults.all())
		{
			dcCache = (EsiDcCacheData) esiDc.getValue();
			if (dcCache == null || isDevInCE(dcCache, ceDevCache))
			{
				continue;
			}
			logger.debug("addDevicesToCE" + dcCache.getEsiId() + "before checking the property for DM ");
			String isBlcokPCCEPropertyEnabled = genericBean.getUtilityPropertyByKeyOrProperty(OpsCenterConstants.BLOCK_PC_CE_IF_DM_ENABLED);	
			logger.debug("addDevicesToCE" + dcCache.getEsiId() + "isDMEnabled = " + isDMEnabled);
			if(isDMEnabled.equals("Y"))
			{
				if(dcCache.getDeviceMacId() != 0 && demandManagerBeanLocal.isDeviceAssociatedWithDM(dcCache.getDeviceMacId()))
				{
					continue;
				}
			}
			logger.debug("adding ESI" + dcCache.getEsiId() + "for esiDcId = " + dcCache.getEsiDcId());
			// only add devices which are indeed in a CE
			esiDcToEsi.put(dcCache.getEsiDcId(), dcCache.getEsiId());
			if (dcCache.getDeviceMacId() != 0 && dcCache.getCeId() != 0 || dcCache.getDeviceMacId() == 0)
			{
				CeDevicesLogData ceDevicesLogData = controlEventPowerBean.addTheDevices(esiDc, dcCache.getDeviceType(), cevent, dcCache.getEsiId(),
						dcCache.getVirtualFlag(), esiToAcctMapModel, deviceNameList);

				if (null != ceDevicesLogData)
				{
					// we must now create the entity since we are now managed by
					// the session bean
					CeDevicesLog ceLog = new CeDevicesLog();
					ceLog.setControlEventId(ceDevicesLogData.getControlEventId());
					ceLog.setDateCreated(ceDevicesLogData.getDateCreated());
					ceLog.setCeDevicesId(ceDevicesLogData.getCeDevicesId());
					ceLog.setLogMessage(ceDevicesLogData.getLogMessage());
					final CeEsiStatus ceEsiStatusId = entityManager.getReference(CeEsiStatus.class,
							OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.IN_PROGRESS).intValue());

					ceLog.setCeEsiStatusId(ceEsiStatusId);

					ceDevicesList.add(ceLog);
				}
			}

			clearCount++;

			if (clearCount > BATCH_SIZE_FLUSH)
			{

				controlEventBeanFacade.persistCeDevicesList(ceDevicesList);
				for (CeDevicesLog ceDeviceLog : ceDevicesList)
				{
					controlEventPowerBean.updateCeDevicesCache(ceDeviceLog, esiToAcctMapModel, cevent, esiDcToEsi);
				}

				ceDevicesList = new ArrayList<CeDevicesLog>();
				clearCount = 0;

			}
		}

		if (ceDevicesList.size() > 0)
		{
			controlEventBeanFacade.persistCeDevicesList(ceDevicesList);
			for (CeDevicesLog ceDeviceLog : ceDevicesList)
			{
				controlEventPowerBean.updateCeDevicesCache(ceDeviceLog, esiToAcctMapModel, cevent, esiDcToEsi);
			}

		}
		dcResults.discard();
	}

	@Override
	public void updateCeDevicesCache(CeDevicesLog ceDeviceLog, Map<Integer, CeAccountMapModel> esiToAcctMapModel, ControlEvent cevent,
			Map<Integer, Integer> esiDcToEsi)
	{

		CeDevices ceDev = ceDeviceLog.getCeDevicesId();
		Integer esiId = esiDcToEsi.get(ceDev.getEsiDcId().getEsiDcId());
		CeAccountMapModel ceAccountMapModel = esiToAcctMapModel.get(esiId);
		int ceGroupMapId = ceAccountMapModel.getCeGroupMapId();
		try
		{
			cacheManager.updateCEDevicesCache(ceDev, cevent.getControlEventId(), ceGroupMapId);
		} catch (AbstractOpsCenterException e)
		{
			logger.error("Unable to update CEDevicesCache , exiting ...");
		}

	}

	@Override
	public void addEsiCELog(int esiId, ControlEvent ce)
	{
		Esi esi = esiBeanFacade.getRefEsiByEsiId(esiId);
		// now add ESI log
		CeEsiLog ceEsiLog = new CeEsiLog();
		ceEsiLog.setControlEventId(ce);
		ceEsiLog.setDateCreated(new DateTime());
		ceEsiLog.setEsiId(esi);
		ceEsiLog.setLogMessage("Gateway has been added to the " + OpsCenterConstants.CE_NAME);
		CeEsiStatus ceEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.IN_PROGRESS).intValue());
		ceEsiLog.setCeEsiStatusId(ceEsiStatusId);

		controlEventBeanFacade.createCeEsiLog(ceEsiLog);

	}

	/**
	 * @throws AbstractOpsCenterException
	 */
	private GroupPowerGatewayData addDeviceClassesToRunningCe(Collection<String> deviceClassList, CeGroupMap grpMap, GroupPowerGatewayData grpPowerData,
			DateTime startTime, int userId) throws AbstractOpsCenterException
	{
		int reqGrpId = grpMap.getCeGroupId().getCeGroupId();
		double powerRemoved = grpPowerData.getGrpPowerRemoved();
		ControlEvent ce = grpMap.getControlEventId();
		DeviceClassPowerData dcPower = determineDeviceClassPower(ce.getControlEventId(), reqGrpId, deviceClassList);

		if (dcPower == null)
		{
			return grpPowerData;
		}
		// Added for Wifi Tstat
		// Getting HoneywellEnabled Property from Cache reducing DB hit
		ControlEventCacheData ceControlEventCacheData = null;
		String strHoneywellEnabled = null;
		Results ceControlEventCache = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(), ce.getControlEventId());
		if (ceControlEventCache == null || ceControlEventCache.size() == 0)
		{
			logger.error("ControlEventPowerBean:addDevicesToCyclingCE ControlEvent cache is null");
		}
		for (Result ceResult : ceControlEventCache.all())
		{
			ceControlEventCacheData = (ControlEventCacheData) ceResult.getValue();
			strHoneywellEnabled = ceControlEventCacheData.getStrHoneywellEnabled();
		}
		logger.info("ControlEventBean:addDevicesToCyclingCE:The Honeywell enableddd is" + strHoneywellEnabled);
		logger.info("The DeviceClassList size before is" + dcPower.getDevClassList().size());
		boolean bThirdPartyDeviceType=false;
		if (strHoneywellEnabled != null && strHoneywellEnabled.equalsIgnoreCase("Y") && dcPower.getDevClassList() != null)
		{
			for (String deviceType : dcPower.getDevClassList())
			{
				if (deviceType.equalsIgnoreCase(OpsCenterConstants.HVAC))
				{
					bThirdPartyDeviceType=true;
					logger.debug("The ThirdPartyDeviceType is"+bThirdPartyDeviceType);
				}
			}
			if(bThirdPartyDeviceType)
			{
				dcPower.getDevClassList().add(OpsCenterConstants.THIRD_PARTY_TSTAT);
			}
			logger.info("The DeviceClassList size after is" + dcPower.getDevClassList().size());
		}

		logger.warn("For CeGroup, Adding device classes = " + grpMap.getCeGroupId().getName() + "\t" + deviceClassList);

		List<Integer> esiList = new ArrayList<Integer>();
		Map<Integer, CeAccountMapModel> esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();

		Results ceAcctMapResults = cacheManager.getCacheDataControlEventIdAndGrpid(cacheManager.getCeAccMapCache(), ce.getControlEventId(), grpMap
				.getCeGroupId().getCeGroupId());
		for (Result result : ceAcctMapResults.all())
		{
			CEAccountMapCacheData ceAcctMapCacheData = (CEAccountMapCacheData) result.getValue();
			if (ceAcctMapCacheData == null)
			{
				continue;
			}

			esiList.add(ceAcctMapCacheData.getEsiId());
			CeAccountMapModel ceAccountMapModel = new CeAccountMapModel();
			ceAccountMapModel.setCeAccountMapId(ceAcctMapCacheData.getCeAccMapId());
			ceAccountMapModel.setCeGroupMapId(ceAcctMapCacheData.getCeGroupMapId());
			ceAccountMapModel.setStartTime(startTime);
			ceAccountMapModel.setDutyCycle(ceAcctMapCacheData.getDutyCycle());

			esiToAcctMapModel.put(ceAcctMapCacheData.getEsiId(), ceAccountMapModel);

			if (esiList.size() >= BATCH_SIZE_ESI)
			{
				try
				{
					powerRemoved += addDeviceClassesToRunningCe(ce, grpPowerData, dcPower, esiList, esiToAcctMapModel);
				} catch (Exception e)
				{
					logger.error("Unable to schedule work against ControlEventAuxThread = ", e);
					return grpPowerData;
				}

				esiList = new ArrayList<Integer>();
				esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();
			}
		}
		if (!esiList.isEmpty())
		{
			try
			{
				powerRemoved += addDeviceClassesToRunningCe(ce, grpPowerData, dcPower, esiList, esiToAcctMapModel);
			} catch (Exception e)
			{
				logger.error("Unable to schedule work against ControlEventAuxThread = ", e);
				return grpPowerData;
			}
		}

		ceAcctMapResults.discard();
		grpPowerData.setGrpPowerRemoved(powerRemoved);
		return grpPowerData;
	}

	/**
	 * @param ce
	 * @param grpPowerData
	 * @param dcPower
	 * @param wm
	 * @param esiList
	 * @param esiToAcctMapModel
	 * @param powerRemoved
	 * @return
	 */
	private double addDeviceClassesToRunningCe(ControlEvent ce, GroupPowerGatewayData grpPowerData, DeviceClassPowerData dcPower, List<Integer> esiList,
			Map<Integer, CeAccountMapModel> esiToAcctMapModel) throws Exception
	{
		double powerRemoved = 0;
		Results esiAvail = cacheManager.getAllCacheByEsiIdList(cacheManager.getGwEsiCache(), esiList);
		logger.warn("esiAvail size= " + esiAvail.size());

		for (Result esiA : esiAvail.all())
		{
			EsiCacheData esiCacheData = (EsiCacheData) esiA.getValue();
			if (esiCacheData == null)
			{
				continue;
			}
			double esiPwrAvail = 0.0;

			double targetedPwrAtEsi = computeEsiDcPower(esiCacheData, dcPower);
			logger.debug("Adding new device classes for ESI to CE now, ESI=" + esiCacheData.getEsiId() + " & powerRemoved=" + targetedPwrAtEsi);

			if (OpsCenterConstants.TRUE.equals(ce.getCycling()))
			{
				esiCacheData.setActEnergyAvail(esiPwrAvail);
				logger.debug("Adding pwr to Cycling evt=" + esiCacheData.getEsiId() + " & powerRemoved=" + targetedPwrAtEsi);

			}
			else
			{
				powerRemoved = powerRemoved + targetedPwrAtEsi;

				// 3.1 - Power can still be available to this CE if not all
				// device classes were added
				esiPwrAvail = Math.max(esiCacheData.getActEnergyAvail() - targetedPwrAtEsi, 0.0);
				esiCacheData.setActEnergyAvail(esiPwrAvail);
			}

			// do the put for far cache update
			Element ele = new Element(esiCacheData.getCacheKey(), esiCacheData);
			cacheManager.getGwEsiCache().put(ele);
		}
		esiAvail.discard();

		// Writes the ce_devices & ce_devices_log db entries
		controlEventPowerBean.addAllDevicesToCEFromEsiList(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList(), TenantContext.getCurrentTenant());
		logger.warn("Just added ESI size = " + esiList.size());

		return powerRemoved;
	}

	private boolean isDevInCE(EsiDcCacheData dcCacheData, Cache ceCache)
	{

		boolean result = false;
		CEDevicesCacheData ceDevCache = null;
		if (dcCacheData.getCeId() != 0)
		{
			Results ceDevList = getCacheDataByCeIdV2(ceCache, dcCacheData.getCeId());

			for (Result ceDev : ceDevList.all())
			{
				ceDevCache = (CEDevicesCacheData) ceDev.getValue();
				// if there is an entry in ceDevicesCache, then this dc is in
				// this evt or perhaps has opted-out
				// of this evt, so return true;
				if (ceDevCache != null && ceDevCache.getEsiDcId() == dcCacheData.getEsiDcId())
				{
					result = true;
					break;
				}
			}
		}
		return result;
	}

	/**
	 * @param grpMap
	 * @param grpPowerData
	 * @param startTime
	 * @param userId
	 * @param nGws
	 * @param grpAccIdList
	 * @param esiToAcctMapModel
	 * @param esiCount
	 * @return
	 */
	private GroupPowerGatewayData determineGsDcPowerVPP(CeGroupMap grpMap, GroupPowerGatewayData grpPowerData, DateTime startTime, int userId, int nGws,
			List<Integer> grpAccIdList, Map<Integer, CeAccountMapModel> esiToAcctMapModel, int esiCount, boolean isWifiThirdPartyGroup)
	{
		logger.info("ControlEventPowerBean:determineGsDcPowerVPP Start");

		int reqGrpId = grpMap.getCeGroupId().getCeGroupId();
		@SuppressWarnings("unused")
		DateTime currTime = new DateTime();
		double powerRemoved = grpPowerData.getGrpPowerRemoved();
		List<Integer> esiList = new ArrayList<Integer>();

		ControlEvent ce = grpMap.getControlEventId();
		Collection<String> deviceClassList = getDeviceClass(ce);
		DeviceClassPowerData dcPower = determineDeviceClassPower(ce.getControlEventId(), reqGrpId, deviceClassList);

		if (dcPower == null && !isWifiThirdPartyGroup)
		{
			return grpPowerData;
		}
		logger.debug("ControlEventPowerBean:determineGsDcPowerVPP After DCPower");
		String strHoneywellEnabled = genericBean.getUtilityPropertyByKeyOrProperty(OpsCenterConstants.HONEYWELL_ENABLED);
		logger.debug("ControlEventPowerBean:addDevicesToCe:The Honeywell enableddd is" + strHoneywellEnabled);
		logger.debug("The DeviceClassList size before is" + dcPower.getDevClassList().size());
		boolean bThirdPartyDeviceType=false;
		if (strHoneywellEnabled != null && strHoneywellEnabled.equalsIgnoreCase("Y") && dcPower.getDevClassList() != null)
		{
			for (String deviceType : dcPower.getDevClassList())
			{
				if (deviceType.equalsIgnoreCase(OpsCenterConstants.DC_HVAC))
				{
					
					bThirdPartyDeviceType=true;
					logger.debug("The ThirdPartyDeviceType is"+bThirdPartyDeviceType);
				}
			}
			if(bThirdPartyDeviceType)
			{
				dcPower.getDevClassList().add(OpsCenterConstants.THIRD_PARTY_TSTAT);
			}
			logger.debug("The DeviceClassList size after is" + dcPower.getDevClassList().size());
		}

		// double tempGrpPwrToRemove = grpMap.getPowerToRemove();
		// Get PowerToRemove from grpPowerData b/c that handles edit and opt out
		double tempGrpPwrToRemove = grpPowerData.getGrpPowerToRemove();

		logger.warn("Starting to search for power determineGsDcPower, grpPowerToRemove = " + tempGrpPwrToRemove);

		// Added for Wifi Tstats as it gets all the devices which are not
		// consuming power
		logger.debug("The WifiEnabled is" + isWifiThirdPartyGroup);
		Results dcAvail = null;
		// Gets all the devices even if they are not consuming power
		if (isWifiThirdPartyGroup)
		{
			dcAvail = cacheManager.getAllCacheDataDcModeAndAccId(cacheManager.getGwDCCache(), grpAccIdList);
		}
		// Non cycling events need devices that are consuming power.
		else
		{
			dcAvail = cacheManager.getAllCacheDataActEnergyConsumedAndDcModeAndAccId(cacheManager.getGwDCCache(), grpAccIdList);
		}
		logger.warn("dcAvail size= " + dcAvail.size());

		if (grpPowerData.isGatheringNewlyAddedEsis())
		{
			// Needed for replace power for opt-out
			if (null == grpPowerData.getNewEsiCacheDataList() || grpPowerData.getNewEsiCacheDataList().isEmpty())
			{
				ArrayList<EsiCacheData> newEsiCacheDataList = new ArrayList<EsiCacheData>();
				grpPowerData.setNewEsiCacheDataList(newEsiCacheDataList);

			}

		}

		Map<Integer, AccumulateDcPower> dcPowerMap = new HashMap<Integer, AccumulateDcPower>();
		Cache esiCache = cacheManager.getGwEsiCache();
		Map<Integer, EsiCacheData> esiIdToEsiMap = getEsiIdToEsiMap(esiCache);

		EsiCacheData esiCacheData = null;
		Cache ceDevCache = cacheManager.getCeDevCache();
        boolean bAllowDevice=false;
		for (Result dc : dcAvail.all())
		{
			EsiDcCacheData dcCacheData = (EsiDcCacheData) dc.getValue();
			if (dcCacheData == null)
			{
				logger.debug("Result returned a null dcCacheData for group = " + reqGrpId);
				continue;
			}
			logger.debug("esiDcId looking for CE =  = " + dcCacheData.getEsiDcId());

			// this should always return just one esi
			// Results esiL =
			// cacheManager.getCacheDataByEsiId(cacheManager.getGwEsiCache(),
			// dcCacheData.getEsiId());
			// if (esiL == null || esiL.size() <= 0)
			// {
			// logger.error("no ESI found in cache for dcId = " +
			// dcCacheData.getEsiDcId()
			// + " no power avail, get next dcId");
			// continue;
			// }
			// there should only be one entry in this Result list
			// here we get tricky-- add the esi to cache so downstream code can
			// start the event--but
			// downstream code will find the tstats/lcs devices and msg those
			// only--not ESI
			// for (Result esi : esiL.all())
			// {
			// esiCacheData = (EsiCacheData) esi.getValue();
			// }
			esiCacheData = esiIdToEsiMap.get(dcCacheData.getEsiId());
			// Added for Wifi Tstat
			String strDeviceType = dcCacheData.getDeviceType();
			boolean bWifiTsat = false;
			bAllowDevice=false;
			// Only include the devices selected in the UI
			if(dcPower.getDevClassList().contains(strDeviceType))
			{
				bAllowDevice=true;
			}
			logger.debug("The Allowdevice is"+bAllowDevice);
			if (strDeviceType.equalsIgnoreCase(OpsCenterConstants.THIRD_PARTY_TSTAT))
			{
				bWifiTsat = true;
			}

			if (esiCacheData == null)
			{
				logger.error("esiCacheData returned null in determineGsDcPower()");
				continue;
			}

			// Set duty cycle for to zero for VPP events
			esiCacheData.setDutyCycle(0);

			logger.debug("Esi for this DC  =  = " + esiCacheData.getEsiId());
			// @SuppressWarnings("unused")
			// GridStreamTstatCacheData tstatCache = null;
			// now find the TSTAT for the RMM DC
			// Results dcResult = cacheManager.getCacheDataForGSDevices(
			// cacheManager.getGsTstatCache(), dcCacheData.getDeviceMacId());
			// for (Result resVal : dcResult.all())
			// {
			// tstatCache = (GridStreamTstatCacheData) resVal.getValue();
			// }
			// now lets fetch ceDevices to see if any of these devices have
			// already opted out of this event--
			// if so they are not candidates to include here

			boolean inCe = isDevInCE(dcCacheData, ceDevCache);

			double targetedPwrAtDc = computeDcPower(dcCacheData, dcPower);
			logger.debug("Found a GS DC to add to CE, dcId = " + dcCacheData.getEsiDcId() + "dcMode = " + dcCacheData.getDcMode() + ", power = "
					+ targetedPwrAtDc + ", dcLastRecTime = " + new DateTime(dcCacheData.getReadingTime()));
			logger.debug("determineGsDcPowerVPP inCe for esi dc " + dcCacheData.getEsiDcId() + " = " + inCe + " and dcCacheData.getOptOutFlag() = "
					+ dcCacheData.getOptOutFlag());
			// Modified for Wifi Tstat
			if ((targetedPwrAtDc > 0 || bWifiTsat) && OpsCenterConstants.FALSE.equals(dcCacheData.getOptOutFlag()) && !inCe && bAllowDevice)
			{

				// Reduce tempGrpPwrToRemove by pwrAtEsi, but take care with
				// remainingPowerToRemove b/c tempGrpPwrToRemove -
				// remainingPowerToRemove >= 0
				double remainingPowerToRemove = Math.min(tempGrpPwrToRemove, targetedPwrAtDc);
				tempGrpPwrToRemove = tempGrpPwrToRemove - targetedPwrAtDc;

				logger.debug("Adding DC now esidcId=" + dcCacheData.getEsiDcId() + " & targetedPwrAtDc=" + targetedPwrAtDc);

				// only add ESI here is not already added-- 1 ESI for a GS
				// account(may have multiple devices )

				powerRemoved = powerRemoved + targetedPwrAtDc;

				// 3.1 - Power can still be available to this CE if not all
				// device classes were added
				@SuppressWarnings("unused")
				double dcPwrAvail = Math.max(dcCacheData.getActEnergyAvail() - targetedPwrAtDc, 0.0);

				// now accumulate data for all DCs for each ESI for later use
				// for accountModel creation
				AccumulateDcPower aDcPower = new AccumulateDcPower();
				aDcPower.setRemainPowerToRemove(remainingPowerToRemove);
				aDcPower.setTargetPowerAtDc(targetedPwrAtDc);
				if (dcPowerMap.get(esiCacheData.getEsiId()) == null)
				{
					aDcPower.setTotalDcPowerConsumed(dcCacheData.getActEnergyConsumed());
				}
				else
				{
					aDcPower.setTotalDcPowerConsumed(dcPowerMap.get(esiCacheData.getEsiId()).getTotalDcPowerConsumed() + dcCacheData.getActEnergyConsumed());
				}

				aDcPower.setAccountId(dcCacheData.getAccountId());
				aDcPower.setEsiCache(esiCacheData);
				dcPowerMap.put(esiCacheData.getEsiId(), aDcPower);
				// DEV-934
				// now udate the DC cache so DC does not get added to the same
				// CE again if in another group
				dcCacheData.setCeId(ce.getControlEventId());
				dcCacheData.setDcMode(OpsCenterConstants.ESI_MODE_CONTROL_REQUESTED);
				logger.debug("The Mode of ESI" + dcCacheData.getDcMode());
				dcCacheData.setSendDrlcStart(true);
				Element ele = new Element(dcCacheData.getCacheKey(), dcCacheData);
				cacheManager.getGwDCCache().put(ele);

				if (!esiList.contains(dcCacheData.getEsiId()))
				{
					// should always only be 1 ESI in this list for the current
					// DC in the cache

					ele = new Element(esiCacheData.getCacheKey(), esiCacheData);
					// update cache now - need to update with CEAccountMapId
					// later
					esiCacheData.setCeId(ce.getControlEventId());

					esiList.add(dcCacheData.getEsiId());
					logger.debug("Adding esi to list to start scheduler, esiId = " + dcCacheData.getEsiId());
					esiCount++;
					nGws++;
					if (grpPowerData.getNewEsiCacheDataList() != null)
					{

						grpPowerData.getNewEsiCacheDataList().add(esiCacheData);
						logger.debug("size of newEsiList = " + grpPowerData.getNewEsiCacheDataList().size());
					}
					// must flush esi cache setting to cache now
					cacheManager.getGwEsiCache().put(ele);
				}

				if (esiCount >= BATCH_SIZE_ESI)
				{
					esiCount = 0;
					Set<Integer> esiIds = dcPowerMap.keySet();
					for (Integer esiId : esiIds)
					{

						CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
						ceAccMapModel.setCeGroupId(grpMap.getCeGroupId().getCeGroupId());
						ceAccMapModel.setAccountId(dcPowerMap.get(esiId).getAccountId());
						ceAccMapModel.setInitialPowerRemovable(dcPowerMap.get(esiId).getTargetPowerAtDc());
						ceAccMapModel.setPowerConsumed(dcPowerMap.get(esiId).getTotalDcPowerConsumed());
						ceAccMapModel.setPowerToRemove(dcPowerMap.get(esiId).getRemainPowerToRemove());
						// If this account was added at the start of the CE then
						// this
						// value must equal the CE start time
						ceAccMapModel.setStartTime(startTime);
						ceAccMapModel.setStopTime(null);
						ceAccMapModel.setUserId(userId);
						ceAccMapModel.setControlEventId(ce.getControlEventId());
						ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
						ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
						ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
						ceAccMapModel.setEsiCacheKey(dcPowerMap.get(esiId).getEsiCache().getCacheKey());
						logger.debug("Adding acc to accModel for accId = " + dcPowerMap.get(esiId).getEsiCache().getCacheKey());
						esiToAcctMapModel.put(esiId, ceAccMapModel);
					}

					logger.warn("determineGsDcPowerVPP: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
					addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList());
					esiList = new ArrayList<Integer>();
					esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();
				}
			}
			// if we have taken all of the power to remove, then exit
			// Modified for Wifi Tstat
			if (tempGrpPwrToRemove <= 0.0 && !bWifiTsat)
			{
				logger.warn("tempGrpPwrToRemove <= 0.0, all power taken, exiting loop, nGws= " + nGws);
				break;
			}
		}

		// now check for GS devices to see if we can add
		logger.debug("We have complete power search for GS devices, numOfGW =" + grpPowerData.getNumGws() + " & grp- powerRemoved=" + powerRemoved
				+ ".  Num ESIs: " + esiList.size());
		// now we have gone thru entire ESI list looking for power--we are done
		// have we met the requested power to remove??
		if (esiCount > 0)
		{

			Set<Integer> esiIds = dcPowerMap.keySet();
			for (Integer esiId : esiIds)
			{

				CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
				ceAccMapModel.setCeGroupId(grpMap.getCeGroupId().getCeGroupId());
				ceAccMapModel.setAccountId(dcPowerMap.get(esiId).getAccountId());
				ceAccMapModel.setInitialPowerRemovable(dcPowerMap.get(esiId).getTargetPowerAtDc());
				ceAccMapModel.setPowerConsumed(dcPowerMap.get(esiId).getTotalDcPowerConsumed());
				ceAccMapModel.setPowerToRemove(dcPowerMap.get(esiId).getRemainPowerToRemove());
				// If this account was added at the start of the CE then this
				// value must equal the CE start time
				ceAccMapModel.setStartTime(startTime);
				ceAccMapModel.setStopTime(null);
				ceAccMapModel.setUserId(userId);
				ceAccMapModel.setControlEventId(ce.getControlEventId());
				ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
				ceAccMapModel.setEsiCacheKey(dcPowerMap.get(esiId).getEsiCache().getCacheKey());
				logger.debug("Adding acc to accModel for accId = " + dcPowerMap.get(esiId).getEsiCache().getCacheKey());
				esiToAcctMapModel.put(esiId, ceAccMapModel);
			}

			logger.warn("determineGsDcPowerVPP: Calling separate thread for Num ACC = " + esiList.size());
			addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList());
			// rdrn-341 only set the ce start time on grp when at least 1 esi is
			// in list
			// only call update start time if at least 1 esi is in the CE
			updateCeGroupStartTime(grpMap, ce.getControlEventId());

		}
		dcAvail.discard();

		grpPowerData.setNumGws(nGws);
		grpPowerData.setGrpPowerRemoved(powerRemoved);

		return grpPowerData;
	}

	/**
	 * @param grpMap
	 * @param grpPowerData
	 * @param startTime
	 * @param userId
	 * @param nGws
	 * @param grpAccIdList
	 * @param esiToAcctMapModel
	 * @param esiCount
	 * @return
	 */
	private GroupPowerGatewayData determineGsDcPowerCycling(CeGroupMap grpMap, GroupPowerGatewayData grpPowerData, DateTime startTime, int userId, int nGws,
			List<Integer> grpAccIdList, Map<Integer, CeAccountMapModel> esiToAcctMapModel, List<String> deviceClasses)
	{

		int reqGrpId = grpMap.getCeGroupId().getCeGroupId();
		Map<Integer, EsiCacheData> esiMap = new HashMap<Integer, EsiCacheData>();

		ControlEvent ce = grpMap.getControlEventId();

		// Non cycling events need devices that are consuming power.
		Results dcAvail = cacheManager.getAllCacheDataDcModeAndAccId(cacheManager.getGwDCCache(), grpAccIdList);

		logger.warn("dcAvail size= " + dcAvail.size());

		List<EsiDcCacheData> esiDcForEvent = new ArrayList<EsiDcCacheData>();
		Cache ceDevCache = cacheManager.getCeDevCache();

		for (Result dc : dcAvail.all())
		{
			boolean allowDevice = false;
			EsiDcCacheData dcCacheData = (EsiDcCacheData) dc.getValue();
			if (dcCacheData == null)
			{
				logger.debug("Result returned a null dcCacheData for group = " + reqGrpId);
				continue;
			}

			// DEV-1702 only include the devices selected in the UI
			if (deviceClasses.contains(dcCacheData.getDeviceType()))
			{
				allowDevice = true;
			}

			boolean inCe = isDevInCE(dcCacheData, ceDevCache);
			// this should always return just one esi
			Results esiL = cacheManager.getCacheDataByEsiId(cacheManager.getGwEsiCache(), dcCacheData.getEsiId());
			if (esiL == null || esiL.size() <= 0)
			{
				logger.error("no ESI found in cache for dcId = " + dcCacheData.getEsiDcId() + " no power avail, get next dcId");
				continue;
			}
			// there should only be one entry in this Result list
			// here we get tricky-- add the esi to cache so downstream code can
			// start the event--but
			// downstream code will find the tstats/lcs devices and msg those
			// only--not ESI
			EsiCacheData esiCacheData = null;
			for (Result esi : esiL.all())
			{
				esiCacheData = (EsiCacheData) esi.getValue();
				// when dc for grp = 0xff,then we will use the dev type dc--
				// will be added when msg is sent to devices
				if (grpMap.getDutyCycle() != 0xff)
					esiCacheData.setDutyCycle(grpMap.getDutyCycle());
			}

			// Set duty cycle for cycling events

			if (OpsCenterConstants.FALSE.equals(dcCacheData.getOptOutFlag()) && esiCacheData != null && esiCacheData.getOptOutReason() == null && !inCe
					&& allowDevice)
			{

				// DEV-934
				// now udate the DC cache so DC does not get added to the same
				// CE again if in another group

				dcCacheData.setCeId(ce.getControlEventId());
				// dev-2564 if dev has not sent reading(unknown), dont change
				// mode to ctrl yet--but do add into the CE
				if (dcCacheData.getDcMode() != OpsCenterConstants.ESI_MODE_UNKNOWN)
					dcCacheData.setDcMode(OpsCenterConstants.ESI_MODE_CONTROL_REQUESTED);
				dcCacheData.setSendDrlcStart(true);
				Element ele = new Element(dcCacheData.getCacheKey(), dcCacheData);
				cacheManager.getGwDCCache().put(ele);

				esiDcForEvent.add(dcCacheData);

				// Put the ESI under control in the cache
				if (!esiMap.containsKey(dcCacheData.getEsiId()))
				{
					// should always only be 1 ESI in this list for the current
					// DC in the cache

					ele = new Element(esiCacheData.getCacheKey(), esiCacheData);
					// update cache now - need to update with CEAccountMapId
					// later
					esiCacheData.setCeId(ce.getControlEventId());

					esiMap.put(dcCacheData.getEsiId(), esiCacheData);
					logger.debug("Adding esi to list to start scheduler, esiId = " + dcCacheData.getEsiId());
					nGws++;
					// must flush esi cache setting to cache now
					cacheManager.getGwEsiCache().put(ele);
				}

				if (esiMap.size() >= BATCH_SIZE_ESI)
				{

					for (EsiCacheData esiCacheDataForCe : esiMap.values())
					{

						CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
						ceAccMapModel.setCeGroupId(grpMap.getCeGroupId().getCeGroupId());
						ceAccMapModel.setAccountId(esiCacheDataForCe.getAccountId());
						ceAccMapModel.setInitialPowerRemovable(0);
						ceAccMapModel.setPowerConsumed(0);
						ceAccMapModel.setPowerToRemove(0);
						// If this account was added at the start of the CE then
						// this
						// value must equal the CE start time
						ceAccMapModel.setStartTime(startTime);
						ceAccMapModel.setStopTime(null);
						ceAccMapModel.setUserId(userId);
						ceAccMapModel.setControlEventId(ce.getControlEventId());
						ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
						ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
						ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
						ceAccMapModel.setEsiCacheKey(esiCacheDataForCe.getCacheKey());
						ceAccMapModel.setDutyCycle(grpMap.getDutyCycle());
						esiToAcctMapModel.put(esiCacheDataForCe.getEsiId(), ceAccMapModel);
					}

					// TODO - why are we passing a list and a map when all of
					// the data is already in the map?
					List<Integer> esiList = new ArrayList<Integer>();
					for (int esiId : esiToAcctMapModel.keySet())
					{
						esiList.add(esiId);
					}

					logger.warn("determineGsDcPowerCycling: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
					addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, deviceClasses);

					esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();
					esiMap = new HashMap<Integer, EsiCacheData>();
				}
			}
		}

		// now check for GS devices to see if we can add
		logger.debug("We have complete power search for GS devices, numOfGW =" + grpPowerData.getNumGws() + ".  Num ESIs: " + esiMap.size());
		// now we have gone thru entire ESI list looking for power--we are done
		// have we met the requested power to remove??
		if (esiMap.size() > 0)
		{

			for (EsiCacheData esiCacheDataForCe : esiMap.values())
			{

				CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
				ceAccMapModel.setCeGroupId(grpMap.getCeGroupId().getCeGroupId());
				ceAccMapModel.setAccountId(esiCacheDataForCe.getAccountId());
				ceAccMapModel.setInitialPowerRemovable(0);
				ceAccMapModel.setPowerConsumed(0);
				ceAccMapModel.setPowerToRemove(0);
				// If this account was added at the start of the CE then this
				// value must equal the CE start time
				ceAccMapModel.setStartTime(startTime);
				ceAccMapModel.setStopTime(null);
				ceAccMapModel.setUserId(userId);
				ceAccMapModel.setControlEventId(ce.getControlEventId());
				ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
				ceAccMapModel.setEsiCacheKey(esiCacheDataForCe.getCacheKey());
				ceAccMapModel.setDutyCycle(grpMap.getDutyCycle());

				esiToAcctMapModel.put(esiCacheDataForCe.getEsiId(), ceAccMapModel);
			}

			// TODO - why are we passing a list and a map when all of the data
			// is already in the map?
			List<Integer> esiList = new ArrayList<Integer>();
			for (int esiId : esiToAcctMapModel.keySet())
			{
				esiList.add(esiId);
			}

			logger.warn("determineGsDcPowerCycling: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
			addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, deviceClasses);
			// rdrn-341 only set the ce start time on grp when at least 1 esi is
			// in list
			// only call update start time if at least 1 esi is in the CE
			if (esiMap.size() > 0)

				updateCeGroupStartTime(grpMap, ce.getControlEventId());

		}
		dcAvail.discard();

		grpPowerData.setNumGws(nGws);
		grpPowerData.setGrpPowerRemoved(0);

		return grpPowerData;
	}

	/**
	 * @param grpMap
	 * @param grpPowerData
	 * @param startTime
	 * @param userId
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	private GroupPowerGatewayData addDevicesToCe(CeGroupMap grpMap, GroupPowerGatewayData grpPowerData, DateTime startTime, int userId,
			List<Integer> grpAccIdListGS, boolean isWifiThirdPartyGroup) throws AbstractOpsCenterException
	{

		int reqGrpId = grpMap.getCeGroupId().getCeGroupId();
		DateTime currTime = new DateTime();
		int nGws = grpPowerData.getNumGws();
		double powerRemoved = grpPowerData.getGrpPowerRemoved();

		ControlEvent ce = grpMap.getControlEventId();
		Collection<String> deviceClassList = getDeviceClass(ce);
		DeviceClassPowerData dcPower = determineDeviceClassPower(ce.getControlEventId(), reqGrpId, deviceClassList);

		if (dcPower == null)
		{
			return grpPowerData;
		}
		// double tempGrpPwrToRemove = grpMap.getPowerToRemove();
		// Get PowerToRemove from grpPowerData b/c that handles edit and opt out
		double tempGrpPwrToRemove = grpPowerData.getGrpPowerToRemove();
		logger.warn("Starting to search for power addDevicesToCe, grpPowerToRemove = " + tempGrpPwrToRemove);

		// This returns account ids
		List<Integer> grpAccIdList = controlEventBeanFacade.getActiveCeGroupAccountMapIdListByCeGroupId(reqGrpId,
				OpsCenterConstants.VERIZON_CELLULAR_DELIVERY_ID);
		logger.warn("grpAccIdList size = " + grpAccIdList.size());

		List<Integer> esiList = new ArrayList<Integer>();
		Map<Integer, CeAccountMapModel> esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();

		// Adds ESI until powerToRemove has been met
		logger.warn("Querying for esiAvail, group = " + reqGrpId);
		// Get all the cached data for all ESIs in the group that have power and
		// are in normal mode in RR order
		Results esiAvail = cacheManager.getAllCacheDataActEnergyConsumedAndModeAndAccId(cacheManager.getGwEsiCache(), grpAccIdList);
		int esiCount = 0;
		logger.warn("esiAvail size = " + esiAvail.size());

		ArrayList<EsiCacheData> newEsiCacheDataList = null;
		if (grpPowerData.isGatheringNewlyAddedEsis())
		{
			// Needed for replace power for opt-out
			newEsiCacheDataList = new ArrayList<EsiCacheData>();
			grpPowerData.setNewEsiCacheDataList(newEsiCacheDataList);
		}

		int staleTimeMin = cacheManager.getStaleTimeMin();

		// first these are the VPP ESI, after that we search for GS devices
		for (Result esiA : esiAvail.all())
		{
			EsiCacheData esiCacheData = (EsiCacheData) esiA.getValue();
			if (esiCacheData == null)
			{
				logger.debug("Result returned a null EsiCacheData for group = " + reqGrpId);
				continue;
			}
			double targetedPwrAtEsi = computeEsiDcPower(esiCacheData, dcPower);
			logger.debug("Found an ESI to add to CE, esiId = " + esiCacheData.getEsiId() + ", esiMode = " + esiCacheData.getEsiMode() + ", power = "
					+ targetedPwrAtEsi + ", esiLastMqRecTime = " + esiCacheData.getLastMqRecdTime());
			DateTime temp1 = esiCacheData.getLastMqRecdTime().withSecondOfMinute(0);
			DateTime readingMinutes = temp1.withMillisOfSecond(0);
			DateTime temp2 = currTime.withSecondOfMinute(0);
			DateTime currentMinutes = temp2.withMillisOfSecond(0);
			if (targetedPwrAtEsi > 0 && readingMinutes.getMillis() > currentMinutes.minusMinutes(staleTimeMin).getMillis()
					&& OpsCenterConstants.FALSE.equals(esiCacheData.getOptOutFlag()))
			{

				if (newEsiCacheDataList != null)
				{
					newEsiCacheDataList.add(esiCacheData);
				}
				esiCount++;

				// Reduce tempGrpPwrToRemove by pwrAtEsi, but take care with
				// remainingPowerToRemove b/c tempGrpPwrToRemove -
				// remainingPowerToRemove >= 0
				double remainingPowerToRemove = Math.min(tempGrpPwrToRemove, targetedPwrAtEsi);
				tempGrpPwrToRemove = tempGrpPwrToRemove - targetedPwrAtEsi;

				logger.debug("Adding ESI to CE now, ESI=" + esiCacheData.getEsiId() + " & powerRemoved=" + targetedPwrAtEsi);

				esiList.add(esiCacheData.getEsiId());

				powerRemoved = powerRemoved + targetedPwrAtEsi;

				// 3.1 - Power can still be available to this CE if not all
				// device classes were added
				double esiPwrAvail = Math.max(esiCacheData.getActEnergyAvail() - targetedPwrAtEsi, 0.0);

				// In 3.0, if the ESI was in the CE then no power was available
				// for the entire ESI
				// double esiPwrAvail = 0.0;

				esiCacheData.setActEnergyAvail(esiPwrAvail);

				// update cache now - need to update with CEAccountMapId later
				esiCacheData.setCeId(ce.getControlEventId());
				// set RR = CE id -- this ensures newly provisioned GWs get
				// added in correct order to CE
				// simply incrementing a counter does not work--KRMT-2090
				esiCacheData.setRoundRobinCnt(ce.getControlEventId());
				esiCacheData.setEsiMode(OpsCenterConstants.ESI_MODE_CONTROL_REQUESTED);
				esiCacheData.setFirstReadIdAfterModeChange(0);
				// do the put for far cache update
				Element ele = new Element(esiCacheData.getCacheKey(), esiCacheData); // cacheManager.getGwEsiCache().get(esiCacheData.getCacheKey());
				cacheManager.getGwEsiCache().put(ele);
				nGws++;

				CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
				ceAccMapModel.setCeGroupId(grpMap.getCeGroupId().getCeGroupId());
				ceAccMapModel.setAccountId(esiCacheData.getAccountId());
				ceAccMapModel.setInitialPowerRemovable(targetedPwrAtEsi);
				ceAccMapModel.setPowerConsumed(esiCacheData.getActEnergyConsumed());

				ceAccMapModel.setPowerToRemove(remainingPowerToRemove);
				// If this account was added at the start of the CE then this
				// value must equal the CE start time
				ceAccMapModel.setStartTime(startTime);
				ceAccMapModel.setStopTime(null);
				ceAccMapModel.setUserId(userId);
				ceAccMapModel.setControlEventId(ce.getControlEventId());
				ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
				ceAccMapModel.setEsiCacheKey(esiCacheData.getCacheKey());
				esiToAcctMapModel.put(esiCacheData.getEsiId(), ceAccMapModel);

				if (esiCount >= BATCH_SIZE_ESI)
				{
					esiCount = 0;

					logger.warn("addDevicesToCe: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
					addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList());

					esiList = new ArrayList<Integer>();
					esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();
				}
			}
			// if we have taken all of the power to remove, then exit
			if (tempGrpPwrToRemove <= 0.0)
			{
				logger.warn("tempGrpPwrToRemove <= 0.0, all power taken, exiting loop, nGws= " + nGws);
				break;
			}
		}
		logger.debug("We have complete power search for grp=" + reqGrpId + " & powerRemoved=" + powerRemoved + ".  Num ESIs: " + esiList.size());

		// now we have gone thru entire ESI list looking for power--we are done
		// have we met the requested power to remove??
		if (esiCount > 0)
		{

			logger.warn("addDevicesToCe: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
			addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList());
			// rdrn-341 only set the ce start time on grp when at least 1 esi is
			// in list
			// only call update start time if at least 1 esi is in the CE
			updateCeGroupStartTime(grpMap, ce.getControlEventId());
		}

		esiAvail.discard();

		grpPowerData.setNumGws(nGws);
		grpPowerData.setGrpPowerRemoved(powerRemoved);
		// now check for GS devices to see if we can add
		if (grpAccIdListGS == null)
		{
			grpAccIdListGS = controlEventBeanFacade.getActiveCeGroupAccountMapIdListByCeGroupId(reqGrpId, OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID);
		}
		logger.warn("grpAccIdList size= " + grpAccIdList.size());
		grpPowerData.setNewEsiCacheDataList(newEsiCacheDataList);
		return determineGsDcPowerVPP(grpMap, grpPowerData, startTime, userId, nGws, grpAccIdListGS, esiToAcctMapModel, esiCount, isWifiThirdPartyGroup);

	}

	/**
	 * @throws AbstractOpsCenterException
	 */
	private GroupPowerGatewayData addDevicesToCyclingCE(CeGroupMap grpMap, GroupPowerGatewayData grpPowerData, DateTime startTime, int userId)
			throws AbstractOpsCenterException
	{

		int reqGrpId = grpMap.getCeGroupId().getCeGroupId();
		DateTime currTime = new DateTime();
		int nGws = grpPowerData.getNumGws();

		ControlEvent ce = grpMap.getControlEventId();
		Collection<String> deviceClassList = getDeviceClass(ce);
		DeviceClassPowerData dcPower = determineDeviceClassPower(ce.getControlEventId(), reqGrpId, deviceClassList);
		if (dcPower == null)
		{
			return grpPowerData;
		}
		// Added for Honweywell Devices and added if HoneywellEnabled is true
		// Getting HoneywellEnabled Property from Cache reducing DB hit
		ControlEventCacheData ceControlEventCacheData = null;
		String strHoneywellEnabled = null;
		Results ceControlEventCache = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(), ce.getControlEventId());
		if (ceControlEventCache == null || ceControlEventCache.size() == 0)
		{
			logger.error("ControlEventPowerBean:addDevicesToCyclingCE ControlEvent cache is null");
			return null;
		}
		for (Result ceResult : ceControlEventCache.all())
		{
			ceControlEventCacheData = (ControlEventCacheData) ceResult.getValue();
			strHoneywellEnabled = ceControlEventCacheData.getStrHoneywellEnabled();
		}
		logger.debug("ControlEventBean:addDevicesToCyclingCE:The Honeywell enableddd is" + strHoneywellEnabled);
		logger.debug("The DeviceClassList size before is" + dcPower.getDevClassList().size());
		logger.debug("deviceClassList Before is = " + deviceClassList);
		boolean bThirdPartyDeviceType=false;
		if (strHoneywellEnabled != null && strHoneywellEnabled.equalsIgnoreCase("Y") && dcPower.getDevClassList() != null)
		{
			for (String deviceType : dcPower.getDevClassList())
			{
				
				if (deviceType.equalsIgnoreCase(OpsCenterConstants.DC_HVAC))
				{
					
					bThirdPartyDeviceType=true;
					logger.debug("The ThirdPartyDeviceType is"+bThirdPartyDeviceType);
				}
			}
			if(bThirdPartyDeviceType)
			{
				dcPower.getDevClassList().add(OpsCenterConstants.THIRD_PARTY_TSTAT);
			}
			logger.debug("The DeviceClassList size after is" + dcPower.getDevClassList().size());
		}

		logger.debug("deviceClassList = " + deviceClassList);
		logger.warn("Starting add all devices for every esi in this grp (grpId: " + grpMap.getCeGroupId().getCeGroupId() + "), duty cycle = "
				+ grpMap.getDutyCycle());

		// This returns account ids
		List<Integer> grpAccIdList = controlEventBeanFacade.getActiveCeGroupAccountMapIdListByCeGroupId(reqGrpId,
				OpsCenterConstants.VERIZON_CELLULAR_DELIVERY_ID);
		logger.warn("grpAccIdList size = " + grpAccIdList.size());

		List<Integer> esiList = new ArrayList<Integer>();
		Map<Integer, CeAccountMapModel> esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();

		// Adds All ESIs in grp that are active and state normal
		Results esiAvail = cacheManager.getAllCacheDataAndModeAndAccId(cacheManager.getGwEsiCache(), grpAccIdList);
		int esiCount = 0;
		logger.warn("esiAvail size = " + esiAvail.size());

		ArrayList<EsiCacheData> newEsiCacheDataList = null;
		if (grpPowerData.isGatheringNewlyAddedEsis())
		{
			// Needed for replace power for opt-out
			newEsiCacheDataList = new ArrayList<EsiCacheData>();
			grpPowerData.setNewEsiCacheDataList(newEsiCacheDataList);
		}
		int maxToInclude = esiAvail.all().size() - esiAvail.all().size() / 10;
		int staleTimeMin = cacheManager.getStaleTimeMin();
		for (Result esiA : esiAvail.all())
		{
			EsiCacheData esiCacheData = (EsiCacheData) esiA.getValue();
			if (esiCacheData == null)
			{
				logger.debug("Result returned a null EsiCacheData for group = " + reqGrpId);
				continue;
			}
			DateTime temp1 = esiCacheData.getLastMqRecdTime().withSecondOfMinute(0);
			DateTime readingMinutes = temp1.withMillisOfSecond(0);
			DateTime temp2 = currTime.withSecondOfMinute(0);
			DateTime currentMinutes = temp2.withMillisOfSecond(0);
			if (readingMinutes.getMillis() > currentMinutes.minusMinutes(staleTimeMin).getMillis()
					&& OpsCenterConstants.FALSE.equals(esiCacheData.getOptOutFlag()))
			{
				logger.debug("Found an ESI to add to CE, esiId = " + esiCacheData.getEsiId() + ", esiMode = " + esiCacheData.getEsiMode()
						+ ", esiLastMqRecTime = " + esiCacheData.getLastMqRecdTime());

				if (newEsiCacheDataList != null)
				{
					newEsiCacheDataList.add(esiCacheData);
				}
				if (esiCount > maxToInclude)
				{
					// we must include all but 10% of esi in this grp to leave
					// some in reserve
					// to support opt-out-- 10% is a random value we chose
					break;
				}

				esiCount++;

				logger.debug("Adding ESI to CE now, ESI = " + esiCacheData.getEsiId());

				esiList.add(esiCacheData.getEsiId());

				// update cache now - need to update with CEAccountMapId later
				esiCacheData.setCeId(ce.getControlEventId());
				// set RR = CE id -- this ensures newly provisioned GWs get
				// added in correct order to CE
				// simply incrementing a counter does not work--KRMT-2090
				esiCacheData.setRoundRobinCnt(ce.getControlEventId());
				esiCacheData.setEsiMode(OpsCenterConstants.ESI_MODE_CONTROL_REQUESTED);
				esiCacheData.setFirstReadIdAfterModeChange(0);
				esiCacheData.setDutyCycle(grpMap.getDutyCycle());
				// do the put for far cache update
				Element ele = new Element(esiCacheData.getCacheKey(), esiCacheData);
				cacheManager.getGwEsiCache().put(ele);
				nGws++;

				CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
				ceAccMapModel.setCeGroupId(grpMap.getCeGroupId().getCeGroupId());
				ceAccMapModel.setAccountId(esiCacheData.getAccountId());
				ceAccMapModel.setInitialPowerRemovable(0.0);
				ceAccMapModel.setPowerConsumed(esiCacheData.getActEnergyConsumed());

				ceAccMapModel.setPowerToRemove(0.0);
				// If this account was added at the start of the CE then this
				// value must equal the CE start time
				ceAccMapModel.setStartTime(startTime);
				ceAccMapModel.setStopTime(null);
				ceAccMapModel.setUserId(userId);
				ceAccMapModel.setControlEventId(ce.getControlEventId());
				ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
				ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
				ceAccMapModel.setEsiCacheKey(esiCacheData.getCacheKey());
				ceAccMapModel.setDutyCycle(grpMap.getDutyCycle());

				esiToAcctMapModel.put(esiCacheData.getEsiId(), ceAccMapModel);

				if (esiCount >= BATCH_SIZE_ESI)
				{
					esiCount = 0;
					logger.warn("addDevicesToCyclingCE: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
					addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList());

					esiList = new ArrayList<Integer>();
					esiToAcctMapModel = new HashMap<Integer, CeAccountMapModel>();
				}
			}
		}

		logger.debug("We have add all ESI for grp = " + reqGrpId + ".  Num ESIs: " + esiList.size());

		// now we have gone thru entire ESI list looking for power--we are done
		// have we met the requested power to remove??
		if (esiCount > 0)
		{

			logger.warn("addDevicesToCyclingCE: Calling separate thread for Num ACC = " + esiToAcctMapModel.size());
			addCeAccountMapEntries(ce.getControlEventId(), esiList, esiToAcctMapModel, dcPower.getDevClassList());
			// rdrn-341 only set the ce start time on grp when at least 1 esi is
			// in list
			// only call update start time if at least 1 esi is in the CE
			updateCeGroupStartTime(grpMap, ce.getControlEventId());
		}

		esiAvail.discard();

		grpPowerData.setNumGws(nGws);
		grpPowerData.setGrpPowerRemoved(0.0);

		grpAccIdList = controlEventBeanFacade.getActiveCeGroupAccountMapIdListByCeGroupId(reqGrpId, OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID);
		logger.debug("The GroupAccountList is"+grpAccIdList.size());

		grpPowerData = determineGsDcPowerCycling(grpMap, grpPowerData, startTime, userId, nGws, grpAccIdList, esiToAcctMapModel, dcPower.getDevClassList());

		return grpPowerData;
	}

	private void updateCeGroupStartTime(CeGroupMap grpMap, int ceId)
	{

		// rdrn-341 only set the ce start time on grp when at least 1 esi is in
		// list

		Results results = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpCache(), grpMap.getCeGroupId().getCeGroupId());

		for (Result result : results.all())
		{
			CEGroupCacheData ceGroupCache = (CEGroupCacheData) result.getValue();

			logger.debug("grp passed in grpMap  = " + grpMap.getCeGroupId().getCeGroupId());
			ceGroupCache.setCeId(ceId);

			if (ceGroupCache != null && ceGroupCache.getCeStartTime() == 0)
			{
				// only set start time, when this grp has not been updated

				ceGroupCache.setCeStartTime(new DateTime().getMillis());
				logger.debug("just set ceStart time set = " + new DateTime() + " ceId " + ceId);

			}
			Element grpElement = new Element(ceGroupCache.getCeGrpId(), ceGroupCache);
			cacheManager.getCeGrpCache().put(grpElement);

		}

	}

	private double computeEsiDcPower(EsiCacheData esi, DeviceClassPowerData dcPower)
	{

		double totalActEnergy = 0.0;
		if (dcPower.getDevClassList().isEmpty())
		{
			logger.error("Device class list must contain at least 1 element ");
			return 0.0;
		}
		logger.debug("DevClass entry = " + dcPower.getDevClassList());

		Map<String, Double> energyConsumedByDeviceType = esi.getEnergyConsumedByDeviceType();
		ArrayList<String> devClassList = dcPower.getDevClassList();
		for (String deviceType : devClassList)
		{
			Double consumed = energyConsumedByDeviceType.get(deviceType);
			if (consumed != null)
			{
				totalActEnergy += consumed;
			}
		}

		logger.debug("Complete EsiDc power search, esiId / power found = " + esi.getEsiId() + "/" + totalActEnergy);
		return totalActEnergy;
	}

	private double computeDcPower(EsiDcCacheData esiDc, DeviceClassPowerData dcPower)
	{

		logger.debug("Entering computeDcPower ");

		double totalActEnergy = 0.0;
		if (dcPower.getDevClassList().isEmpty())
		{
			logger.error("Device class list must contain at least 1 element ");
			return 0.0;
		}
		logger.debug("DevClass entry = " + dcPower.getDevClassList());
		ArrayList<String> devClassList = dcPower.getDevClassList();
		for (String deviceType : devClassList)
		{
			if (deviceType.equals(esiDc.getDeviceType()))
			{
				Double consumed = esiDc.getActEnergyConsumed();
				if (consumed != null)
				{
					totalActEnergy += consumed;
				}
				logger.debug("found esiDc power for dev type =  " + esiDc.getDeviceType());

			}
		}

		logger.debug("Complete EsiDc power search, esiId / power found = " + esiDc.getEsiDcId() + " / " + totalActEnergy);
		return totalActEnergy;
	}

	private DeviceClassPowerData determineDeviceClassPower(int ceId, int reqGrpId, Collection<String> devClassList)
	{
		logger.info("[ENTER] DeviceClassPowerData ControlEventPowerBean.determineDeviceClassPower(ceId = " + ceId + ", reqGrpId = " + reqGrpId
				+ ", devClassList = " + devClassList);

		// find out if this event is duty cycle by device type or by group
		Set<String> dutyCycleByDeviceType = checkForDutyCycleByDeviceType(ceId);
		logger.debug("dutyCycleByDeviceTypeeee : " + dutyCycleByDeviceType);

		ArrayList<String> devTypeList = new ArrayList<String>();
		DeviceClassPowerData devC = new DeviceClassPowerData();

		if (dutyCycleByDeviceType == null || dutyCycleByDeviceType.isEmpty())
		{
			logger.info("Inside dutyCycleByDeviceType is Null");
			/*
			 * For Duty Cycle By Group Events and VPP Events
			 */
			Results ceGrpPowerResults = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpPowerCache(), reqGrpId);
			logger.info("The CeGrpPowerResults" + ceGrpPowerResults);

			for (Result result : ceGrpPowerResults.all())
			{
				CEGroupPowerCacheData ceGroupPowerCache = (CEGroupPowerCacheData) result.getValue();
				String devType = ceGroupPowerCache.getDevType();
				logger.info("The Devtype is" + devType);
				boolean add = false;
				if (OpsCenterConstants.DC_HVAC.equals(devType) && devClassList.contains(OpsCenterConstants.HVAC))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_WATER_HEATER.equals(devType) && devClassList.contains(OpsCenterConstants.WH))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_POOL_PUMP.equals(devType) && devClassList.contains(OpsCenterConstants.PP))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_HVAC_SWITCH.equals(devType) && devClassList.contains(OpsCenterConstants.HS))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_SINGLE_HEAT.equals(devType) && devClassList.contains(OpsCenterConstants.SH))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_DUAL_HEAT.equals(devType) && devClassList.contains(OpsCenterConstants.DH))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_EV_CHARGER.equals(devType) && devClassList.contains(OpsCenterConstants.EV))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_IRRIGATION_PUMP.equals(devType) && devClassList.contains(OpsCenterConstants.IP))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_CROP_HEAT.equals(devType) && devClassList.contains(OpsCenterConstants.CH))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_GENERATOR.equals(devType) && devClassList.contains(OpsCenterConstants.GEN))
				{
					add = true;
				}
				else if (OpsCenterConstants.THIRD_PARTY_TSTAT.equals(devType) && devClassList.contains(OpsCenterConstants.HVAC))
				{
					add = true;
				}
				if (add)
				{
					devTypeList.add(devType);
					logger.debug("Found device class = " + devType);
				}
			}
		}
		else
		{
			/*
			 * If dutyCycleByDeviceType has any elements, this is for Duty Cycle
			 * By Device Type Disregard deviceTypes in devClassList
			 */

			devTypeList = new ArrayList<String>(dutyCycleByDeviceType);
		}

		devC.setDevClassList(devTypeList);

		logger.debug("devC.devClassList : " + devC.getDevClassList());

		logger.info("[ EXIT] ControlEventPowerBean.determineDeviceClassPower");

		return devC;
	}

	/**
	 * @throws AbstractOpsCenterException
	 */
	@Override
	public CeDevicesLogData addDeviceToCE(Result cache, CeAccountMap ceAccountMap, int esiId, ControlEvent ce, int ceGroupMapId, DateTime startTime,
			DateTime currTime) throws AbstractOpsCenterException
	{

		EsiDcCacheData dCache = null;
		int esiDcId = 0;
		double actEnergy = 0.0;
		String devType = "";

		if (cache.getValue() instanceof EsiDcCacheData)
		{

			dCache = (EsiDcCacheData) cache.getValue();
			esiDcId = dCache.getEsiDcId();
			devType = dCache.getDeviceType();
			actEnergy = dCache.getActEnergyConsumed();
			// now reduce power avail for ea DC in ESI
			dCache.setActEnergyAvail(0.0);
			// DEV-2564-- at startup if no readings have landed, then do not set
			// mode to control
			if (dCache.getDcMode() != OpsCenterConstants.ESI_MODE_UNKNOWN)
				dCache.setDcMode(OpsCenterConstants.ESI_MODE_CONTROL_REQUESTED);
			// update cache now - need to update with CEAccountMapId later
			dCache.setCeId(ce.getControlEventId());
			// set RR = CE id -- this ensures newly provisioned GWs get added in
			// correct order to CE
			// simply incrementing a counter does not work--KRMT-2090
			dCache.setRoundRobinCnt(ce.getControlEventId());
			// do the put for far cache update
			logger.debug("found DC instance(legacy or GS rmm device)--devType, actEnergy, esiDcId = " + devType + " " + actEnergy + " " + esiDcId);
			// this is required to support --readding of devices into a CE--
			// for BroadCast signalling, since individual messages to each dev
			// is not sent
			dCache.setDrlcStartTime(startTime.getMillis());

		}
		CeDevices ceDev = new CeDevices();
		// account Id search should only return 1 entry in ceAccMapList
		logger.debug("stuffing ce_account_map into ceDevices for esiDcId =  " + ceAccountMap.getCeAccountMapId() + "/" + esiDcId);

		ceDev.setCeAccountMapId(ceAccountMap);
		// ceDev.setEsiDcId(esiBeanFacade.findEsiDcByEsiDcId(dCache.getEsiDcId()));
		ceDev.setEsiDcId(esiBeanFacade.getRefEsiDcByEsiDcId(esiDcId));
		ceDev.setDriftPowerConsumed(0.0);
		// If this device has not drifted, then their is code that exists that
		// expects this value to be null
		// ceDev.setDriftTime(OpsCenterConstants.REALLY_LONG_AGO_DATETIME);
		ceDev.setInitialPowerRemovable(actEnergy);
		ceDev.setDeviceTypeId(OpsCenterConstants.deviceNameToTypeMap.get(devType).intValue());
		// This is used for calculations, so prefer it to be exactly the same as
		// CE Start Time, if this is created when the CE starts
		ceDev.setStartTime(startTime);
		ceDev.setIndividualTstatOptOutFlag(OpsCenterConstants.FALSE);
		ceDev.setInvalidReadsFlag(OpsCenterConstants.FALSE);
		ceDev.setDriftFlag(OpsCenterConstants.FALSE);
		ceDev.setLostCommsFlag(OpsCenterConstants.FALSE);
		ceDev.setOutOfSyncFlag(OpsCenterConstants.FALSE);
		ceDev.setRejectedCeStartRequest(OpsCenterConstants.FALSE);
		ceDev.setTstatOptOutFlag(OpsCenterConstants.FALSE);
		ceDev.setReleasedFlag(OpsCenterConstants.FALSE);
		// controlEventBeanFacade.createCeDevices(ceDev);

		logger.debug("Added CeDev entries for ESI = " + esiId);
		// now add Devices log
		CeDevicesLogData ceDevicesData = new CeDevicesLogData();
		ceDevicesData.setControlEventId(ce);
		ceDevicesData.setDateCreated(currTime);
		ceDevicesData.setCeDevicesId(ceDev);
		ceDevicesData.setLogMessage("Device " + devType + " has been added to the " + OpsCenterConstants.CE_NAME);

		Element element = null;
		if (cache.getValue() instanceof EsiDcCacheData)
		{
			if (dCache != null)
			{
				element = new Element(dCache.getCacheKey(), dCache); // cacheManager.getGwDCCache().get(dcCache.getCacheKey());
			}
			cacheManager.getGwDCCache().put(element);
		}
		logger.debug("Added CeDevices table to DB for DC, esiDcId / energyAvail = " + esiDcId + " " + actEnergy);
		return ceDevicesData;
	}

	@Override
	public ControlEventSummaryCountModel getControlEventSummaryCounts(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return controlEventBeanFacade.getControlEventCounts();
	}

	@Override
	public List<ControlEventModel> getCurrentControlEvents(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<ControlEvent> controlEventList;

		// This method is only to be used to get the current control event
		// model.
		// The calculations for power removed, avg power removed, and number of
		// gw/opt outs are not mapped to the model for performance reasons.

		Map<Integer, Double> powerRemovedByControlEventId = new HashMap<Integer, Double>();
		Map<Integer, Double> avgPowerRemovedByControlEventId = new HashMap<Integer, Double>();
		Map<Integer, int[]> numGwsAndOptOutsByControlEventId = new HashMap<Integer, int[]>();

		controlEventList = controlEventBeanFacade.getActiveControlEventByTime(new DateTime());

		List<ControlEventModel> controlEventModels = new ArrayList<ControlEventModel>();

		List<ControlEventSummaryModel> controlEventSummaryModels = getControlEventSummary(controlEventList, powerRemovedByControlEventId,
				avgPowerRemovedByControlEventId, numGwsAndOptOutsByControlEventId);

		if (null != controlEventSummaryModels && controlEventSummaryModels.size() > 0)
		{
			controlEventModels = mapControlEventSummariesToControlEvents(controlEventSummaryModels);
		}

		return controlEventModels;

	}

	@Override
	public ControlEventModel getControlEventModelByCeId(int ceId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		// This method is only to be used to get the current control event
		// model.
		// The calculations for power removed, avg power removed, and number of
		// gw/opt outs are not mapped to the model for performance reasons.

		Map<Integer, Double> powerRemovedByControlEventId = new HashMap<Integer, Double>();
		Map<Integer, Double> avgPowerRemovedByControlEventId = new HashMap<Integer, Double>();
		Map<Integer, int[]> numGwsAndOptOutsByControlEventId = new HashMap<Integer, int[]>();

		List<ControlEvent> controlEvents = controlEventBeanFacade.getControlEventByControlEventId(ceId);
		if (null == controlEvents || 0 == controlEvents.size())
		{
			return null;
		}
		ControlEvent controlEvent = controlEvents.get(0);

		List<ControlEventModel> controlEventModels = new ArrayList<ControlEventModel>();

		List<ControlEventSummaryModel> controlEventSummaryModels = getControlEventSummary(controlEvents, powerRemovedByControlEventId,
				avgPowerRemovedByControlEventId, numGwsAndOptOutsByControlEventId);

		if (null != controlEventSummaryModels && controlEventSummaryModels.size() > 0)
		{
			controlEventModels = mapControlEventSummariesToControlEvents(controlEventSummaryModels);
			ControlEventModel controlEventModel = controlEventModels.get(0);
			controlEventModel.setCeStatus(controlEvent.getCeStatusId().getCeStatusName());
			assignDeviceTypeIdsToControlEventModel(controlEventModel, controlEvent);
			return controlEventModel;
		}
		else
		{
			return null;
		}

	}

	private void assignDeviceTypeIdsToControlEventModel(ControlEventModel controlEventModel, ControlEvent controlEvent)
	{
		if (controlEvent != null)
		{
			Set<String> includedDeviceTypeIdSet = new HashSet<String>();

			if (controlEventModel.getIncludedDeviceTypeIds() != null)
			{
				includedDeviceTypeIdSet.addAll(controlEventModel.getIncludedDeviceTypeIds());
			}

			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeEvCharger()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.ELECTRIC_VEHICLE.getCeValue() + "");
			}

			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeHvacFlag()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.HVAC.getCeValue() + "");
			}

			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeHvacSwitch()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.AC_SWITCH.getCeValue() + "");
			}
			
			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeSingleHeat()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.SINGLE_HEAT.getCeValue() + "");
			}
			
			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeDualHeat()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.DUAL_HEAT.getCeValue() + "");
			}

			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludePoolPumpFlag()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.POOL_PUMP.getCeValue() + "");
			}

			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeWaterHeaterFlag()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.WATER_HEATER.getCeValue() + "");
			}

			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeIrrigationPump()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.IRRIGATION_PUMP.getCeValue() + "");
			}
			
			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeCropHeat()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.CROP_HEAT.getCeValue() + "");
			}
			
			if (OpsCenterConstants.TRUE.equalsIgnoreCase(controlEvent.getIncludeGenerator()))
			{
				includedDeviceTypeIdSet.add(OpsCenterConstants.DeviceType.GENERATOR.getCeValue() + "");
			}

			controlEventModel.setIncludedDeviceTypeIds(new ArrayList<String>());
			controlEventModel.getIncludedDeviceTypeIds().addAll(includedDeviceTypeIdSet);
		}
	}

	private List<ControlEventModel> mapControlEventSummariesToControlEvents(List<ControlEventSummaryModel> controlEventSummaryModels)
	{
		List<ControlEventModel> controlEventModels = new ArrayList<ControlEventModel>();

		for (ControlEventSummaryModel controlEventSummaryModel : controlEventSummaryModels)
		{
			ControlEventModel controlEventModel = new ControlEventModel();

			controlEventModel.setControlEventId(controlEventSummaryModel.getCeId());
			controlEventModel.setAdditionalPowerToRemove(controlEventSummaryModel.getAdditionalPowerToRemove());
			controlEventModel.setCriticalFlag(controlEventSummaryModel.getCriticalFlag());
			controlEventModel.setMode(controlEventSummaryModel.getMode());
			controlEventModel.setName(controlEventSummaryModel.getName());
			controlEventModel.setPowerRemoved(controlEventSummaryModel.getPowerRemoved());
			controlEventModel.setPowerRequestedInPercent(controlEventSummaryModel.getPowerRequestedInPercent());
			controlEventModel.setPowerToRemove(controlEventSummaryModel.getPowerToRemove());
			controlEventModel.setStartTime(controlEventSummaryModel.getStartTime());
			controlEventModel.setStopTime(controlEventSummaryModel.getStopTime());
			controlEventModel.setUserCreated(controlEventSummaryModel.getUserName());
			controlEventModel.setAuto(controlEventSummaryModel.isAuto());
			controlEventModel.setScadaReferenceName(controlEventSummaryModel.getScadaReferenceName());
			controlEventModels.add(controlEventModel);

		}

		return controlEventModels;
	}

	@Override
	public List<ControlEventSummaryModel> getControlEventSummary(int timeView, Integer tenantId)
	{
		return getControlEventSummary(timeView, true, tenantId);
	}

	@Override
	public List<ControlEventSummaryModel> getControlEventSummary(int timeView, boolean computeAvgPower, Integer tenantId)
	{
		// The computeAvgPower parameter is passed since the conservation events
		// list in the portal
		// does not use this information. So the calculation will not be made to
		// reduce CPU and response time.
		TenantContext.setCurrentTenant(tenantId);
		logger.info("List<ControlEventSummaryModel> ControlEventPowerBean.getControlEventSummary(" + timeView + ", " + computeAvgPower + ")");
		List<ControlEvent> controlEventList;
		Map<Integer, Double> powerRemovedByControlEventId;
		Map<Integer, Double> avgPowerRemovedByControlEventId = new HashMap<Integer, Double>();
		Map<Integer, int[]> numGwsAndOptOutsByControlEventId;

		if (timeView == TIMEVIEW_CURRENT || timeView == TIMEVIEW_FUTURE)
		{
			controlEventList = timeView == TIMEVIEW_CURRENT ? controlEventBeanFacade.getActiveControlEventByTime(new DateTime()) : controlEventBeanFacade
					.getFutureControlEventByTime(new DateTime());

			if (controlEventList.isEmpty())
			{
				return Collections.emptyList();
			}

			int i = 0;
			int[] ids = new int[controlEventList.size()];
			for (ControlEvent controlEvent : controlEventList)
			{
				ids[i++] = controlEvent.getControlEventId();
			}

			// Assuming that there will not be two many current and future so
			// passing ids
			powerRemovedByControlEventId = controlEventBeanFacade.getPowerRemovedForControlEventIds(ids);
			if (computeAvgPower)
			{
				avgPowerRemovedByControlEventId = controlEventBeanFacade.getAvgPowerRemovedForControlEventIds(ids);
			}
			numGwsAndOptOutsByControlEventId = controlEventBeanFacade.getNumGwsAndOptOutsForControlEventIds(ids);
		}
		else
		{
			
			DateTime maxPastEvt = new DateTime().minusDays(OpsCenterConstants.MAX_DAYS_PAST_EVENTS);
			controlEventList = controlEventBeanFacade.getPastControlEventByTimeMaxDays(new DateTime(), maxPastEvt);
			if (controlEventList.isEmpty())
			{
				return Collections.emptyList();
			}

			// Assuming that the majority will be past events, so not passing
			// ids
			powerRemovedByControlEventId = controlEventBeanFacade.getPowerRemovedForControlEventIds();
			if (computeAvgPower)
			{
				avgPowerRemovedByControlEventId = controlEventBeanFacade.getAvgPowerRemovedForControlEventIds();
			}
			numGwsAndOptOutsByControlEventId = controlEventBeanFacade.getNumGwsAndOptOutsForControlEventIds();
		}

		logger.info("ControlEventPowerBean.getControlEventSummary");

		return getControlEventSummary(controlEventList, powerRemovedByControlEventId, avgPowerRemovedByControlEventId, numGwsAndOptOutsByControlEventId);
	}

	@Override
	public List<ControlEventSummaryModel> getControlEventSummary(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<ControlEvent> controlEventList = controlEventBeanFacade.getControlEvent();

		// Doing this so EntityManager will cache the CeDevices, so a separate
		// sql does not get run per CeAccountMap
		Map<Integer, Double> powerRemovedByControlEventId = controlEventBeanFacade.getPowerRemovedForControlEventIds();

		Map<Integer, Double> avgPowerRemovedByControlEventId = controlEventBeanFacade.getAvgPowerRemovedForControlEventIds();
		Map<Integer, int[]> numGwsAndOptOutsByControlEventId = controlEventBeanFacade.getNumGwsAndOptOutsForControlEventIds();

		return getControlEventSummary(controlEventList, powerRemovedByControlEventId, avgPowerRemovedByControlEventId, numGwsAndOptOutsByControlEventId);
	}

	private List<ControlEventSummaryModel> getControlEventSummary(List<ControlEvent> controlEventList, Map<Integer, Double> powerRemovedByControlEventId,
			Map<Integer, Double> avgPowerRemovedByControlEventId, Map<Integer, int[]> numGwsAndOptOutsByControlEventId)
	{
		logger.info("[ENTER] List<ControlEventSummaryModel> ControlEventPowerBean.getControlEventSummary(...)");

		ArrayList<ControlEventSummaryModel> controlEventSummaryModelList = new ArrayList<ControlEventSummaryModel>(controlEventList.size());

		for (ControlEvent controlEvent : controlEventList)
		{

			int ceId = controlEvent.getControlEventId();

			double avgPowerRemoved = avgPowerRemovedByControlEventId.containsKey(ceId) ? avgPowerRemovedByControlEventId.get(ceId) : 0.0;
			double powerRemoved = powerRemovedByControlEventId.containsKey(ceId) ? powerRemovedByControlEventId.get(ceId) : 0.0;
			int numberOfOptOuts = numGwsAndOptOutsByControlEventId.containsKey(ceId) ? numGwsAndOptOutsByControlEventId.get(ceId)[1] : 0;
			int numberOfGateways = numGwsAndOptOutsByControlEventId.containsKey(ceId) ? numGwsAndOptOutsByControlEventId.get(ceId)[0] : 0;

			ControlEventSummaryModel controlEventSummaryModel = new ControlEventSummaryModel();
			controlEventSummaryModel.setPowerRemoved(powerRemoved);
			controlEventSummaryModel.setAvgPowerRemoved(avgPowerRemoved);
			controlEventSummaryModel.setStopTime(controlEvent.getStopTime());
			controlEventSummaryModel.setStartTime(controlEvent.getStartTime());
			controlEventSummaryModel.setAdditionalPowerToRemove(controlEvent.getAdditionalPowerToRemove());
			controlEventSummaryModel.setPowerToRemove(controlEvent.getPowerToRemove());
			// int numberOfGateways;
			// if
			// (OpsCenterConstants.TRUE.equals(controlEvent.getManageAllGroupsFlag()))
			// {
			// if (allAccounts < 0) {
			// allAccounts = controlEventBeanFacade.getCountOfActiveAccounts();
			// }
			// numberOfGateways = allAccounts;
			// } else {
			// if (countsByCe == null) {
			// countsByCe =
			// controlEventBeanFacade.getCountOfDistinctActiveAccountsForGroupsPerCe();
			// }
			// Integer count = countsByCe.get(ceId);
			// numberOfGateways = (count != null) ? count : 0;
			// }

			controlEventSummaryModel.setNumberOfGateways(numberOfGateways);
			controlEventSummaryModel.setNumberOfOptOuts(numberOfOptOuts);
			controlEventSummaryModel.setUserName(controlEvent.getUserCreated());
			controlEventSummaryModel.setCeId(ceId);
			controlEventSummaryModel.setName(OpsCenterConstants.CE_NAME_PREFIX + ceId);
			controlEventSummaryModel.setCriticalFlag(controlEvent.getCriticalFlag());
			controlEventSummaryModel.setPowerRequestedInPercent(controlEvent.getPowerToRemoveInPercent());
			if (null != controlEvent.getCycling() && controlEvent.getCycling().equals(OpsCenterConstants.TRUE))
			{
				controlEventSummaryModel.setMode(OpsCenterConstants.eventMode.CYCLING);
			}
			else
			{
				controlEventSummaryModel.setMode(OpsCenterConstants.eventMode.VPP);
			}

			controlEventSummaryModel.setAuto(GenericBean.isDbValueTrue(controlEvent.getAutoCe()));
			if(GenericBean.isDbValueTrue(controlEvent.getAutoCe())) {
				controlEventSummaryModel.setScadaReferenceName(multiScadaAPI.getScadaReferenceNameFromId(controlEvent.getScadaReferenceId()));
			}

			controlEventSummaryModelList.add(controlEventSummaryModel);
			logger.trace("returning in CE Summary model, powerInPercent = " + controlEventSummaryModel.getPowerRequestedInPercent());
		}

		logger.info("[ EXIT] ControlEventPowerBean.getControlEventSummary");

		return controlEventSummaryModelList;
	}

	/**
	 * @param ceAccountMap
	 * @param ceDuration
	 *            - in millis
	 * @return - power removed for this account (does not include drifters)
	 */
	@SuppressWarnings("unused")
	private double timeWeightedPowerRemoved(CEAccountMapCacheData ceAccountMap, long ceDuration, long ceStopTimeMillis)
	{

		double powerRemoved = 0;
		long stopTimeMillis = ceStopTimeMillis;
		double duration = Math.min(ceDuration, stopTimeMillis - ceAccountMap.getStartTime().getMillis());
		if (duration > 0)
		{
			double ratioInControl = duration / ceDuration;
			powerRemoved += ceAccountMap.getInitialPowerRemovable() * ratioInControl;
		}
		return powerRemoved;
	}

	/**
	 * @param ceAccountMap
	 * @param ceDuration
	 *            - in millis
	 * @return - power removed for drifters
	 */
	@SuppressWarnings("unused")
	private double timeWeightedPowerRemoved(CEDevicesCacheData ceDevices, long ceDuration)
	{
		double powerRemoved = 0;
		long driftMillis = ceDevices.getEndTime();
		if (driftMillis > 0)
		{
			double duration = Math.min(ceDuration, driftMillis - ceDevices.getStartTime());
			if (duration > 0)
			{
				double ratioInControl = duration / ceDuration;
				powerRemoved += ceDevices.getIntialPowerRemoveable() * ratioInControl;
			}
		}
		return powerRemoved;
	}

	/*
	 * This is the remote interface exposed to UI. The signature does not
	 * include the hashmap as that signature is part of the local method. So we
	 * will pass a null list here to local interface.
	 * 
	 * @see com.consert.core.ejb.session.interfaces.ControlEventPowerBeanRemote#
	 * getControlEventDetails (int)
	 */
	@Override
	public ControlEventModel getControlEventDetails(int controlEventId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return getControlEventDetails(controlEventId, false);
	}

	@Override
	public ControlEventModel getControlEventDetails(int controlEventId, boolean retrievePowerAvailable)
	{
		return getControlEventDetails(controlEventId, null, retrievePowerAvailable);
	}

	/*
	 * This is the remote interface exposed to UI. The signature does not
	 * include the hashmap as that signature is part of the local method. So we
	 * will pass a null list here to local interface.
	 * 
	 * @see com.consert.core.ejb.session.interfaces.ControlEventPowerBeanRemote#
	 * getControlEventDetails (int)
	 */
	@Override
	public ControlEventModel getControlEventDetailsByName(String controlEventName)
	{
		try
		{
			int controlEventId = -1;
			Results ceResults = cacheManager.getCacheData(cacheManager.getControlEventCache());

			for (Result ceResult : ceResults.all())
			{
				ControlEventCacheData ceCache = (ControlEventCacheData) ceResult.getValue();
				int thisCeId = ceCache.getCeId();
				ControlEvent ce = getControlEvent(thisCeId);

				if (ce.getName().equals(controlEventName))
				{
					controlEventId = ce.getControlEventId();
				}
			}

			return getControlEventDetails(controlEventId, false);
		} catch (Exception exp)
		{
			logger.error(exp.getMessage());
		}

		return null;
	}

	@Override
	public List<CeDeviceTypeModel> getCeDeviceTypeModelCollection(int controlEventId, Integer tenantId)
	{
		Map<Integer, CeDeviceTypeModel> ceDeviceTypesByDeviceTypeId = new HashMap<Integer, CeDeviceTypeModel>();
		TenantContext.setCurrentTenant(tenantId);
		logger.info("[ENTER] List<CeDeviceTypeModel> ControlEventPowerBean.getCeDeviceTypeModelCollection(controlEventId = " + controlEventId + ")");

		List<CeDevicesLogModel> list2 = controlEventBeanFacade.getCeDevicesLogModelMostRecentByControlEventId(controlEventId);

		logger.debug("getCeDeviceTypeModelCollection list2 size = " + list2.size());

		for (CeDevicesLogModel ceDevicesLogModel : list2)
		{
			CeDeviceTypeModel ceDeviceTypeModel = ceDeviceTypesByDeviceTypeId.get(ceDevicesLogModel.getDtId());
			if (ceDeviceTypeModel == null)
			{
				ceDeviceTypeModel = new CeDeviceTypeModel();
				ceDeviceTypesByDeviceTypeId.put(ceDevicesLogModel.getDtId(), ceDeviceTypeModel);
			}

			ceDeviceTypeModel.increment(ceDevicesLogModel.getCeEsiStatusName());
			ceDeviceTypeModel.setTimeStamp(PersistenceUtilities.getDateTimeFromTimestamp(ceDevicesLogModel.getDateCreated()));
		}

		// Currently this will display all device types that exist on an esi in
		// all groups or the selected groups for the CE
		// This may need to be filtered to Water Heater, Pool Pump, and HVAC
		// device types. Or maybe to exclude virtual tstats.
		Map<Integer, Integer> countsByType = controlEventBeanFacade.getCountOfActiveDevicesPerTypeByControlEventId(controlEventId);
		Set<Integer> deviceTypeIds = countsByType.keySet();
		for (Integer typeId : deviceTypeIds)
		{
			CeDeviceTypeModel ceDeviceTypeModel = ceDeviceTypesByDeviceTypeId.get(typeId);
			if (ceDeviceTypeModel == null)
			{
				ceDeviceTypeModel = new CeDeviceTypeModel();
				ceDeviceTypesByDeviceTypeId.put(typeId, ceDeviceTypeModel);
			}
		}

		Set<Integer> typeIds = ceDeviceTypesByDeviceTypeId.keySet();
		for (Integer typeId : typeIds)
		{
			DeviceType deviceType = controlEventBeanFacade.findDeviceTypeByDeviceTypeId(typeId);
			CeDeviceTypeModel ceDeviceTypeModel = ceDeviceTypesByDeviceTypeId.get(typeId);
			ceDeviceTypeModel.setDeviceTypeId(typeId);
			ceDeviceTypeModel.setDeviceTypeName(deviceType.getDeviceTypeName());
			ceDeviceTypeModel.setCeId(controlEventId);
			Integer count = countsByType.get(typeId);
			if (count != null)
			{
				ceDeviceTypeModel.setTotal(count);
			}
		}
		// Added for Wifitsat Setting the Total to Tstat of WifiTstat
		// Getting HoneywellEnabled Property
		String strHoneywellEnabled = genericBean.getUtilityPropertyByKeyOrProperty(OpsCenterConstants.HONEYWELL_ENABLED);
		logger.info("ControlEventPowerBean:getCeDeviceTypeModelCollection The HoneywellEnabled is" + strHoneywellEnabled);
		if (strHoneywellEnabled != null && strHoneywellEnabled.equalsIgnoreCase("Y"))
		{
			CeDeviceTypeModel ceDeviceTypeModelWifiTstat = ceDeviceTypesByDeviceTypeId.get(OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT);
			int iWifiTotal = 0;
			CeDeviceTypeModel ceDeviceTypeModelTstat = ceDeviceTypesByDeviceTypeId.get(OpsCenterConstants.DEVICE_TYPE_ID_HVAC);
			if (ceDeviceTypeModelTstat != null && ceDeviceTypeModelWifiTstat != null)
			{
				int iTstatTotal = ceDeviceTypeModelTstat.getTotal();
				ceDeviceTypeModelTstat.setTotal(iTstatTotal + ceDeviceTypeModelWifiTstat.getTotal());
				ceDeviceTypeModelTstat.setNumberOfDrifted(ceDeviceTypeModelTstat.getNumberOfDrifted() + ceDeviceTypeModelWifiTstat.getNumberOfDrifted());
				ceDeviceTypeModelTstat.setNumberOfInitial(ceDeviceTypeModelTstat.getNumberOfInitial() + ceDeviceTypeModelWifiTstat.getNumberOfInitial());
				ceDeviceTypeModelTstat.setNumberOfInProgress(ceDeviceTypeModelTstat.getNumberOfInProgress()
						+ ceDeviceTypeModelWifiTstat.getNumberOfInProgress());
				ceDeviceTypeModelTstat.setNumberOfOptedOut(ceDeviceTypeModelTstat.getNumberOfOptedOut() + ceDeviceTypeModelWifiTstat.getNumberOfOptedOut());
				ceDeviceTypeModelTstat.setNumberOfOptingOut(ceDeviceTypeModelTstat.getNumberOfOptingOut() + ceDeviceTypeModelWifiTstat.getNumberOfOptingOut());
				ceDeviceTypeModelTstat.setNumberOfStopped(ceDeviceTypeModelTstat.getNumberOfStopped() + ceDeviceTypeModelWifiTstat.getNumberOfStopped());
				ceDeviceTypeModelTstat.setNumberOfStopping(ceDeviceTypeModelTstat.getNumberOfStopping() + ceDeviceTypeModelWifiTstat.getNumberOfStopping());
				logger.debug("Inside tstat case");
			}
			else if (ceDeviceTypeModelTstat == null && ceDeviceTypeModelWifiTstat != null)
			{
				iWifiTotal = ceDeviceTypeModelWifiTstat.getTotal();
				CeDeviceTypeModel ceDeviceTypeModelTsat = new CeDeviceTypeModel();
				ceDeviceTypeModelTsat.setDeviceTypeId(OpsCenterConstants.DEVICE_TYPE_ID_HVAC);
				ceDeviceTypeModelTsat.setDeviceTypeName(OpsCenterConstants.DC_HVAC);
				ceDeviceTypeModelTsat.setCeId(ceDeviceTypeModelWifiTstat.getCeId());
				ceDeviceTypeModelTsat.setTotal(iWifiTotal);
				ceDeviceTypeModelTsat.setNumberOfDrifted(ceDeviceTypeModelWifiTstat.getNumberOfDrifted());
				ceDeviceTypeModelTsat.setNumberOfInitial(ceDeviceTypeModelWifiTstat.getNumberOfInitial());
				ceDeviceTypeModelTsat.setNumberOfInProgress(ceDeviceTypeModelWifiTstat.getNumberOfInProgress());
				ceDeviceTypeModelTsat.setNumberOfOptedOut(ceDeviceTypeModelWifiTstat.getNumberOfOptedOut());
				ceDeviceTypeModelTsat.setNumberOfOptingOut(ceDeviceTypeModelWifiTstat.getNumberOfOptingOut());
				ceDeviceTypeModelTsat.setNumberOfStopped(ceDeviceTypeModelWifiTstat.getNumberOfStopped());
				ceDeviceTypeModelTsat.setNumberOfStopping(ceDeviceTypeModelWifiTstat.getNumberOfStopping());
				ceDeviceTypeModelTsat.setTimeStamp(ceDeviceTypeModelWifiTstat.getTimeStamp());
				ceDeviceTypesByDeviceTypeId.put(OpsCenterConstants.DEVICE_TYPE_ID_HVAC, ceDeviceTypeModelTsat);
				logger.debug("Inside ThirdpartyTstat case");
			}
			// Removing WifiTstat
			if (ceDeviceTypeModelWifiTstat != null)
			{
				ceDeviceTypesByDeviceTypeId.remove(OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT);
			}
			logger.debug("After Removing ThirdpartyTstat");
		}

		/*
		 * If this is a duty cycle by device type event, filter out the device
		 * types not in the event, and add the duty cycle value for each device
		 * type
		 */
		setCeDeviceTypeModelsForDutyCycleByDeviceTypeEvent(controlEventId, ceDeviceTypesByDeviceTypeId);

		ArrayList<CeDeviceTypeModel> ceDeviceTypeModelCollection = new ArrayList<CeDeviceTypeModel>(ceDeviceTypesByDeviceTypeId.values());

		logger.info("[ EXIT] ControlEventPowerBean.getCeDeviceTypeModelCollection");

		return ceDeviceTypeModelCollection;
	}

	/**
	 * @param controlEventId
	 * @param ceDeviceTypesByDeviceTypeId
	 */
	private void setCeDeviceTypeModelsForDutyCycleByDeviceTypeEvent(int controlEventId, Map<Integer, CeDeviceTypeModel> ceDeviceTypesByDeviceTypeId)
	{
		List<DefinitionEventMap> defnEventMapList = controlEventBeanFacade.getCeDefinitionEventMapByCeId(controlEventId);

		if (defnEventMapList != null && !defnEventMapList.isEmpty() && defnEventMapList.get(0).getDeviceTypeId() != null)
		{
			Set<Integer> dutyCycleByDeviceTypeIds = new HashSet<Integer>();

			for (DefinitionEventMap defnEventMap : defnEventMapList)
			{
				dutyCycleByDeviceTypeIds.add(defnEventMap.getDeviceTypeId().getDeviceTypeId());
			}

			// Replace 19 with 0 since TSTAT deviceTypeId is 19 in the
			// CE_DEFN_EVENT_MAP table
			if (dutyCycleByDeviceTypeIds.contains(OpsCenterConstants.DeviceType.THERMOSTAT.getId()))
			{
				dutyCycleByDeviceTypeIds.remove(OpsCenterConstants.DeviceType.THERMOSTAT.getId());
				dutyCycleByDeviceTypeIds.add(OpsCenterConstants.DeviceType.HVAC.getId());
			}

			Iterator<Map.Entry<Integer, CeDeviceTypeModel>> iterator = ceDeviceTypesByDeviceTypeId.entrySet().iterator();

			while (iterator.hasNext())
			{
				Map.Entry<Integer, CeDeviceTypeModel> entry = iterator.next();

				if (!dutyCycleByDeviceTypeIds.contains(entry.getKey()))
				{
					iterator.remove();
				}
				else
				{
					for (DefinitionEventMap defnEventMap : defnEventMapList)
					{
						/*
						 * Remember to use device_type_id 19's (TSTAT) duty
						 * cycle value for 0's (HVAC) duty cycle
						 */
						if (defnEventMap.getDeviceTypeId().getDeviceTypeId() == entry.getKey()
								|| (defnEventMap.getDeviceTypeId().getDeviceTypeId() == OpsCenterConstants.DeviceType.THERMOSTAT.getId() && entry.getKey() == OpsCenterConstants.DeviceType.HVAC
										.getId()))
						{
							entry.getValue().setDutyCycle(defnEventMap.getDutyCycle());
						}
					}
				}
			}

			/*
			 * Now make sure we didn't miss any device types mentioned in
			 * CE_DEFN_EVENT_MAP
			 * 
			 * Even if no devices are active for that device type, we should
			 * still return a model for it (ignore 19 (TSTAT) since we got its
			 * info for 0 (HVAC) already
			 */
			for (DefinitionEventMap defnEventMap : defnEventMapList)
			{
				if (!ceDeviceTypesByDeviceTypeId.keySet().contains(defnEventMap.getDeviceTypeId().getDeviceTypeId())
						&& !(defnEventMap.getDeviceTypeId().getDeviceTypeId() == OpsCenterConstants.DeviceType.THERMOSTAT.getId()))
				{
					CeDeviceTypeModel ceDeviceTypeModel = new CeDeviceTypeModel();
					ceDeviceTypeModel.setCeId(defnEventMap.getEventId().getControlEventId());
					ceDeviceTypeModel.setDeviceTypeId(defnEventMap.getDeviceTypeId().getDeviceTypeId());
					ceDeviceTypeModel.setDutyCycle(defnEventMap.getDutyCycle());
					ceDeviceTypeModel.setDeviceTypeName(OpsCenterConstants.DeviceType.fromId(ceDeviceTypeModel.getDeviceTypeId()).getValue());
					ceDeviceTypesByDeviceTypeId.put(defnEventMap.getDeviceTypeId().getDeviceTypeId(), ceDeviceTypeModel);
				}
			}

			logger.debug("ceDeviceTypesByDeviceTypeId (for DC by DT): " + ceDeviceTypesByDeviceTypeId);
		}
	}

	private ArrayList<CeGroupMapModel> getCeGroupMapModelCollection(int controlEventId, Map<Integer, double[]> grpAvailPowerList)
	{
		logger.info("[ENTER] ControlEventPowerBean.getCeGroupMapModelCollection(controlEventId = " + controlEventId + ", grpAvailPowerList = "
				+ grpAvailPowerList + ")");

		Map<Integer, CeGroupMapModel> ceGroupMapsByCeGroupId = new HashMap<Integer, CeGroupMapModel>();
		Map<Integer, Integer> ceGroupByAccountId = controlEventBeanFacade.geCeAccountMapAccIdGrpIdByCeId(controlEventId);

		List<CeEsiLogModel> list = controlEventBeanFacade.getCeEsiLogMostRecentByControlEventId(controlEventId);

		for (CeEsiLogModel item : list)
		{
			if (item != null)
				logger.debug("Account id: " + item.getAccountId());
			else
				logger.debug("Null item");
		}

		Set<Integer> alreadyAddedCeGroupIds = new HashSet<Integer>();

		for (CeEsiLogModel ceEsiLog : list)
		{
			Integer ceGroupId = ceGroupByAccountId.get(ceEsiLog.getAccountId());
			if (ceGroupId != null)
			{
				CeGroupMapModel ceGroupMapModel = ceGroupMapsByCeGroupId.get(ceGroupId);
				if (ceGroupMapModel == null)
				{
					ceGroupMapModel = new CeGroupMapModel();
					ceGroupMapsByCeGroupId.put(ceGroupId, ceGroupMapModel);
				}

				// Only add the first Ce Esi Status name entry in the
				// sorted list from getCeEsiLogMostRecentByControlEventId
				if (alreadyAddedCeGroupIds.add(ceGroupId))
				{
					AccountID accountId = createAccountID(ceEsiLog);
					ceGroupMapModel.add(ceEsiLog.getCeEsiStatusName(), accountId);
				}
			}
		}

		Map<Integer, Integer> countsByGroup = controlEventBeanFacade.getCountOfActiveAccountsPerGroupByControlEventId(controlEventId);

		Set<Integer> ceGroupIds = countsByGroup.keySet();
		// This for makes sure every group belonging to the control event is
		// displayed, even if no esis in the group are currently controlled
		for (Integer ceGroupId : ceGroupIds)
		{
			CeGroupMapModel ceGroupMapModel = ceGroupMapsByCeGroupId.get(ceGroupId);
			if (ceGroupMapModel == null)
			{
				ceGroupMapModel = new CeGroupMapModel();
				ceGroupMapsByCeGroupId.put(ceGroupId, ceGroupMapModel);
			}
		}

		Set<Integer> groupIds = ceGroupMapsByCeGroupId.keySet();
		for (Integer ceGroupId : groupIds)
		{
			CeGroup ceGroup = controlEventBeanFacade.findCeGroupByCeGroupId(ceGroupId);

			CeGroupMapModel ceGroupMapModel = ceGroupMapsByCeGroupId.get(ceGroupId);
			ceGroupMapModel.setCeGroupId(ceGroupId);
			String name = ceGroup == null ? "Unknown - " + ceGroupId : ceGroup.getName();
			ceGroupMapModel.setCeGroupName(name);
			ceGroupMapModel.setCeId(controlEventId);
			// grpAvailPowerList is passed when we are changing power levels
			// - start a new CE
			// - start a edit a CE
			if (grpAvailPowerList != null && !grpAvailPowerList.isEmpty())
			{

				double[] powerValues = grpAvailPowerList.get(ceGroupId);
				if (powerValues != null)
				{
					ceGroupMapModel.setAdditionalPowerToRemove(powerValues[0]);
					ceGroupMapModel.setInitialPowerToRemove(powerValues[1]);
					logger.debug("additional power to remove for grpid, Initial Power = " + new Double(powerValues[0]).toString() + ","
							+ new Double(powerValues[1]).toString());
				}
				// Just in case.
				else
				{
					logger.warn("Null power array for CE Group " + ceGroupId);
				}

			}
			// This is the request for information scenario.
			// We do not have a grpAvailPowerListgrpAvailPowerList because no CE
			// creation or edit has occurred. Use existing information on the CE
			// as taken from the CE group map cache.
			else
			{
				double totalInitialPower = 0.0;
				double totalAdditionalPower = 0.0;

				Results groupCacheMapsForGroup = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpMapCache(), ceGroupId);

				for (Result result : groupCacheMapsForGroup.all())
				{
					CEGroupMapCacheData grpCacheMapData = (CEGroupMapCacheData) result.getValue();

					if (grpCacheMapData.getCeId() == controlEventId)
					{
						totalInitialPower += grpCacheMapData.getIntialPowerToRemoveable();
						// totalAdditionalPower +=
						// grpCacheMapData.getAdditionalPowerToRemove();
						totalAdditionalPower += grpCacheMapData.getPowerToRemove() - grpCacheMapData.getIntialPowerToRemoveable();
					}
				}

				ceGroupMapModel.setInitialPowerToRemove(totalInitialPower);
				ceGroupMapModel.setAdditionalPowerToRemove(totalAdditionalPower);

			}

			Integer count = countsByGroup.get(ceGroupId);
			if (count != null)
			{
				ceGroupMapModel.setTotal(count);
			}

		}

		ArrayList<CeGroupMapModel> ceGroupMapModelCollection = new ArrayList<CeGroupMapModel>(ceGroupMapsByCeGroupId.values());

		logger.info("[ EXIT] ControlEventPowerBean.getCeGroupMapModelCollection");

		return ceGroupMapModelCollection;
	}

	@Override
	public Set<Integer> getErcotAutoCeGroups(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return controlEventBeanFacade.getErcotGroupIds();
	}

	@Override
	public List<CeGroupMapModel> getCeGroupMapModelCollection(int controlEventId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		return getCeGroupMapModelCollection(controlEventId, new HashMap<>());
	}

	private ArrayList<CeGroupMapModel> getCeGroupMapModelCollectionForVPPPercentageEvent(int controlEventId)
	{
		logger.info("[ENTER] ArrayList<CeGroupMapModel> ControlEventPowerBean.getCeGroupMapModelCollectionForVPPPercentageEvent(controlEventId = "
				+ controlEventId + ")");

		ArrayList<CeGroupMapModel> ceGroupMapModelCollection = new ArrayList<CeGroupMapModel>();

		List<CeGroupMap> ceGroupMapList = controlEventBeanFacade.getCeGroupMapByControlEventId(controlEventId);

		for (CeGroupMap ceGroupMap : ceGroupMapList)
		{
			CeGroupMapModel ceGroupMapModel = new CeGroupMapModel();

			ceGroupMapModel.setCeGroupId(ceGroupMap.getCeGroupId().getCeGroupId());
			ceGroupMapModel.setCeGroupName(ceGroupMap.getCeGroupId().getName());
			ceGroupMapModel.setCeId(controlEventId);

			// we multiplied it by the power factor when we created it, but we
			// need to back to original value when re-rendering it on UI

			double totalPowerInPercent = ceGroupMap.getInitialPowerToRemove() + ceGroupMap.getAdditionalPowerToRemove();

			ceGroupMapModel.setPowerToRemoveInPercent(totalPowerInPercent);

			ceGroupMapModel.setInitialPowerToRemove(ceGroupMap.getInitialPowerToRemove());
			ceGroupMapModel.setAdditionalPowerToRemove(ceGroupMap.getAdditionalPowerToRemove());

			ceGroupMapModelCollection.add(ceGroupMapModel);
		}

		logger.info("[ EXIT] ControlEventPowerBean.getCeGroupMapModelCollectionForVPPPercentageEvent");

		return ceGroupMapModelCollection;
	}

	@Override
	public ControlEventModel getControlEventDetails(int controlEventId, Map<Integer, double[]> grpAvailPowerList)
	{
		return getControlEventDetails(controlEventId, grpAvailPowerList, true);
	}

	/**
	 * We do not have a historical view of what accounts belonged to a CeGroup
	 * when the event ended... So currently the counts assume that the groups
	 * have not changed...
	 */
	@Override
	public ControlEventModel getControlEventDetails(int controlEventId, Map<Integer, double[]> grpAvailPowerList, boolean retrievePowerAvailable)
	{
		logger.info("[ENTER] ControlEventModel ControlEventPowerBean.getControlEventDetails(" + controlEventId + ", retrievePowerAvailable = "
				+ retrievePowerAvailable + ")");

		if (grpAvailPowerList != null && !grpAvailPowerList.isEmpty())
		{
			for (Integer grpId : grpAvailPowerList.keySet())
			{
				logger.debug("grpId " + grpId + " : " + Arrays.toString(grpAvailPowerList.get(grpId)));
			}
		}

		ControlEvent controlEvent = controlEventBeanFacade.findControlEventByControlEventId(controlEventId);

		if (controlEvent == null)
		{
			logger.info("[ EXIT] ControlEventPowerBean.getControlEventDetails");
			return null;
		}

		ControlEventModel controlEventModel = new ControlEventModel();
		controlEventModel.setControlEventId(controlEvent.getControlEventId());
		controlEventModel.setName(OpsCenterConstants.CE_NAME_PREFIX + controlEvent.getControlEventId());
		if (null != controlEvent.getCycling() && controlEvent.getCycling().equals(OpsCenterConstants.TRUE))
		{
			controlEventModel.setMode(eventMode.CYCLING);
		}
		else
		{
			controlEventModel.setMode(eventMode.VPP);
		}

		controlEventModel.setCriticalFlag(controlEvent.getCriticalFlag());
		controlEventModel.setStartTime(controlEvent.getStartTime());
		controlEventModel.setStopTime(controlEvent.getStopTime());
		controlEventModel.setRecoveryTimeDelay(controlEvent.getRecoveryTimeDelay());
		controlEventModel.setAdditionalPowerToRemove(controlEvent.getAdditionalPowerToRemove());
		controlEventModel.setPowerToRemove(controlEvent.getPowerToRemove());
		controlEventModel.setUserModified(controlEvent.getUserModified());
		controlEventModel.setDateModified(controlEvent.getDateModified());
		controlEventModel.setUserCreated(controlEvent.getUserCreated());
		controlEventModel.setDateCreated(controlEvent.getDateCreated());
		controlEventModel.setCeStatus(controlEvent.getCeStatusId().getCeStatusName());
		controlEventModel.setManageAllGroupsFlag(controlEvent.getManageAllGroupsFlag());
		controlEventModel.setModifiedCount(controlEvent.getModifiedCount());
		controlEventModel.setPowerRequestedInPercent(controlEvent.getPowerToRemoveInPercent());
		controlEventModel.setMode(controlEvent.getCycling().equals(OpsCenterConstants.TRUE) ? eventMode.CYCLING : eventMode.VPP);
		controlEventModel.setIncludedDeviceTypeIds(new ArrayList<String>(controlEvent.getCEMapping().keySet()));
		controlEventModel.setAuto(GenericBean.isDbValueTrue(controlEvent.getAutoCe()));

		// Get power available for this CE. This is the sum of power
		// available across all groups.

		// Performance enhancement - retrieving the power available for a CE is
		// an expensive query.
		// Since the dashboards will retrieve control event details, it is not
		// necessary to return this
		// level of detail.
		if (retrievePowerAvailable)
		{
			double powerForCE = getPowerAvailForCE(controlEventModel.getControlEventId());
			controlEventModel.setPowerAvailable(powerForCE);
		}

		double powerRemoved = controlEventBeanFacade.getPowerRemovedByControlEventId(controlEvent.getControlEventId());
		controlEventModel.setPowerRemoved(powerRemoved);
		controlEventModel.setCeDeviceTypeModelCollection(new ArrayList<CeDeviceTypeModel>(getCeDeviceTypeModelCollection(controlEventId, TenantContext.getCurrentTenant())));

		boolean vppPercentageEvent = controlEventModel.getMode().equals(eventMode.VPP)
				&& controlEventModel.getPowerRequestedInPercent().equals(OpsCenterConstants.TRUE);

		if (vppPercentageEvent)
		{
			controlEventModel.setCeGroupMapModelCollection(getCeGroupMapModelCollectionForVPPPercentageEvent(controlEventId));
		}
		else
		{
			controlEventModel.setCeGroupMapModelCollection(getCeGroupMapModelCollection(controlEventId, grpAvailPowerList));
		}
		logger.debug("Dumping powerToRemove for this evtId = " + controlEventModel.getPowerToRemove() + (vppPercentageEvent ? "% " : " ")
				+ controlEventModel.getCeId());

		// TODO: @JPN removed the group count for CE for now.
		// controlEventModel = getGroupCountsForCeId(controlEventModel);
		entityManager.detach(controlEvent);
		logger.info("[ EXIT] ControlEventPowerBean.getControlEventDetails");

		return controlEventModel;
	}

	/**
	 * Get the CE group map from the cache for all groups used by the specified
	 * CE.
	 *
	 * @return
	 * @throws Exception
	 */
	@Override
	public List<CEGroupMapCacheData> getCeGroupMapsByCe(int ceId)
	{
		List<CEGroupMapCacheData> ceGroupMapList = new ArrayList<CEGroupMapCacheData>();

		Results ceGrpMapResults = cacheManager.getCacheData(cacheManager.getCeGrpMapCache());
		for (Result ceGrpMapResult : ceGrpMapResults.all())
		{
			CEGroupMapCacheData ceGrpMapCache = (CEGroupMapCacheData) ceGrpMapResult.getValue();
			if (ceGrpMapCache.getCeId() == ceId)
			{
				ceGroupMapList.add(ceGrpMapCache);
			}
		}

		return ceGroupMapList;
	}

	/**
	 * @param ceAccId
	 * @return
	 */
	private AccountID createAccountID(CeEsiLogModel account)
	{
		AccountID accountId = new AccountID();
		accountId.setAccountId(account.getAccountId());
		accountId.setAccountNumber(account.getAccountNumber());
		accountId.setFirstName(account.getFirstName());
		accountId.setLastName(account.getLastName());
		return accountId;
	}

	@Override
	@Asynchronous
	public void stopControlEvent(List<Integer> ceList, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		DateTime currTime = new DateTime();
		for (Integer ceId : ceList)
		{
			ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceId);
			if (ce == null)
			{
				throw new ControlEventNotFoundException("Unable to find " + OpsCenterConstants.CE_NAME + " (id=" + ceId + ")");
			}
			ce.setOrigStopTime(ce.getStopTime());
			ce.setStopTime(currTime);

			entityManager.flush();
			// The stopTime must be <= current time or the controlEventBean will
			// think that the CE has been extended
			controlEventBean.sendStopControlEvent(ceId);
		}
	}

	@Override
	@Asynchronous
	public void updateCeTablesOnStop(List<Integer> accList, int ceId, DateTime currTime, Integer tenantId)
	{

		logger.info("Entering updateCeTablesOnStop total # of accounts =   " + accList.size());
		TenantContext.setCurrentTenant(tenantId);
		// now update the ceDevices table for stopped CE
		controlEventBeanFacade.updateCeDevicesStopTimesForCE(ceId, currTime);

	}

	/**
	 * returns EsiCacheData & CEAccountMapCacheData
	 */
	@Override
	public Object[] isEsiInCE(int accId) throws AbstractOpsCenterException
	{

		logger.info("Entering isEsiInCE for accId = " + accId);

		Results esiResults = cacheManager.getCacheDataByAccId(cacheManager.getGwEsiCache(), accId);
		EsiCacheData esiCache = null;
		for (Result esiResult : esiResults.all())
		{
			esiCache = (EsiCacheData) esiResult.getValue();
			if (!OpsCenterConstants.VERIZON_CELLULAR_DELIVERY.equals(esiCache.getNwType()))
			{
				// if this is not verizon ESI, skip it and check below for
				// optout
				break;
			}
			CEAccountMapCacheData ceAccountMapCacheData = null;

			int ceAccountMapId = esiCache.getCeAccountMapId();
			Element element = cacheManager.getCeAccMapCache().get(ceAccountMapId);
			if (element != null)
			{
				ceAccountMapCacheData = (CEAccountMapCacheData) element.getObjectValue();
			}
			return new Object[] { esiCache, ceAccountMapCacheData };
		}
		if (esiCache == null)
		{
			logger.error("could not opt-out acc, no esi found in cache");
			return null;
		}

		// now check the GS devices
		EsiDcCacheData dcCache = null;
		CEAccountMapCacheData accMapCache = null;
		Results dcResults = cacheManager.getCacheDataByAccId(cacheManager.getGwDCCache(), accId);
		for (Result dcResult : dcResults.all())
		{

			// skip nonGS devices here, they will get optedout below after
			// classic devices
			if (!OpsCenterConstants.GRIDSTREAM_RF_DELIVERY.equals(esiCache.getNwType()))
			{
				break;
			}

			dcCache = (EsiDcCacheData) dcResult.getValue();
			CEDevicesCacheData ceDevCache = null;

			// first get the ceDevices, to make sure dc still in a ce
			Results ceDevResults = cacheManager.getCacheDataByCeIdAndEsiDcId(cacheManager.getCeDevCache(), dcCache.getCeId(), dcCache.getEsiDcId());
			for (Result ceDev : ceDevResults.all())
			{
				ceDevCache = (CEDevicesCacheData) ceDev.getValue();

				if (ceDevCache != null)
				{
					logger.debug("ceDevCache ce accMapId = " + ceDevCache.getCeAccMapId());

					CeDevices ceDevices = controlEventBeanFacade.findCeDevicesByCeDevicesId(ceDevCache.getCeDevicesId());
					if (ceDevices != null && ceDevices.getStopTime() == null)
					{
						logger.debug("Found ceDevices for esiDcId " + dcCache.getEsiDcId());

						accMapCache = new CEAccountMapCacheData();
						accMapCache.setCeId(dcCache.getCeId());
						ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(dcCache.getCeId());
						accMapCache.setCriticalFlag(ce.getCriticalFlag());
						break;

					}
				}
			}
		}

		logger.info("Exiting isEsiInCE  ");

		dcResults.discard();
		esiResults.discard();

		return new Object[] { esiCache, accMapCache };

	}

	@Override
	public boolean optOutEsiFromCE(int accId, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		return optOutEsiFromCE(accId, OpsCenterConstants.OptOutReason.GUI);
	}

	@Override
	public boolean optOutEsiFromCE(int accId, OptOutReason reason) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] boolean ControlEventPowerBean.optOutEsiFromCE(accId = " + accId + ", reason = " + reason + ")");

		DateTime currTime = new DateTime();
		Results accMapResults = cacheManager.getCacheDataByCeAccId(cacheManager.getCeAccMapCache(), accId);

		CEAccountMapCacheData accMapCache = null;
		EsiCacheData esiCache = null;

		boolean found = false;

		for (Result accMap : accMapResults.all())
		{
			accMapCache = (CEAccountMapCacheData) accMap.getValue();
			if (accMapCache.getCriticalFlag().equals(OpsCenterConstants.TRUE))
			{
				logger.info("[ EXIT] ControlEventPowerBean.optOutEsiFromCE");
				throw new ControlEventOptOutNotAllowed(DefaultResources.CEV_ERR_CODE_CE_OPTOUT_NOT_ALLOWED, OpsCenterConstants.CE_NAME + " is either Critical"
						+ accId);
			}
			else if (accMapCache.getStartTime().getMillis() < currTime.getMillis())
			{
				Results esiResults = cacheManager.getCacheDataByAccId(cacheManager.getGwEsiCache(), accId);
				for (Result esiResult : esiResults.all())
				{
					esiCache = (EsiCacheData) esiResult.getValue();
					// skip GS devices here, they will get opted out below after
					// classic devices
					if (!OpsCenterConstants.VERIZON_CELLULAR_DELIVERY.equals(esiCache.getNwType()))
					{
						break;
					}

					if (esiCache.getOptOutFlag().equals(OpsCenterConstants.TRUE))
					{
						logger.info("[ EXIT] ControlEventPowerBean.optOutEsiFromCE");
						throw new ControlEventOptOutNotAllowed(DefaultResources.CEV_ERR_CODE_CE_OPTOUT_NOT_ALLOWED, "Account already opted-out" + accId);
					}
					// set opt-out reason krmt-4317
					esiCache.setOptOutReason(reason);
					optOutEsiFromCE(esiCache, accMapCache);

					final int ceGroupMapId = accMapCache.getCeGroupMapId();
					final double powerToRemove = accMapCache.getPowerToRemove();

					controlEventPowerBean.replacePowerForOptOutNewThread(ceGroupMapId, powerToRemove, TenantContext.getCurrentTenant());

					logger.debug("Found ESI and successfully opt-out, esiId= " + esiCache.getEsiId());
					found = true;
					break;
				}
			}

			if (found)
			{
				logger.info("[ EXIT] ControlEventPowerBean.optOutEsiFromCE");
				return found;
			}
		}

		accMapResults.discard();

		// Now optout any GS devices
		logger.debug("Looking for GS devices-- all must be opt-out for accId = " + accId);
		accMapResults = cacheManager.getCacheDataByCeAccId(cacheManager.getCeAccMapCache(), accId);

		EsiDcCacheData dcCache = null;
		for (Result accMap : accMapResults.all())
		{
			accMapCache = (CEAccountMapCacheData) accMap.getValue();
			Results dcResults = cacheManager.getCacheDataByAccId(cacheManager.getGwDCCache(), accMapCache.getCeAccId());
			for (Result dcResult : dcResults.all())
			{
				if (esiCache == null)
				{
					logger.error("esiCache returned null in optOutEsiFromCE()");
					continue;
				}
				dcCache = (EsiDcCacheData) dcResult.getValue();
				// skip nonGS devices here, they get opted out in code block
				// above this
				if (!OpsCenterConstants.GRIDSTREAM_RF_DELIVERY.equals(esiCache.getNwType()))
				{
					break;
				}

				logger.debug("Look for device in control, dcId/manage mode = " + dcCache.getEsiDcId() + "/" + dcCache.getDcMode());

				if (dcCache.getDcMode() != OpsCenterConstants.ESI_MODE_CONTROL)
				{
					// even if the device is not in CE, all devices for this acc
					// need to get
					// opt-out flag set in cache so it does not get re-added
					// back to the CE
					dcCache.setOptOutReason(reason);
					// must now save the data for opt-out reason
					Element element = new Element(dcCache.getCacheKey(), dcCache);
					cacheManager.getGwDCCache().put(element);
					continue;
				}

				logger.debug("Found GS Dev, see if we can indeed optout, dcId /esiId = " + dcCache.getEsiDcId() + "/" + esiCache.getEsiId());
				// dev 2413-- allow opt-out for critical when request is from
				// utility portal
				// KRMT-6975 also allow opt out if an unmanaged device is in CE
				if (accMapCache.getCriticalFlag().equals(OpsCenterConstants.TRUE) && OpsCenterConstants.OptOutReason.UTILITY_DEV_OPTOUT != reason
						&& OpsCenterConstants.OptOutReason.UTILITY_RELEASED != reason && OpsCenterConstants.OptOutReason.CANCEL_CE_FOR_DO_NOT_MANAGE != reason)
				{
					logger.info("[ EXIT] ControlEventPowerBean.optOutEsiFromCE");
					throw new ControlEventOptOutNotAllowed(DefaultResources.CEV_ERR_CODE_CE_OPTOUT_NOT_ALLOWED, OpsCenterConstants.CE_NAME
							+ " is either Critical" + accId);
				}
				else if (accMapCache.getStartTime().getMillis() < currTime.getMillis())
				{
					if (dcCache.getOptOutFlag().equals(OpsCenterConstants.TRUE) && !dcCache.isCancelCEUnmanaged())
					{
						logger.error("GS Device already opted-out dcId = " + dcCache.getEsiDcId());
						// no need for exception here...just exit
						/*
						 * throw new ControlEventOptOutNotAllowed
						 * (DefaultResources.CEV_ERR_CODE_CE_OPTOUT_NOT_ALLOWED,
						 * "GS Device already opted-out" + accId);
						 */
						logger.info("[ EXIT] ControlEventPowerBean.optOutEsiFromCE");
						return false;
					}
					// set opt-out reason krmt-4317
					dcCache.setOptOutReason(reason);
					// must now save the data for opt-out reason
					Element element = new Element(dcCache.getCacheKey(), dcCache);
					cacheManager.getGwDCCache().put(element);
					optOutGSDeviceFromCE(dcCache, accMapCache);
					logger.debug("Found GS device and succesfully opt-out, esiDcId =  " + dcCache.getEsiDcId());
					found = true;
				}

			}
			if (found)
			{
				// only if we found at least 1 DC to opt-out, do we then replace
				// power
				final int ceGroupMapId = accMapCache.getCeGroupMapId();
				final double powerToRemove = accMapCache.getPowerToRemove();

				controlEventPowerBean.replacePowerForOptOutNewThread(ceGroupMapId, powerToRemove, TenantContext.getCurrentTenant());
			}
		}

		logger.info("[ EXIT] ControlEventPowerBean.optOutEsiFromCE");

		accMapResults.discard();
		return found;
	}

	private Collection<String> getDeviceClass(ControlEvent ce)
	{

		return ce.getCEMapping().keySet();

	}

	@Override
	public void optOutEsiFromCE(EsiCacheData esiCache, CEAccountMapCacheData ceAccMapCache) throws AbstractOpsCenterException
	{
		optOutEsiFromCE(Arrays.asList(esiCache), Arrays.asList(ceAccMapCache));
	}

	@Override
	public void optOutGSDeviceFromCE(EsiDcCacheData dcCache, CEAccountMapCacheData ceAccMapCache) throws AbstractOpsCenterException
	{
		optOutGSDeviceFromCE(Arrays.asList(dcCache), Arrays.asList(ceAccMapCache));
	}

	/**
	 * This method has be optimized for performance!!! The goal is to handle
	 * 10,000+ optOuts in 1 minute, which would simulate the entire wireless
	 * provider network being down for staleTimeMin minutes
	 *
	 * @param esiCacheList
	 * @param ceAccMapCacheList
	 * @throws AbstractOpsCenterException
	 */
	@Override
	public void optOutEsiFromCE(List<EsiCacheData> esiCacheList, List<CEAccountMapCacheData> ceAccMapCacheList) throws AbstractOpsCenterException
	{

		List<Integer> esiIdList = new ArrayList<Integer>();
		List<EsiCacheData> sendStopList = new ArrayList<EsiCacheData>();
		for (EsiCacheData esiCache : esiCacheList)
		{
			logger.debug("ESI= has opted-out from CE = " + esiCache.getEsiId() + " " + esiCache.getCeId());

			// If the ceId is 0, then we are in a bad state, likely caused by
			// the cache getting dropped while the CE was running
			if (esiCache.getCeId() > 0 && esiCache.getOptOutReason() != OpsCenterConstants.OptOutReason.RELEASED)
			{
				esiIdList.add(esiCache.getEsiId());
			}

			// now take ESI out of CE, If ESI Mode not equal Control then
			// assuming that this is an out-of-sync condition
			if (OpsCenterConstants.ESI_MODE_CONTROL == esiCache.getEsiMode())
			{
				sendStopList.add(esiCache);
			}
		}

		// On opt out set powerAvail to zero for all devices
		Cache gwDCCache = cacheManager.getGwDCCache();
		Results results = cacheManager.getAllCacheByEsiIdListAndEnergyAvail(gwDCCache, esiIdList);
		for (Result dcResult : results.all())
		{
			EsiDcCacheData esiDcCache = (EsiDcCacheData) dcResult.getValue();
			if (esiDcCache == null)
			{
				continue;
			}
			esiDcCache.setActEnergyAvail(0.0);
			gwDCCache.put(new Element(esiDcCache.getCacheKey(), esiDcCache));
		}
		results.discard();

		if (!sendStopList.isEmpty())
		{
			try
			{
				controlEventBean.sendStopControlEvent(sendStopList, false);
			} catch (AbstractOpsCenterException e1)
			{
				logger.error("Unable to send stop CE GW Mode message to esi count=" + sendStopList.size(), e1);
			}
		}
		// PHNX-28 STOPPING no more will be use so replacing STOPPING -> STOPPED
		CeEsiStatus stoppingCeEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.STOPPED).intValue());

		CeEsiStatus stoppedCeEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.STOPPED).intValue());
		// PHNX-28 OPTING_OUT no more will be use so replacing OPTING_OUT ->
		// OPTED_OUT
		CeEsiStatus optingOutCeEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.OPTED_OUT).intValue());

		DateTime currTime = new DateTime();
		// MISSING_READS, GUI, TSTAT_OVERRIDE, RELEASED, OUT_OF_SYNC
		List<Integer> ceAccountMissingReads = new ArrayList<Integer>();
		List<Integer> ceAccountGui = new ArrayList<Integer>();
		List<Integer> ceAccountTsat = new ArrayList<Integer>();
		List<Integer> ceAccountReleased = new ArrayList<Integer>();
		List<Integer> ceAccountOutOfSync = new ArrayList<Integer>();
		List<Integer> ceAccountOptOuts = new ArrayList<Integer>();
		List<Integer> ceAccountDoNotManage = new ArrayList<Integer>();
		List<Integer> ceAccountLostComms = new ArrayList<Integer>();
		List<Integer> ceAccountRejectedCeStart = new ArrayList<Integer>();

		Set<Integer> driftingEsiDcIds = new HashSet<Integer>();
		Set<Integer> tstatOverrideEsiDcIds = new HashSet<Integer>();
		Set<Integer> invalidReadsEsiDcIds = new HashSet<Integer>();

		Set<Integer> stoppedCeAccMapIds = new HashSet<Integer>();

		int clearCount;
		clearCount = 0;
		int size = esiCacheList.size();
		for (int i = 0; i < size; i++)
		{
			EsiCacheData esiCache = esiCacheList.get(i);
			CEAccountMapCacheData ceAccMapCache = ceAccMapCacheList.get(i);
			// if (esiCache.getLastMqRecdTime().getMillis() <
			// currTime.minusMinutes(staleTimeMin).getMillis()) {
			// ceAccountMissingReads.add(ceAccMapCache.getCeAccMapId());
			// } else{
			// ceAccountOptOuts.add(ceAccMapCache.getCeAccMapId());
			// }
			switch (esiCache.getOptOutReason())
			{
			case MISSING_READS:
				ceAccountMissingReads.add(ceAccMapCache.getCeAccMapId());
				break;
			case GUI:
				ceAccountGui.add(ceAccMapCache.getCeAccMapId());
				break;
			case TSTAT_OVERRIDE:
				ceAccountTsat.add(ceAccMapCache.getCeAccMapId());
				break;
			case RELEASED:
				ceAccountReleased.add(ceAccMapCache.getCeAccMapId());
				break;
			case OUT_OF_SYNC:
				ceAccountOutOfSync.add(ceAccMapCache.getCeAccMapId());
				break;
			case DO_NOT_MANAGE:
				ceAccountDoNotManage.add(ceAccMapCache.getCeAccMapId());
				break;
			case CANCEL_CE_FOR_DO_NOT_MANAGE:
				ceAccountDoNotManage.add(ceAccMapCache.getCeAccMapId());
				break;
			case LOST_COMMS:
				ceAccountLostComms.add(ceAccMapCache.getCeAccMapId());
				break;
			case REJECTED_CE_START_REQUEST:
				ceAccountRejectedCeStart.add(ceAccMapCache.getCeAccMapId());
				break;

			default:
				ceAccountOptOuts.add(ceAccMapCache.getCeAccMapId());
			}

			Map<Integer, EsiDcFlagCacheData> esiDcFlagByEsiDcId = esiCache.getCeFlagsByEsiDcId();
			for (EsiDcFlagCacheData esiDcFlagCacheData : esiDcFlagByEsiDcId.values())
			{
				switch (esiDcFlagCacheData.getCeFlag())
				{
				case OpsCenterConstants.CE_ESI_DC_FLAG_INVALID_READS:
					invalidReadsEsiDcIds.add(esiDcFlagCacheData.getEsiDcId());
					break;
				case OpsCenterConstants.CE_ESI_DC_FLAG_TSTAT_DRIFTING:
					driftingEsiDcIds.add(esiDcFlagCacheData.getEsiDcId());
					break;
				case OpsCenterConstants.CE_ESI_DC_FLAG_TSTAT_OVERRIDE:
					tstatOverrideEsiDcIds.add(esiDcFlagCacheData.getEsiDcId());
					break;
				default:
					break;
				}
			}

			// first log the optedout ESI in DB
			CeEsiLog esiLog = new CeEsiLog();
			ControlEvent refControlEvent = controlEventBeanFacade.getRefControlEventByControlEventId(ceAccMapCache.getCeId());
			esiLog.setControlEventId(refControlEvent);
			esiLog.setDateCreated(currTime);
			esiLog.setEsiId(controlEventBeanFacade.getRefEsiByEsiId(esiCache.getEsiId()));
			// If ESI Mode not equal Control then assuming that this is an
			// out-of-sync condition
			if (OpsCenterConstants.ESI_MODE_CONTROL == esiCache.getEsiMode())
			{
				esiLog.setLogMessage("Gateway is Opting out of " + OpsCenterConstants.CE_NAME);
				esiLog.setCeEsiStatusId(optingOutCeEsiStatusId);
			}
			else
			{
				esiLog.setLogMessage("Gateway has Stopped participating in the " + OpsCenterConstants.CE_NAME);
				esiLog.setCeEsiStatusId(stoppedCeEsiStatusId);
				stoppedCeAccMapIds.add(ceAccMapCache.getCeAccMapId());
			}

			try
			{
				controlEventBeanFacade.createCeEsiLog(esiLog);
			} catch (Exception e)
			{
				logException(e, esiLog.getLogMessage());

				throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeEsiLog = ");
			}

			clearCount++;
			if (clearCount > BATCH_SIZE_FLUSH)
			{
				clearCount = 0;
				entityManager.flush();
				entityManager.clear();
			}

			esiCache.setCeAccountMapId(0);
			esiCache.setCeDeviceMqIds(null);
			// esiCache.setDutyCycle(0); We don't set DutyCycle to 0 when Optout
			// but only while stop event, please refer DEV-2926 DEV-3124.
			// set the hb flag now for all esi, to prepare for next evt they get
			// added to

			// Leaving ceId in esiCache, so that it can get cleared when the
			// Control Event stops/ends
			// esiCache.setCeId(0);

			Element esiElement = new Element(esiCache.getCacheKey(), esiCache); // cacheManager.getGwEsiCache().get(esiCache.getCacheKey());
			cacheManager.getGwEsiCache().put(esiElement);
			// delete ceAccMapCache entry--
			logger.debug("Cache has been deleted for Opted Out ESI = " + esiCache.getEsiId());
			cacheManager.deleteCEAccountMapCacheEntry(ceAccMapCache.getCeAccMapId());
		}
		if (!ceAccountOptOuts.isEmpty())
		{
			logger.debug("Regular opt out, esi count=" + ceAccountOptOuts.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountOptOuts, currTime, OpsCenterConstants.TRUE, OpsCenterConstants.OptOutReason.ACCOUNT_OPTOUT);
		}
		if (!ceAccountMissingReads.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountMissingReads);
			logger.debug("Missing read opt out, esi count=" + ceAccountMissingReads.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountMissingReads, currTime, OpsCenterConstants.TRUE, OpsCenterConstants.OptOutReason.MISSING_READS);
		}
		if (!ceAccountGui.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountGui);
			logger.debug("GUI opt out, esi count=" + ceAccountGui.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountGui, currTime, OpsCenterConstants.TRUE, OpsCenterConstants.OptOutReason.GUI);
		}
		if (!ceAccountTsat.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountTsat);
			logger.debug("Whole house tstat opt out, esi count=" + ceAccountTsat.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountTsat, currTime, OpsCenterConstants.TRUE, OpsCenterConstants.OptOutReason.TSTAT_OVERRIDE);
		}
		if (!ceAccountReleased.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountReleased);
			logger.debug("Released, esi count=" + ceAccountReleased.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountReleased, currTime, OpsCenterConstants.FALSE, OpsCenterConstants.OptOutReason.RELEASED);
		}
		if (!ceAccountOutOfSync.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountOutOfSync);
			logger.debug("Out of Sync opt out, esi count=" + ceAccountOutOfSync.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountOutOfSync, currTime, OpsCenterConstants.FALSE, OpsCenterConstants.OptOutReason.OUT_OF_SYNC);
		}
		if (!ceAccountDoNotManage.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountDoNotManage);
			logger.debug("Do Not Manage opt out, esi count=" + ceAccountDoNotManage.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountDoNotManage, currTime, OpsCenterConstants.FALSE, OpsCenterConstants.OptOutReason.DO_NOT_MANAGE);
		}
		if (!ceAccountLostComms.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountLostComms);
			logger.debug("Lost Comms opt out, esi count=" + ceAccountLostComms.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountLostComms, currTime, OpsCenterConstants.FALSE, OpsCenterConstants.OptOutReason.LOST_COMMS);
		}

		if (!ceAccountRejectedCeStart.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountRejectedCeStart);
			logger.debug("GW Rejected CE Start, esi count=" + ceAccountRejectedCeStart.size());
			controlEventBeanFacade.updateCeAccountMap(ceAccountLostComms, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.REJECTED_CE_START_REQUEST);
		}

		Results devResults = cacheManager.getCacheDataByAccMapId(cacheManager.getCeDevCache(), ceAccountOptOuts);

		// Update the CE Devices with flags to handle 2 uses cases:
		// 1) The last device for a gw in a CE gets flagged for opt out, so opt
		// out entire esi
		// 2) If whole house opt out on tstat override, Ops will flag the tstat
		// that opted out
		updateCeDevicesWithFlags(devResults.all(), driftingEsiDcIds, tstatOverrideEsiDcIds, invalidReadsEsiDcIds, currTime);

		// Update the CE Devices w/o flags
		controlEventBeanFacade.updateCeDevicesStopTimes(ceAccountOptOuts, currTime);

		clearCount = 0;
		for (Result devResult : devResults.all())
		{
			CEDevicesCacheData devMapCache = (CEDevicesCacheData) devResult.getValue();

			if (devMapCache == null)
			{
				continue;
			}

			// Need to delete device from cache b/c ce account map was removed
			// from cache
			if (devMapCache.getEndTime() > 0)
			{
				cacheManager.deleteCEDevicesCacheEntry(devMapCache.getCeDevicesId());
				continue;
			}

			int devId = devMapCache.getCeDevicesId();
			CeDevices ceDevice = controlEventBeanFacade.getRefCeDevicesByCeDevicesId(devId);

			CeDevicesLog ceDevicesLog = new CeDevicesLog();
			ControlEvent refControlEvent = controlEventBeanFacade.getRefControlEventByControlEventId(devMapCache.getCeId());
			ceDevicesLog.setControlEventId(refControlEvent);
			ceDevicesLog.setDateCreated(currTime);
			ceDevicesLog.setCeDevicesId(ceDevice);
			// krmt-2094-- add device name to log
			String devName = OpsCenterConstants.deviceTypeToNameMap.get(devMapCache.getDevTypeId());
			ceDevicesLog.setLogMessage("Device " + devName + " is exiting out of " + OpsCenterConstants.CE_NAME);

			// KRMT-2410: We don't have a definite event for when a device has
			// exited control. So we will just show drifting, opting out, &
			// stopping
			// The Esi will be the only log with the definitive Opted Out or
			// Stopped

			if (stoppedCeAccMapIds.contains(devMapCache.getCeAccMapId()))
			{
				ceDevicesLog.setCeEsiStatusId(stoppingCeEsiStatusId);
			}
			else
			{
				ceDevicesLog.setCeEsiStatusId(optingOutCeEsiStatusId);
			}

			cacheManager.deleteCEDevicesCacheEntry(ceDevice.getCeDevicesId());

			try
			{
				controlEventBeanFacade.createCeDevicesLog(ceDevicesLog);
			} catch (Exception e)
			{
				logException(e, ceDevicesLog.getLogMessage());

				throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeDevicesLog = ");
			}

			clearCount++;
			if (clearCount > BATCH_SIZE_FLUSH)
			{
				clearCount = 0;
				entityManager.flush();
				entityManager.clear();
			}
		}
		devResults.discard();

		logger.info("Exiting optOutEsiFromCE ");
	}

	@Override
	public void optOutGSDeviceFromCE(List<EsiDcCacheData> dcCacheList, List<CEAccountMapCacheData> ceAccMapCacheList) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] void ControlEventPowerBean.optOutGSDeviceFromCE(...) # of GS devices to opt out = " + dcCacheList.size());

		int ce = 0;
		List<Integer> esiIdList = new ArrayList<Integer>();
		List<EsiCacheData> sendStopList = new ArrayList<EsiCacheData>();
		for (EsiDcCacheData dcCache : dcCacheList)
		{
			logger.debug("Device= has opted-out from esiDcId ,CE, dcMode  = " + dcCache.getEsiDcId() + " " + dcCache.getCeId() + " " + dcCache.getDcMode());

			Results esiL = cacheManager.getCacheDataByEsiId(cacheManager.getGwEsiCache(), dcCache.getEsiId());
			if (esiL == null || esiL.size() <= 0)
			{
				continue;
			}

			// there should only be one entry in this Result list
			EsiCacheData esiCacheData = null;
			for (Result esi : esiL.all())
			{
				esiCacheData = (EsiCacheData) esi.getValue();
			}
			// If the ceId is 0, then we are in a bad state, likely caused by
			// the cache getting dropped while the CE was running
			if (dcCache.getCeId() > 0 && dcCache.getOptOutReason() != OpsCenterConstants.OptOutReason.RELEASED)
			{
				esiIdList.add(dcCache.getEsiId());
			}
			// now take Device out of CE, If device Mode not equal Control then
			// assuming that this is an out-of-sync condition
			if (OpsCenterConstants.ESI_MODE_CONTROL == dcCache.getDcMode())
			{
				sendStopList.add(esiCacheData);
			}
			logger.info("Calling optOutGSDeviceFromCE --> checkCeTimeOnOptOut(dcCache)");
			checkCeTimeOnOptOut(dcCache);
		}

		// On opt out set powerAvail to zero for all devices
		Cache gwDCCache = cacheManager.getGwDCCache();
		for (EsiDcCacheData dc : dcCacheList)
		{
			ce = dc.getCeId();
			dc.setActEnergyAvail(0.0);
			dc.setSendDrlcEnd(true);
			logger.debug("Optout flag for esiDcId during opt-out processing =  " + dc.getEsiDcId() + "/" + dc.getOptOutFlag());
			gwDCCache.put(new Element(dc.getCacheKey(), dc));
		}

		// now update all of the DC opt-out indicators
		OptOutIds optOutIds = updateOptOutFlags(dcCacheList, ceAccMapCacheList);

		if (!sendStopList.isEmpty())
		{
			try
			{
				controlEventBean.sendStopControlEvent(sendStopList, false);
			} catch (AbstractOpsCenterException e1)
			{
				logger.error("Unable to send stop CE for GS Dev Mode message to esi count=" + sendStopList.size(), e1);
			}
		}

		Results devResults = cacheManager.getCacheDataByAccMapId(cacheManager.getCeDevCache(), optOutIds.getCeAccountOptOuts());
		DateTime currTime = new DateTime();
		int clearCount = 0;
		for (Result devResult : devResults.all())
		{
			CEDevicesCacheData devMapCache = (CEDevicesCacheData) devResult.getValue();

			if (devMapCache == null)
			{
				continue;
			}

			// Need to delete device from cache b/c ce account map was removed
			// from cache
			if (devMapCache.getEndTime() > 0)
			{
				cacheManager.deleteCEDevicesCacheEntry(devMapCache.getCeDevicesId());
				continue;
			}

			int devId = devMapCache.getCeDevicesId();
			CeDevices ceDevice = controlEventBeanFacade.getRefCeDevicesByCeDevicesId(devId);

			CeDevicesLog ceDevicesLog = new CeDevicesLog();
			ControlEvent refControlEvent = controlEventBeanFacade.getRefControlEventByControlEventId(devMapCache.getCeId());
			ceDevicesLog.setControlEventId(refControlEvent);
			ceDevicesLog.setDateCreated(currTime);
			ceDevicesLog.setCeDevicesId(ceDevice);
			// krmt-2094-- add device name to log
			String devName = OpsCenterConstants.deviceTypeToNameMap.get(devMapCache.getDevTypeId());
			ceDevicesLog.setLogMessage("Device " + devName + " is exiting out of " + OpsCenterConstants.CE_NAME);

			// KRMT-2410: We don't have a definite event for when a device has
			// exited control. So we will just show drifting, opting out, &
			// stopping
			// The Esi will be the only log with the definitive Opted Out or
			// Stopped

			if (optOutIds.getStoppedCeAccMapIds().contains(devMapCache.getCeAccMapId()))
			{
				ceDevicesLog.setCeEsiStatusId(optOutIds.getStoppingCeEsiStatusId());
			}
			else
			{
				ceDevicesLog.setCeEsiStatusId(optOutIds.getOptingOutCeEsiStatusId());
			}

			cacheManager.deleteCEDevicesCacheEntry(ceDevice.getCeDevicesId());

			try
			{
				controlEventBeanFacade.createCeDevicesLog(ceDevicesLog);
			} catch (Exception e)
			{
				logException(e, ceDevicesLog.getLogMessage());

				logger.info("[ EXIT] ControlEventPowerBean.optOutGSDeviceFromCE");
				throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeDevicesLog = ");
			}

			clearCount++;
			if (clearCount > BATCH_SIZE_FLUSH)
			{
				clearCount = 0;
				entityManager.flush();
				entityManager.clear();
			}
		}
		devResults.discard();

		logger.info("[ EXIT] ControlEventPowerBean.optOutGSDeviceFromCE");
	}

	@Override
	public void checkCeTimeOnOptOut(EsiDcCacheData esiDcCacheData)
	{
		logger.info("[ENTER] checkCeTimeOnOptOut(EsiDcCacheData esiDcCacheData)");
		// All the groups in CE
		Results grpResults = cacheManager.getCacheDataByCeIdNotNull(cacheManager.getCeGrpCache());
		List<Integer> groupsIdsInCe = new ArrayList<Integer>();

		if (grpResults != null && grpResults.size() > 0)
		{
			for (Result grpResult : grpResults.all())
			{
				CEGroupCacheData ceGroupCache = (CEGroupCacheData) grpResult.getValue();
				groupsIdsInCe.add(ceGroupCache.getCeGrpId());
			}
		}

		// All the groups associated with the device
		List<Integer> groupList = esiDcCacheData.getGrpIdList();

		// Iterating through all the groups associated with the device
		if (groupList != null && groupList.size() > 0)
		{
			for (Integer ceGrpId : groupList)
			{
				if (groupsIdsInCe.contains(ceGrpId))
				{ // Looking at each group
					// if it is in CE
					int noOfDevices = 0;
					Element ceGrpEelement = cacheManager.getCeGrpCache().get(ceGrpId);
					CEGroupCacheData ceGroupCacheData = (CEGroupCacheData) ceGrpEelement.getObjectValue();

					int ceId = ceGroupCacheData.getCeId();

					Results esiDcList = cacheManager.getCacheDataByCeId(cacheManager.getGwDCCache(), ceId);
					for (Result esiDc : esiDcList.all())
					{
						EsiDcCacheData dcCacheData = (EsiDcCacheData) esiDc.getValue();
						List<Integer> grpList = dcCacheData.getGrpIdList();
						if (grpList.contains(ceGrpId))
						{
							noOfDevices++;
						}

					}
					StringBuilder sb = new StringBuilder();
					sb.append(" ... Total noOfDevices = " + noOfDevices);
					logger.debug(sb.toString());

					int originalCounter = ceGroupCacheData.getOptOutDeviceCounter();
					int incrementedCounter = originalCounter + 1;
					if (noOfDevices != 0)
					{ // Though it should not be zero here
						if (noOfDevices == incrementedCounter)
						{
							logger.debug("now we are calc for this grp after all dev opt out, grpid = " + ceGrpId);

							calculateTimeInCeForOptOut(ceGrpId);
							ceGroupCacheData.setCeTotalMinsCalculated(true);
						}
						else
						{
							ceGroupCacheData.setOptOutDeviceCounter(incrementedCounter);
							ceGroupCacheData.setCeTotalMinsCalculated(false);
						}
						// KGFR-73 must do a put to ensure other server sees
						// update
						Element grpElement = new Element(ceGroupCacheData.getCeGrpId(), ceGroupCacheData);
						cacheManager.getCeGrpCache().put(grpElement);
					}
				}
			}
		}
		logger.info("[EXIT] checkCeTimeOnOptOut(EsiDcCacheData esiDcCacheData)");
	}

	private OptOutIds updateOptOutFlags(List<EsiDcCacheData> dcCacheList, List<CEAccountMapCacheData> ceAccMapCacheList) throws AbstractOpsCenterException
	{
		// PHNX-28 STOPPING no more will be use so replacing STOPPING -> STOPPED
		CeEsiStatus stoppingCeEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.STOPPED).intValue());

		CeEsiStatus stoppedCeEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.STOPPED).intValue());
		// PHNX-28 OPTING_OUT no more will be use so replacing OPTING_OUT ->
		// OPTED_OUT
		CeEsiStatus optingOutCeEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.OPTED_OUT).intValue());

		DateTime currTime = new DateTime();

		OptOutIds optOutIds = new OptOutIds();
		optOutIds.setOptingOutCeEsiStatusId(optingOutCeEsiStatusId);
		optOutIds.setStoppedCeEsiStatusId(stoppedCeEsiStatusId);
		optOutIds.setStoppingCeEsiStatusId(stoppingCeEsiStatusId);

		// MISSING_READS, GUI, TSTAT_OVERRIDE, RELEASED, OUT_OF_SYNC
		List<Integer> ceAccountMissingReads = new ArrayList<Integer>();
		List<Integer> ceAccountGui = new ArrayList<Integer>();
		List<Integer> ceAccountTsat = new ArrayList<Integer>();
		List<Integer> ceAccountReleased = new ArrayList<Integer>();
		List<Integer> ceAccountOutOfSync = new ArrayList<Integer>();
		List<Integer> ceAccountOptOuts = new ArrayList<Integer>();
		List<Integer> ceAccountDoNotManage = new ArrayList<Integer>();
		List<Integer> ceAccountLostComms = new ArrayList<Integer>();
		List<Integer> ceAccountRejectedCeStart = new ArrayList<Integer>();

		Set<Integer> driftingEsiDcIds = new HashSet<Integer>();
		Set<Integer> tstatOverrideEsiDcIds = new HashSet<Integer>();
		Set<Integer> invalidReadsEsiDcIds = new HashSet<Integer>();

		Set<Integer> stoppedCeAccMapIds = new HashSet<Integer>();

		List<Integer> utilityDevOptOut = new ArrayList<Integer>();
		List<Integer> utilityReleased = new ArrayList<Integer>();

		int clearCount;
		clearCount = 0;
		CEDevicesCacheData ceDevMapCache = null;
		int size = dcCacheList.size();
		for (int i = 0; i < size; i++)
		{
			EsiDcCacheData dcCache = dcCacheList.get(i);
			Results devResults = cacheManager.getCacheDataByCeIdAndEsiDcId(cacheManager.getCeDevCache(), dcCache.getCeId(), dcCache.getEsiDcId());
			for (Result devResult : devResults.all())
			{
				ceDevMapCache = (CEDevicesCacheData) devResult.getValue();
				if (ceDevMapCache != null && ceDevMapCache.getEsiDcId() == dcCache.getEsiDcId())
				{
					break;
				}
			}

			if (ceDevMapCache == null)
			{
				logger.error("ceDevMapCache returned null in updateOptOutFlags");
				continue;
			}
			switch (dcCache.getOptOutReason())
			{
			case MISSING_READS:
				ceAccountMissingReads.add(ceDevMapCache.getCeDevicesId());
				break;
			case GUI:
				ceAccountGui.add(ceDevMapCache.getCeDevicesId());
				break;
			case TSTAT_OVERRIDE:
				ceAccountTsat.add(ceDevMapCache.getCeDevicesId());
				break;
			case RELEASED:
				ceAccountReleased.add(ceDevMapCache.getCeDevicesId());
				break;
			case OUT_OF_SYNC:
				ceAccountOutOfSync.add(ceDevMapCache.getCeDevicesId());
				break;
			case DO_NOT_MANAGE:
				ceAccountDoNotManage.add(ceDevMapCache.getCeDevicesId());
				break;
			case CANCEL_CE_FOR_DO_NOT_MANAGE:
				ceAccountDoNotManage.add(ceDevMapCache.getCeDevicesId());
				break;
			case LOST_COMMS:
				ceAccountLostComms.add(ceDevMapCache.getCeDevicesId());
				break;
			case REJECTED_CE_START_REQUEST:
				ceAccountRejectedCeStart.add(ceDevMapCache.getCeDevicesId());
				break;
			case UTILITY_RELEASED:
				utilityReleased.add(ceDevMapCache.getCeDevicesId());
				break;
			default:
				ceAccountOptOuts.add(ceDevMapCache.getCeDevicesId());
			}
			Results esiL = cacheManager.getCacheDataByEsiId(cacheManager.getGwEsiCache(), dcCache.getEsiId());
			if (esiL == null || esiL.size() <= 0)
			{
				logger.error("No ESI found in cache for esiDcId = " + dcCache.getEsiId() + " Cant record optout info");
				continue;
			}

			// there should only be one entry in this Result list
			EsiCacheData esiCache = null;
			boolean allDcOptOut = true;
			for (Result esi : esiL.all())
			{
				esiCache = (EsiCacheData) esi.getValue();
				// now determine if all of the DCs for an esi have opted out,
				// only then do we delete the ceAccountMap from cache
				Results esiDcList = cacheManager.getCacheDataByEsiId(cacheManager.getGwDCCache(), esiCache.getEsiId());
				for (Result esiDc : esiDcList.all())
				{
					EsiDcCacheData dcCacheData = (EsiDcCacheData) esiDc.getValue();
					if (OpsCenterConstants.FALSE.equals(dcCacheData.getOptOutFlag()) && OpsCenterConstants.ESI_MODE_CONTROL == dcCacheData.getDcMode())
					{
						allDcOptOut = false;
						break;
					}
					continue;
				}

			}

			if (esiCache == null)
			{
				logger.error("esiCache returned null in updateOptOutFlags");
				continue;
			}
			Map<Integer, EsiDcFlagCacheData> esiDcFlagByEsiDcId = esiCache.getCeFlagsByEsiDcId();
			for (EsiDcFlagCacheData esiDcFlagCacheData : esiDcFlagByEsiDcId.values())
			{
				switch (esiDcFlagCacheData.getCeFlag())
				{
				case OpsCenterConstants.CE_ESI_DC_FLAG_INVALID_READS:
					invalidReadsEsiDcIds.add(esiDcFlagCacheData.getEsiDcId());
					break;
				case OpsCenterConstants.CE_ESI_DC_FLAG_TSTAT_DRIFTING:
					driftingEsiDcIds.add(esiDcFlagCacheData.getEsiDcId());
					break;
				case OpsCenterConstants.CE_ESI_DC_FLAG_TSTAT_OVERRIDE:
					tstatOverrideEsiDcIds.add(esiDcFlagCacheData.getEsiDcId());
					break;
				default:
					break;
				}
			}
			// first log the optedout ESI in DB
			CeEsiLog esiLog = new CeEsiLog();
			ControlEvent refControlEvent = controlEventBeanFacade.getRefControlEventByControlEventId(ceDevMapCache.getCeId());
			esiLog.setControlEventId(refControlEvent);
			esiLog.setDateCreated(currTime);
			esiLog.setEsiId(controlEventBeanFacade.getRefEsiByEsiId(esiCache.getEsiId()));
			// If ESI Mode not equal Control then assuming that this is an
			// out-of-sync condition
			if (OpsCenterConstants.ESI_MODE_CONTROL == dcCache.getDcMode())
			{
				esiLog.setLogMessage("Device is Opting out of " + OpsCenterConstants.CE_NAME);
				esiLog.setCeEsiStatusId(optingOutCeEsiStatusId);
			}
			else
			{
				esiLog.setLogMessage("Device has Stopped participating in the " + OpsCenterConstants.CE_NAME);
				esiLog.setCeEsiStatusId(stoppedCeEsiStatusId);
				stoppedCeAccMapIds.add(ceDevMapCache.getCeDevicesId());
				optOutIds.setStoppedCeAccMapIds(stoppedCeAccMapIds);

			}

			try
			{
				controlEventBeanFacade.createCeEsiLog(esiLog);
			} catch (Exception e)
			{
				logException(e, esiLog.getLogMessage());

				throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for CeEsiLog = ");
			}

			clearCount++;
			if (clearCount > BATCH_SIZE_FLUSH)
			{
				clearCount = 0;
				entityManager.flush();
				entityManager.clear();
			}

			esiCache.setCeAccountMapId(0);
			esiCache.setCeDeviceMqIds(null);
			// esiCache.setDutyCycle(0); We don't set DutyCycle to 0 when Optout
			// but only while stop event, please refer DEV-2926 DEV-3124.
			// set the hb flag now for all esi, to prepare for next evt they get
			// added to

			Element esiElement = new Element(esiCache.getCacheKey(), esiCache); // cacheManager.getGwEsiCache().get(esiCache.getCacheKey());
			cacheManager.getGwEsiCache().put(esiElement);
			if (allDcOptOut)
			{
				// delete ceAccMapCache entry--
				cacheManager.deleteCEAccountMapCacheEntry(ceDevMapCache.getCeAccMapId());
				logger.debug("CeAccountMapCache has been deleted for  esiDcId / CeAccMapId = " + dcCache.getEsiDcId() + "/" + ceDevMapCache.getCeAccMapId());
			}
			// added for GS devices-must update cache for CeDevices here for
			// endTime
			Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), ceDevMapCache.getEsiDcId());
			for (Result dcResult : esiDcResults.all())
			{
				EsiDcCacheData dcCacheData = (EsiDcCacheData) dcResult.getValue();
				if (dcCacheData != null && dcCacheData.getDeviceMacId() != 0)
				{
					// must set ceDevicesCache.endTime to current time to
					// indicate that the GS device has
					// exited the CE
					logger.debug("found GS leg for optout setting ceEndtime  ");

					ceDevMapCache.setEndTime(currTime.getMillis());
					Element devlement = new Element(ceDevMapCache.getCeDevicesId(), ceDevMapCache);
					cacheManager.getCeDevCache().put(devlement);
				}

			}
			esiDcResults.discard();

		}

		if (!ceAccountOptOuts.isEmpty())
		{
			logger.debug("Regular opt out, dev count=" + ceAccountOptOuts.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountOptOuts, currTime, OpsCenterConstants.TRUE,
					OpsCenterConstants.OptOutReason.ACCOUNT_OPTOUT);
		}
		if (!ceAccountMissingReads.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountMissingReads);
			logger.debug("Missing read opt out, dev count=" + ceAccountMissingReads.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountMissingReads, currTime, OpsCenterConstants.TRUE,
					OpsCenterConstants.OptOutReason.MISSING_READS);
		}
		if (!ceAccountGui.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountGui);
			logger.debug("GUI opt out, dev count=" + ceAccountGui.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountGui, currTime, OpsCenterConstants.FALSE, OpsCenterConstants.OptOutReason.GUI);
		}
		if (!ceAccountTsat.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountTsat);
			logger.debug("Whole house tstat opt out, dev count=" + ceAccountTsat.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountTsat, currTime, OpsCenterConstants.TRUE, OpsCenterConstants.OptOutReason.TSTAT_OVERRIDE);
		}
		if (!ceAccountReleased.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountReleased);
			logger.debug("Released, dev count=" + ceAccountReleased.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountReleased, currTime, OpsCenterConstants.FALSE, OpsCenterConstants.OptOutReason.RELEASED);
		}
		if (!ceAccountOutOfSync.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountOutOfSync);
			logger.debug("Out of Sync opt out, dev count=" + ceAccountOutOfSync.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountOutOfSync, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.OUT_OF_SYNC);
		}
		if (!ceAccountDoNotManage.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountDoNotManage);
			logger.debug("Do Not Manage opt out, dev count=" + ceAccountDoNotManage.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountDoNotManage, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.DO_NOT_MANAGE);
		}
		if (!ceAccountLostComms.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountLostComms);
			logger.debug("Lost Comms opt out, dev count=" + ceAccountLostComms.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountLostComms, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.LOST_COMMS);
		}

		if (!ceAccountRejectedCeStart.isEmpty())
		{
			ceAccountOptOuts.addAll(ceAccountRejectedCeStart);
			logger.debug("GW Rejected CE Start, dev count=" + ceAccountRejectedCeStart.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(ceAccountLostComms, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.REJECTED_CE_START_REQUEST);
		}

		if (!utilityDevOptOut.isEmpty())
		{
			ceAccountOptOuts.addAll(utilityDevOptOut);
			logger.debug("Utility device opt-out, dev count=" + utilityDevOptOut.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(utilityDevOptOut, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.UTILITY_DEV_OPTOUT);
		}
		if (!utilityReleased.isEmpty())
		{
			ceAccountOptOuts.addAll(utilityReleased);
			logger.debug("Utility released the grp" + utilityReleased.size());
			controlEventBeanFacade.updateCeDevicesOptOutFlags(utilityReleased, currTime, OpsCenterConstants.FALSE,
					OpsCenterConstants.OptOutReason.UTILITY_RELEASED);
		}
		optOutIds.setCeAccountOptOuts(ceAccountOptOuts);

		Results devResults = cacheManager.getCacheDataByAccMapId(cacheManager.getCeDevCache(), ceAccountOptOuts);

		// Update the CE Devices with flags to handle 2 uses cases:
		// 1) The last device for a gw in a CE gets flagged for opt out, so opt
		// out entire esi
		// 2) If whole house opt out on tstat override, Ops will flag the tstat
		// that opted out
		updateCeDevicesWithFlags(devResults.all(), driftingEsiDcIds, tstatOverrideEsiDcIds, invalidReadsEsiDcIds, currTime);

		// Update the CE Devices w/o flags
		controlEventBeanFacade.updateCeDevicesStopTimes(ceAccountOptOuts, currTime);

		return optOutIds;
	}

	/**
	 * This method is passed in a list of EsiCacheData, all the ones that
	 * drifted, had a tstatOverriden, or had too many invalid reads. It then
	 * uses CeDevicesCacheData.endTime to determine the subset which has
	 * occurred since the last time this method was run
	 */
	@Override
	public void handleTstatAndReplacePowerForCe(List<EsiCacheData> esiCacheList, List<CEAccountMapCacheData> ceAccMapCacheList, Set<Integer> driftingEsiDcIds,
			Set<Integer> tstatOverrideEsiDcIds, Set<Integer> invalidReadsEsiDcIds) throws AbstractOpsCenterException
	{

		logger.info("Entering handleTstatAndReplacePowerForCe driftingEsiDcIds.size=" + driftingEsiDcIds.size() + "\ttstatOverrideEsiDcIds.size="
				+ tstatOverrideEsiDcIds.size() + "\tinvalidReadsEsiDcIds.size=" + invalidReadsEsiDcIds.size());

		// Create a single status object here and reuse it for each drifted
		// account map log.

		CeEsiStatus ceEsiStatusIdDrifting = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.DRIFTED).intValue());

		DateTime currTime = new DateTime();

		// Convert from a list of account maps to a list of account map IDs.
		List<Integer> ceAccountMapIds = new ArrayList<Integer>();

		// This is a map of all devics that have drifted or have invalid reads
		Map<Integer, EsiCacheData> esiCacheByEsiDcId = new HashMap<Integer, EsiCacheData>();

		int clearCount = 0;

		// Cycle through the ESI-DC list and the corresponding account map list.
		// Get the account map drift indicator in synch with the ESI-DC drift
		// indicator.

		// hmbrd-758
		List<EsiCacheData> gsEsiCancelList = new ArrayList<EsiCacheData>();
		int size = esiCacheList.size();

		for (int i = 0; i < size; i++)
		{
			EsiCacheData esiCache = esiCacheList.get(i);
			CEAccountMapCacheData ceAccMapCache = ceAccMapCacheList.get(i);

			// Does the ESI DC indicate a drift
			boolean esiDcDrift = false;
			Map<Integer, EsiDcFlagCacheData> ceFlagsByEsiDcId = esiCache.getCeFlagsByEsiDcId();
			for (EsiDcFlagCacheData esiDcFlag : ceFlagsByEsiDcId.values())
			{
				int flag = esiDcFlag.getCeFlag();
				if (flag == OpsCenterConstants.CE_ESI_DC_FLAG_TSTAT_DRIFTING)
				{
					esiDcDrift = true;
					// go ahead and clear the drifting flags now
					for (Integer id : driftingEsiDcIds)
					{
						if (esiDcFlag.getEsiDcId() == id)
						{
							esiDcFlag.setCeFlag(0);
							ceFlagsByEsiDcId.put(id, esiDcFlag);
							Integer rmmDcId = convertTstatToDc(id);
							logger.debug("just cleared drifting flag for tstatdcId " + id);
							Element esilement = new Element(esiCache.getCacheKey(), esiCache);
							cacheManager.getGwEsiCache().put(esilement);
							if (esiCacheByEsiDcId.get(rmmDcId) != esiCache && esiCache.getNwType().equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
							{
								setEsiDcSendDRLCEnd(rmmDcId);

							}
							break;
						}
					}
				}

				// do not add drifting ESIs to esiCacheByEsiDcId since we dont
				// want to tell GW
				// to exit ctrl-- keep them at max temp, event after drifting
				// krmt-4627
				// now for GS devices, we must search for power to replace using
				// the DC not the TSTAT, so
				// convert each of the following arrays from tstat to dc
				if (flag == OpsCenterConstants.CE_ESI_DC_FLAG_TSTAT_OVERRIDE)
				{
					logger.debug("size of tstatOverrideEsiDcIds = " + tstatOverrideEsiDcIds.size());
					for (Integer id : tstatOverrideEsiDcIds)
					{
						if (esiDcFlag.getEsiDcId() == id)
						{
							esiDcFlag.setCeFlag(0);
							ceFlagsByEsiDcId.put(id, esiDcFlag);
							esiCache.setCeFlagsByEsiDcId(ceFlagsByEsiDcId);
							logger.debug("just cleared override flag for tstatdcId " + id);
							Element esilement = new Element(esiCache.getCacheKey(), esiCache);
							cacheManager.getGwEsiCache().put(esilement);
							Integer rmmDcId = convertTstatToDc(id);
							// we only want to send DRLC end for GS dev which
							// have been overriden
							if (esiCacheByEsiDcId.get(rmmDcId) != esiCache && esiCache.getNwType().equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
							{
								esiCacheByEsiDcId.put(rmmDcId, esiCache);
								// now set the indicator to send a DRLC end for
								// GS DCs ONLY
								setEsiDcSendDRLCEnd(rmmDcId);
								setEsiDcOptOutReason(rmmDcId);
								gsEsiCancelList.add(esiCache);
							}
							break;
						}
					}

				}
				// now we must clear the override flag since we just added this
				// dc to the above list to take him
				// out of the evnt for GS devices
				Results esiTstatIdResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGsTstatCache(), esiDcFlag.getEsiDcId());
				for (Result tstatResult : esiTstatIdResults.all())
				{
					GridStreamTstatCacheData tstatCacheData = (GridStreamTstatCacheData) tstatResult.getValue();
					if (tstatCacheData != null && tstatCacheData.getDeviceMacId() != 0)
					{
						// now find correspoing TSTAT
						tstatCacheData.setTstatOverride(false);
						Element ele = new Element(tstatCacheData.getCacheKey(), tstatCacheData);
						cacheManager.getGsTstatCache().put(ele);
					}
				}

				if (flag == OpsCenterConstants.CE_ESI_DC_FLAG_INVALID_READS)
				{
					for (Integer id : invalidReadsEsiDcIds)
					{
						if (esiDcFlag.getEsiDcId() == id)
						{
							esiDcFlag.setCeFlag(0);
							ceFlagsByEsiDcId.put(id, esiDcFlag);
							esiCache.setCeFlagsByEsiDcId(ceFlagsByEsiDcId);
							logger.debug("just cleared override flag for tstatdcId " + id);
							Element esilement = new Element(esiCache.getCacheKey(), esiCache);
							cacheManager.getGwEsiCache().put(esilement);
							Integer rmmDcId = convertTstatToDc(id);
							if (esiCacheByEsiDcId.get(rmmDcId) != esiCache && esiCache.getNwType().equals(OpsCenterConstants.GRIDSTREAM_RF_DELIVERY))
							{
								esiCacheByEsiDcId.put(rmmDcId, esiCache);
								// now set the indicator to send a DRLC end for
								// GS DCs ONLY
								setEsiDcSendDRLCEnd(rmmDcId);
								// only add to list if not already in list
								if (!gsEsiCancelList.contains(esiCache))
									gsEsiCancelList.add(esiCache);

							}
							break;
						}
					}
				}
				esiTstatIdResults.discard();
			}

			// Does the account map indicate a drift
			boolean accMapDrift = ceAccMapCache.isHasDrifted();

			// If the ESI indicates a drift but the account map does not, set
			// the account map to
			// drifted and update the account map in the cache and DB.
			if (esiDcDrift && !accMapDrift)
			{

				logger.debug("ESI has drifted, gwMqId = " + esiCache.getEsiGatewayMQId());

				ceAccMapCache.setHasDrifted(true);
				cacheManager.getCeAccMapCache().put(new Element(ceAccMapCache.getCeAccMapId(), ceAccMapCache));

				CeEsiLog ceEsiLog = new CeEsiLog();
				ceEsiLog.setCeEsiStatusId(ceEsiStatusIdDrifting);
				ceEsiLog.setControlEventId(controlEventBeanFacade.getRefControlEventByControlEventId(ceAccMapCache.getCeId()));
				ceEsiLog.setDateCreated(currTime);
				Esi esi = esiBeanFacade.getRefEsiByEsiId(esiCache.getEsiId());
				ceEsiLog.setEsiId(esi);
				ceEsiLog.setLogMessage("This gateway has a device that drifted up and exited from the " + OpsCenterConstants.CE_NAME);

				controlEventBeanFacade.createCeEsiLog(ceEsiLog);

				clearCount++;
				if (clearCount > BATCH_SIZE_FLUSH)
				{
					clearCount = 0;
					entityManager.flush();
					entityManager.clear();
				}
			}

			ceAccountMapIds.add(ceAccMapCache.getCeAccMapId());
		}

		logger.debug("size of tstatOverrideEsiDcIds = " + tstatOverrideEsiDcIds.size());
		// This section of code gets us the list of devices that need
		// a control message. The code segment takes the existing device list
		// and removed Do Not Manage devices to create a list.
		Results ceDevicesResults = cacheManager.getCacheDataByAccMapIdAndNotEnded(cacheManager.getCeDevCache(), ceAccountMapIds);
		List<Result> ceDevicesResultList = ceDevicesResults.all();
		// This method updates the status of CE devices in the cache and DB.
		// Just as important, it sums up the power used by those devices and
		// organizes
		// the power values by group - returning powerToReplaceByGroupMap.
		Map<Integer, Double> powerToReplaceByGroupMap = updateCeDevicesWithFlags(ceDevicesResultList, driftingEsiDcIds, tstatOverrideEsiDcIds,
				invalidReadsEsiDcIds, currTime);

		HashSet<EsiCacheData> esiCacheNeedingUpdatedControlMessage = new HashSet<EsiCacheData>(ceDevicesResultList.size());
		logger.debug("size of CeDevicesCache = " + ceDevicesResultList.size());

		for (Result result : ceDevicesResultList)
		{
			CEDevicesCacheData ceDevicesCache = (CEDevicesCacheData) result.getValue();
			EsiCacheData esiCacheData = esiCacheByEsiDcId.get(ceDevicesCache.getEsiDcId());

			// if mode = unmanaged, do not add to list, as esi is already out of
			// CE during
			// setting of DNM mode and no additional msg is required to GW
			if (esiCacheData != null)
			{
				logger.debug("adding exit control list, esiId = " + esiCacheData.getEsiId());
				esiCacheNeedingUpdatedControlMessage.add(esiCacheData);
			}

		}
		// hmbrd-758
		// this list contains those ESI which need a DRLC cancel but have
		// drifted and ceDevices in DB already has a non
		// null entry in the DB-- must include them to send DRLC cancel
		for (EsiCacheData esiCache : gsEsiCancelList)
		{
			if (!esiCacheNeedingUpdatedControlMessage.contains(esiCache))
				esiCacheNeedingUpdatedControlMessage.add(esiCache);
		}

		// send DRLC cancel CE for all esi/devices in below list
		controlEventBean.sendStopControlEventForIndDeviceOptOutsBulk(esiCacheNeedingUpdatedControlMessage, tstatOverrideEsiDcIds);

		ceDevicesResults.discard();
		esiCacheNeedingUpdatedControlMessage.clear();
		// Now that we have the power to replace organized by group, go ahead
		// and to it.
		Set<Integer> ceGroupIdSet = powerToReplaceByGroupMap.keySet();

		for (Integer ceGroupMapId : ceGroupIdSet)
		{
			// CeGroupMap ceGrpMap =
			// controlEventBeanFacade.findCeGroupMapByCeGroupMapId(ceGroupMapId);
			double replacedPower = replacePowerForOptOut(ceGroupMapId, powerToReplaceByGroupMap.get(ceGroupMapId));
			logger.info("handleTstatAndReplacePowerForCe: Replaced Power = " + replacedPower + " for CeGroupMapId=" + ceGroupMapId);
		}

		logger.info("Exiting handleTstatAndReplacePowerForCe");
	}

	private Integer convertTstatToDc(Integer tstatDcId)
	{

		Integer tmpDcId = null;
		Results esiTstatIdResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGsTstatCache(), tstatDcId);
		for (Result tstatResult : esiTstatIdResults.all())
		{
			GridStreamTstatCacheData tstatCacheData = (GridStreamTstatCacheData) tstatResult.getValue();
			if (tstatCacheData != null && tstatCacheData.getDeviceMacId() != 0)
			{
				tmpDcId = tstatCacheData.getEsiHvacDcId();
				logger.debug("adding RMM esiDCId to hash " + tstatCacheData.getEsiHvacDcId());
			}

		}

		// if we dont find any GS tstat, go ahead and restore the original hash
		if (tmpDcId == null)
		{
			tmpDcId = tstatDcId;
		}
		esiTstatIdResults.discard();

		return tmpDcId;

	}

	private void setEsiDcSendDRLCEnd(Integer esiDcId)
	{

		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), esiDcId);
		for (Result dcResult : esiDcResults.all())
		{
			EsiDcCacheData dcCacheData = (EsiDcCacheData) dcResult.getValue();
			if (dcCacheData != null && dcCacheData.getDeviceMacId() != 0)
			{
				dcCacheData.setSendDrlcEnd(true);
			}
		}
		esiDcResults.discard();

	}

	/**
	 * @param driftingEsiDcIds
	 * @param tstatOverrideEsiDcIds
	 * @param invalidReadsEsiDcIds
	 * @param ceEsiStatusIdDrifting
	 * @param ceEsiStatusIdOptingOut
	 * @param currTime
	 * @param clearCount
	 * @param ceDevicesResults
	 * @return
	 */
	private Map<Integer, Double> updateCeDevicesWithFlags(List<Result> ceDevicesResults, Set<Integer> driftingEsiDcIds, Set<Integer> tstatOverrideEsiDcIds,
			Set<Integer> invalidReadsEsiDcIds, DateTime currTime)
	{

		int clearCount = 0;

		// in R3.2, no need to show drifting....
		CeEsiStatus ceEsiStatusIdDrifted = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.DRIFTED).intValue());
		// PHNX-28 OPTING_OUT no more will be use so replacing OPTING_OUT ->
		// OPTED_OUT
		CeEsiStatus ceEsiStatusIdOptingOut = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.OPTED_OUT).intValue());

		List<Integer> ceDevicesDrifts = new ArrayList<Integer>();
		List<Integer> ceTstatOptOuts = new ArrayList<Integer>();
		List<Integer> ceInvalidReadsOptOuts = new ArrayList<Integer>();

		Map<Integer, Double> powerToReplaceByGroupMap = new HashMap<Integer, Double>();
		for (Result ceDevResult : ceDevicesResults)
		{
			CEDevicesCacheData ceDevicesCache = (CEDevicesCacheData) ceDevResult.getValue();
			boolean drift = driftingEsiDcIds.contains(ceDevicesCache.getEsiDcId());
			boolean tstatOverride = tstatOverrideEsiDcIds.contains(ceDevicesCache.getEsiDcId());
			boolean invalidReads = invalidReadsEsiDcIds.contains(ceDevicesCache.getEsiDcId());

			if (drift || tstatOverride || invalidReads)
			{
				// Only write DB entry once
				if (ceDevicesCache.getEndTime() > 0)
				{
					continue;
				}

				if (drift)
				{
					ceDevicesCache.setDriftPowerConsumed(ceDevicesCache.getIntialPowerRemoveable());
					ceDevicesCache.setHasDrifted(true);
				}

				ceDevicesCache.setEndTime(currTime.getMillis());
				Element devlement = new Element(ceDevicesCache.getCeDevicesId(), ceDevicesCache);
				cacheManager.getCeDevCache().put(devlement);

				CeDevicesLog ceDevicesLog = new CeDevicesLog();
				ceDevicesLog.setControlEventId(controlEventBeanFacade.getRefControlEventByControlEventId(ceDevicesCache.getCeId()));
				ceDevicesLog.setDateCreated(currTime);
				ceDevicesLog.setCeDevicesId(controlEventBeanFacade.getRefCeDevicesByCeDevicesId(ceDevicesCache.getCeDevicesId()));

				String devName = OpsCenterConstants.deviceTypeToNameMap.get(ceDevicesCache.getDevTypeId());
				ceDevicesLog.setLogMessage("Device " + devName + (drift ? " has drifted up" : " is exiting") + " out of " + OpsCenterConstants.CE_NAME);
				ceDevicesLog.setCeEsiStatusId(drift ? ceEsiStatusIdDrifted : ceEsiStatusIdOptingOut);
				controlEventBeanFacade.createCeDevicesLog(ceDevicesLog);

				int ceDevicesId = ceDevicesCache.getCeDevicesId();
				if (drift)
				{
					ceDevicesDrifts.add(ceDevicesId);
				}
				else if (tstatOverride)
				{
					ceTstatOptOuts.add(ceDevicesId);
				}
				else
				{
					ceInvalidReadsOptOuts.add(ceDevicesId);
				}

				clearCount++;
				if (clearCount > BATCH_SIZE_FLUSH)
				{
					clearCount = 0;
					entityManager.flush();
					entityManager.clear();
				}

				Double powerToReplace = powerToReplaceByGroupMap.get(ceDevicesCache.getCeGroupMapId());
				if (powerToReplace == null)
				{
					powerToReplace = 0.0;
				}
				// here we need to determine if we need to add the acc to the
				// powerToReplaceByGroupMap only if
				// individual opt out is NOT in affect-- ie we do not want to
				// replace power for a GW which had
				// a tstat-opt and whole GW did not opt-out
				boolean individualTstatOptOut = OpsCenterConstants.TRUE.equals(genericBean.getUtilityCeIndividualTstatOptOut());
				boolean cycling = false;
				Results ceGrpMapResults = cacheManager.getCacheDataByGrpMapId(cacheManager.getCeGrpMapCache(), ceDevicesCache.getCeGroupMapId());
				// we should get only one entry returned from this cache search
				for (Result ceGrpMapResult : ceGrpMapResults.all())
				{

					CEGroupMapCacheData ceGrpMapCacheData = (CEGroupMapCacheData) ceGrpMapResult.getValue();
					if (ceGrpMapCacheData == null)
					{
						continue;
					}
					cycling = ceGrpMapCacheData.getDutyCycle() > 0;
				}
				if (cycling && !individualTstatOptOut || !cycling)
				{

					powerToReplaceByGroupMap.put(ceDevicesCache.getCeGroupMapId(), powerToReplace + ceDevicesCache.getIntialPowerRemoveable());
				}
			}
		}

		controlEventBeanFacade.updateCeDevicesStopTimesAndDriftPowerById(ceDevicesDrifts, currTime);
		controlEventBeanFacade.updateCeDevicesStopTimesAndTstatOptOutById(ceTstatOptOuts, currTime);
		controlEventBeanFacade.updateCeDevicesStopTimesAndInvalidReadsById(ceInvalidReadsOptOuts, currTime);
		return powerToReplaceByGroupMap;
	}

	/**
	 * For a given CE Group replace power to account for opt outs.
	 */
	@Asynchronous
	public void replacePowerForOptOutNewThread(int ceGroupMapId, double powerLost, Integer tenantId)
	{

		TenantContext.setCurrentTenant(tenantId);
		replacePowerForOptOut(ceGroupMapId, powerLost);
	}

	@SuppressWarnings("synthetic-access")
	@Override
	public double replacePowerForOptOut(int ceGroupMapId, double powerLost)
	{

		CeGroupMap ceGrpMap = controlEventBeanFacade.findCeGroupMapByCeGroupMapId(ceGroupMapId);
		ControlEvent ce = ceGrpMap.getControlEventId();

		if (ce.getStopTime().getMillis() <= System.currentTimeMillis())
		{
			return 0.0;
		}

		// Find the user record for the modifying user
		User user = null;
		try
		{
			user = userAccBeanFacade.findUserByUsername(ce.getUserModified());
		} catch (UserNotUniqueException e)
		{
			logger.error("replacePowerForOptOut: Error retrieving user at replacePowerForOptOut: " + e.getMessage());
			e.printStackTrace();

			logger.error("replacePowerForOptOut: User not found at replacePowerForOptOut: " + ce.getUserModified());
			return 0.0;
		}

		// Power lost is simply recorded. It is not used to calculate power to
		// replace.
		logger.info("Entering  replacePowerForOptOut: ceGroupMapId=" + ceGroupMapId + ", powerLost= " + powerLost);

		// Find out how much power we need by determining the groups obligation,
		// how much the group is providing, and making up the difference.
		double powerNeededForGroup = ceGrpMap.getPowerToRemove();
		double powerRemovedForGroup = getPowerRemovedByCeGroupMapId(ceGrpMap.getCeGroupMapId());
		double powerToRemove = powerNeededForGroup - powerRemovedForGroup;
		boolean cycling = OpsCenterConstants.TRUE.equals(ce.getCycling());

		logger.debug("replacePowerForOptOut: ceGroupId=" + ceGrpMap.getCeGroupId() + ", powerNeededForGroup=" + powerNeededForGroup + ", powerRemovedForGroup="
				+ powerRemovedForGroup + ", powerToRemove=" + powerToRemove + ", cycling =" + cycling);

		// If we have to provide power, do so.
		// powerLost will also be used only if power request to remove is less
		// than
		// power being contributed by each acc/dev(see computation above)
		if (powerToRemove <= 0.0)
		{
			powerToRemove = powerLost;
		}

		double powerRemoved = 0.0;
		if (powerToRemove > 0.0 || cycling)
		{
			DateTime currTime = new DateTime();
			GroupPowerGatewayData grpPowerData = new GroupPowerGatewayData();
			grpPowerData.setGrpPowerToRemove(powerToRemove);
			grpPowerData.setGatheringNewlyAddedEsis(true);

			Collection<String> ceTypeSet = getDeviceClass(ce);
			logger.debug("replacePowerForOptOut: Looking for ESIs with power for types: " + ceTypeSet);
			if (cycling)
			{
				try
				{
					grpPowerData = addDevicesToCyclingCE(ceGrpMap, grpPowerData, currTime, user.getUserId());
				} catch (AbstractOpsCenterException e1)
				{
					e1.printStackTrace();
				}
			}
			else
			{
				try
				{
					grpPowerData = addDevicesToCe(ceGrpMap, grpPowerData, currTime, user.getUserId(), null, false);
				} catch (AbstractOpsCenterException e)
				{
					logger.error("replacePowerForOptOut: Error retrieving grpPowerData at replacePowerForOptOut: " + e.getMessage());
					e.printStackTrace();

					logger.error("replacePowerForOptOut: grpPowerData not found at replacePowerForOptOut: " + ce.getUserModified());
					return 0.0;
				}
				powerRemoved = grpPowerData.getGrpPowerRemoved();
			}

			logger.debug("powerRemove after replace logic =  " + powerRemoved);
			List<EsiCacheData> newEsiCacheDataList = grpPowerData.getNewEsiCacheDataList();

			if ((powerRemoved > 0.0 || cycling) && !newEsiCacheDataList.isEmpty())
			{
				for (EsiCacheData esi : newEsiCacheDataList)
				{

					Element ele = new Element(esi.getCacheKey(), esi);
					// must flush esi cache setting to cache now
					cacheManager.getGwEsiCache().put(ele);

				}

				// this is a trick to sleep here for 10 sec and give time
				// for the tables to get populated
				// when a new device is added to a CE before sending the ce
				// start
				try
				{
					Thread.sleep(10 * 1000L);
				} catch (InterruptedException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				// now schedule the CE so that it will include the newly added
				// ESIs
				try
				{
					controlEventBean.sendStartControlEvent(newEsiCacheDataList);
				} catch (AbstractOpsCenterException e)
				{
					logger.error(
							"replacePowerForOptOut: Unable to schedule CE, new Esi to replace opt out power will not be added to CE, until next heartbeat", e);
				}
			}

			logger.debug("replacePowerForOptOut: ceGroupMapId=" + ceGroupMapId + ", powerToRemove=" + grpPowerData.grpPowerToRemove + ", powerRemoved="
					+ powerRemoved);
		}
		logger.debug("Exiting replacePowerForOptOut");
		return powerRemoved;
	}

	/**
	 * Sum of the power removed for this group.
	 *
	 * @param ceGroupMapId
	 * @param accMapIdList
	 * @return
	 */
	private double getPowerRemovedByCeGroupMapId(int grpMapId)
	{
		double devicePowerRemoved = 0.0;

		// Iterate through all of the devices in this group and total the
		// initial power removed. The sum is the power removed by this group.
		Results devicesByGrpMapId = cacheManager.getCacheDataByGrpMapIdAndNotEnded(cacheManager.getCeDevCache(), grpMapId);
		for (Result device : devicesByGrpMapId.all())
		{
			CEDevicesCacheData ceDevicesCacheData = (CEDevicesCacheData) device.getValue();
			if (ceDevicesCacheData == null)
			{
				logger.error("Null CEDevicesCacheData entry trying to retrieve powerRemoved");
				continue;
			}
			devicePowerRemoved += ceDevicesCacheData.getIntialPowerRemoveable();
		}
		devicesByGrpMapId.discard();

		return devicePowerRemoved;
	}

	/**
	 * Backwards compatibility - editing a control event used to work upwards
	 * only
	 */
	@Override
	public ControlEventModel editControlEvent(ControlEventEditModel ceEditModel, Integer tenantId) throws AbstractOpsCenterException
	{
		TenantContext.setCurrentTenant(tenantId);
		return editControlEventIncreasePowerToRemove(ceEditModel);
	}

	/**
	 * Request to remove more power for a control event
	 */
	@Override
	public ControlEventModel editControlEventIncreasePowerToRemove(ControlEventEditModel ceEditModel) throws AbstractOpsCenterException
	{
		logger.info("Entering editControlEvent(" + ceEditModel.getCeId() + ")");

		// For VPP percentage events, check the total power to remove
		// to make sure it's a valid value (between 0 and 100)
		if (ceEditModel.getPowerRequestedInPercent().equals(OpsCenterConstants.TRUE))
		{
			for (GroupPowerModel group : ceEditModel.getGroupPowerList())
			{
				double powerToRemove = group.getInitialPowerToRemove() + group.getAdditionalPowerToRemove();

				if (powerToRemove <= 0.0 || powerToRemove > 100.0)
				{
					logger.error("Cannot edit VPP percentage event with total power to remove less than 0 or greater than 100");
					logger.info("[ EXIT] ControlEventPowerBean.startControlEvent");
					throw new ControlEventPercentPowerToRemoveExceeded(DefaultResources.CEV_ERR_CODE_CE_PERCENT_POWER_EXCEEDED,
							"Cannot edit VPP percentage event with total power to remove less than 0 or greater than 100");
				}
				else if (group.getAdditionalPowerToRemove() < 0.0)
				{
					logger.error("Cannot reduce power to remove in VPP percentage event");
					logger.info("[ EXIT] ControlEventPowerBean.startControlEvent");
					throw new ControlEventPercentPowerToRemoveExceeded(DefaultResources.CEV_ERR_CODE_CE_PERCENT_POWER_EXCEEDED,
							"Cannot reduce power to remove in VPP percentage event");
				}
			}
		}

		ControlEvent ce = getControlEvent(ceEditModel.getCeId());
		if (ce == null)
		{
			throw new ControlEventNotFoundException("No control event found for edit: " + ceEditModel.getCeId());
		}

		// Check for conflicting use of CE groups
		checkForConflictedCEGroups(ce.getControlEventId(), ce.getStartTime(), ce.getStopTime(), ceEditModel.getGroupPowerList());

		if (ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_CANCELED)
				|| ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_STOPPED)
				|| ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_ENDED))
		{
			throw new ControlEventStoppedException("Before this Edit " + OpsCenterConstants.CE_NAME + " executed, Ops noticed " + OpsCenterConstants.CE_NAME
					+ " (id=" + ceEditModel.getCeId() + ") is in a state");
		}

		// This code makes sure that we don't remove a device type
		List<String> addedTypes = new ArrayList<String>();
		LinkedHashMap<String, String> ceTypeMap = new LinkedHashMap<String, String>();
		// create an instance of the entity
		Collection<String> ceTypeSet = ceEditModel.getTargetDeviceTypeIDs().keySet();

		ceTypeMap = ce.getCEMapping();
		for (String currClass : ceTypeSet)
		{
			logger.debug("Edit Model passed in class = " + currClass);
			if (!ceTypeMap.containsKey(currClass))
			{
				addedTypes.add(currClass);
				ceTypeMap.put(currClass, OpsCenterConstants.TRUE);
				logger.debug("Added new dev Class = " + currClass);
			}
		}
		ce.setCEMapping(ceTypeMap);
		ce.setModifiedCount(1 + ce.getModifiedCount());

		// Change CE critical flag, start and stop times and other parameters
		setCEParametersFromEditModel(ce, ceEditModel);

		/*
		 * DEV-2874 Add CE_DEFN_EVENT_MAPs in this thread as opposed to from
		 */
		updateCeDefinitionData(ceEditModel.getCeDefinitionId(), ceEditModel.getDutyCycleByDeviceType(), ce, ceEditModel.getMode(), ceEditModel.getDutyCycle());

		// Load the already existing groups
		List<CeGroupMap> ceGroupMapSet = ce.getCeGroupMapCollection();
		Map<Integer, CeGroupMap> ceGroupMapByCeGroupId = new HashMap<Integer, CeGroupMap>();
		for (CeGroupMap ceGroupMap : ceGroupMapSet)
		{
			ceGroupMapByCeGroupId.put(ceGroupMap.getCeGroupId().getCeGroupId(), ceGroupMap);
		}

		ControlEventPowerModel powerModelData = new ControlEventPowerModel();
		List<GroupPowerModel> existingGroupPowerModelList = new ArrayList<GroupPowerModel>();
		List<GroupPowerModel> newGroupPowerModelList = new ArrayList<GroupPowerModel>();
		List<GroupPowerModel> groupPowerModelList = ceEditModel.getGroupPowerList();
		Map<Integer, double[]> grpAvailPowerList = new HashMap<Integer, double[]>();
		boolean inProgress = OpsCenterConstants.IN_PROGRESS.equals(ce.getCeStatusId().getCeStatusName());
		boolean powerInPercentage = ce.getPowerToRemoveInPercent().equalsIgnoreCase(OpsCenterConstants.TRUE);

		for (GroupPowerModel groupPowerModel : groupPowerModelList)
		{
			logger.debug("Processing groupPowerModel: " + groupPowerModel);

			// Load the group power model map - we return this to callers
			if (powerInPercentage)
			{
				loadGroupPowerModelInPercentages(grpAvailPowerList, groupPowerModel);
			}
			else
			{
				loadGroupPowerModel(grpAvailPowerList, groupPowerModel);
			}

			CeGroupMap grpMap = ceGroupMapByCeGroupId.get(groupPowerModel.getGrpId());
			// This group has to be added to the CE
			if (grpMap == null)
			{
				// The CE is already in progress
				if (inProgress)
				{
					DateTime currentTime = new DateTime();
					if (OpsCenterConstants.TRUE.equals(ce.getCycling()))
					{
						populateCyclingDataAddingGroups(powerModelData, groupPowerModel, ce, currentTime, ceEditModel.getUserId(), ceGroupMapSet.size());
					}
					else
					{
						populatePowerModelDataAddingGroups(powerModelData, groupPowerModel, ce, currentTime, ceEditModel.getUserId(), ceGroupMapSet.size());
					}
				}
				else
				{
					// The CE is in the future
					newGroupPowerModelList.add(groupPowerModel);
				}
			}
			// The group is already in the CE
			else
			{
				double additionalPowerToRemove = 0.0;
				if (OpsCenterConstants.FALSE.equals(ce.getCycling()))
				{
					// TODO 3.0.1 - Adding a device type to existing CE, need to
					// create the new CeDeviceType Entries And Logs with Correct
					// Power adjustments to ESI & Group
					if (powerInPercentage)
					{
						additionalPowerToRemove = groupPowerModel.getAdditionalPowerToRemove();
					}
					else
					{
						additionalPowerToRemove = groupPowerModel.getPowerToRemove();
					}
					logger.debug("Add power to remove on Edit CE, additionalPowerToRemove = " + additionalPowerToRemove + (powerInPercentage ? "%" : ""));
				}
				else
				{
					grpMap.setDutyCycle(groupPowerModel.getDutyCycle());
					logger.debug("New Duty Cycle to use for grp =   " + grpMap.getDutyCycle());
				}

				// This only gets executed for set point CEs.
				// additionalPowerToRemove will
				// always be zero for cycling CEs.
				if (additionalPowerToRemove > 0 || !addedTypes.isEmpty())
				{
					double powerToRemove = additionalPowerToRemove;
					logger.debug("Initial power to remove = " + groupPowerModel.getInitialPowerToRemove());

					if (powerInPercentage)
					{
						powerToRemove = additionalPowerToRemove + grpMap.getInitialPowerToRemove();

						// % power rec must not be > 100 %--, bubble up
						// exception to UI
						// we limit it to 110 % because user can select 100 %
						// and we will add 10% always to requested amount
						if (powerToRemove > (100.0 * EXTRA_POWER_FACTOR))
						{
							throw new ControlEventPercentPowerToRemoveExceeded("Percent request > 100, not allowed " + ce.getControlEventId());
						}
						grpMap.setAdditionalPowerToRemove(additionalPowerToRemove);
						grpMap.setPowerToRemove(powerToRemove);
						// Semantic change in powerToRemove - was percent and is
						// now in watts
						powerToRemove = computePowerInPercent(ce, groupPowerModel.getGrpId(), powerToRemove);
						logger.debug("Power request by %, convert to Watts avail = " + powerToRemove);
					}
					else
					{
						grpMap.setAdditionalPowerToRemove(additionalPowerToRemove + grpMap.getAdditionalPowerToRemove());
						// TODO - Consider that when adding additional power to
						// an in progress event it is really in addition to
						// powerRemoved... Not powerToRemove...
						grpMap.setPowerToRemove(grpMap.getPowerToRemove() + powerToRemove);
						logger.debug("Power requested in WATTS for GrpId/reqGrpPwrToRemove = " + groupPowerModel.getGrpId() + "/" + additionalPowerToRemove);
					}

					grpMap.setModifiedCount(1 + grpMap.getModifiedCount());

					if (inProgress)
					{
						existingGroupPowerModelList.add(groupPowerModel);
						int prevNumGws = controlEventBeanFacade.getCeAccountMapCountByCeGroupIdAndControlEventId(grpMap.getCeGroupId().getCeGroupId(), grpMap
								.getControlEventId().getControlEventId());
						GroupPowerGatewayData grpPowerData = new GroupPowerGatewayData();
						grpPowerData.setNumGws(prevNumGws);
						grpPowerData.setGrpPowerToRemove(powerToRemove);

						int grpKey = groupPowerModel.getGrpId();
						if (!cacheManager.getCeGrpCache().isKeyInCache(grpKey))
						{
							// not in cache--what to do??
							logger.error("Grp request from UI not in grp cache--error??");
						}
						else
						{
							DateTime currentTime = new DateTime();
							if (!addedTypes.isEmpty())
							{
								// 3.1 - Adding a device type to existing CE,
								// need to create the new CeDevices &
								// CeDevicesLogs and apply the correct Power
								// adjustments to ESI & Group cache
								grpPowerData = addDeviceClassesToRunningCe(addedTypes, grpMap, grpPowerData, currentTime, ceEditModel.getUserId());
							}

							// now update the GRP Map Cache
							try
							{
								// power to remove initially should be 0.0 , as
								// ESI are added this value will increment
								cacheManager.updateCEGrpMapCache(grpMap.getCeGroupMapId(), grpMap.getAdditionalPowerToRemove(), grpMap.getPowerToRemove(),
										ce.getPowerToRemoveInPercent());
							} catch (InterruptedException e)
							{
								e.printStackTrace();
							}
							double grpPowerAvail = 0.0;
							// if its a cycling event, the grpPwrAvail is really
							// meaningless as we put all esi in grp into event
							// anyways
							if (OpsCenterConstants.TRUE.equals(ce.getCycling()))
							{
								grpPowerData = addDevicesToCyclingCE(grpMap, grpPowerData, currentTime, ceEditModel.getUserId());
								powerModelData.setPowerAvailable(grpPowerAvail);

							}
							else
							{
								logger.debug("Looking for ESIs with power for types: " + ceTypeSet);
								grpPowerData = addDevicesToCe(grpMap, grpPowerData, currentTime, ceEditModel.getUserId(), null, false);

								double grpReqPwrToRem = grpPowerData.getGrpPowerRemoved();

								// this is total power avail for utility--all
								// grps
								// double grpPowerConsumed =
								// Math.max(grpCacheData.getProjPowerConsumed(),
								// grpReqPwrToRem);
								Element element = cacheManager.getCeGrpCache().get(grpKey);
								CEGroupCacheData grpCacheData = (CEGroupCacheData) element.getObjectValue();

								grpPowerAvail = Math.max(grpCacheData.getProjPowerAvailable(), grpReqPwrToRem);

								// clearing out this value...
								groupPowerModel.setProjPowerAvailable(grpPowerAvail);
								groupPowerModel.setPowerToRemove(powerToRemove);
								// groupPowerModel.setAdditionalPowerToRemove(grpMap.getAdditionalPowerToRemove());

								grpPowerAvail = Math.max(grpPowerAvail - grpReqPwrToRem, 0.0);
								powerModelData.setPowerAvailable(powerModelData.getPowerAvailable() + grpPowerAvail);
							}
							powerModelData.setNumberOfGateways(powerModelData.getNumberOfGateways() + grpPowerData.getNumGws());
							// powerModelData.setPowerRemoved(powerModelData.getPowerRemoved()
							// + grpReqPwrToRem);

						}
					}
				}
			}
		}

		if (!newGroupPowerModelList.isEmpty())
		{
			createCeGroupMaps(newGroupPowerModelList, ce, groupPowerModelList.size() - 1);
		}

		// populatePowerRemoved(ce, powerModelData,
		// existingGroupPowerModelList);

		User user = userAccBeanFacade.findUserByUserId(ceEditModel.getUserId());
		String userName = user != null ? user.getUsername() : "UNKNOWN";
		powerModelData.setUserName(userName);
		powerModelData.setGroupPowerList(groupPowerModelList);
		ce.setUserModified(userName);
		
		ce.setStopTime(ceEditModel.getStopDate());
		ce.setOrigStopTime(ceEditModel.getOrigStopDate());
		
		DateTime currentDateTime = new DateTime();
		ce.setDateModified(currentDateTime);
		// Update the cache and the DB
		flushControlEvent(ce);

		ControlEventModel model = getControlEventDetails(ce.getControlEventId(), grpAvailPowerList);
		return model;
	}

	/**
	 * Reduce the power removed from a control event. This is accomplished by
	 * opting out customers until the new power goals are met.
	 */
	@Override
	public ControlEventModel editControlEventReducePowerToRemove(ControlEventEditModel ceEditModel) throws AbstractOpsCenterException
	{
		ControlEvent ce = getControlEvent(ceEditModel.getCeId());
		if (ce == null)
		{
			throw new ControlEventNotFoundException("No control event found for edit: " + ceEditModel.getCeId());
		}

		if (ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_CANCELED)
				|| ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_STOPPED)
				|| ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_ENDED))
		{
			throw new ControlEventStoppedException("Before this Edit " + OpsCenterConstants.CE_NAME + " executed, Ops noticed " + OpsCenterConstants.CE_NAME
					+ " (id=" + ceEditModel.getCeId() + ") is in a state");
		}

		// We expect power to be taken from the CE to be expressed as a negative
		// number.
		double totalPowerToTakenFromCE = ceEditModel.getAdditionalPowerToRemoveTotal();
		if (totalPowerToTakenFromCE > 0.0)
		{
			throw new ControlEventPercentPowerToRemoveExceeded("Requests for less power must be expressed as a negative.  Got: " + totalPowerToTakenFromCE);
		}

		// Now turn it positive for future calculations
		totalPowerToTakenFromCE = Math.abs(totalPowerToTakenFromCE);

		setCEParametersFromEditModel(ce, ceEditModel);

		// Flush the CE here to prevent OpenJPA exceptions. Later in the code we
		// clear the
		// entity manager, which detaches the CE. This allows us to persist the
		// CE changes
		// before it is potentially detached.
		flushControlEvent(ce);

		/*
		 * DEV-2874 Add CE_DEFN_EVENT_MAPs in this thread as opposed to from the
		 * UI controller thread, to prevent race conditions
		 */
		if (ceEditModel.getCeDefinitionId() != null && ceEditModel.getMode() == OpsCenterConstants.eventMode.CYCLING)
		{
			if (ceEditModel.getDutyCycle() == OpsCenterConstants.dutyCycle.GROUP)
			{
				ceDefinitionBean.updateEventToDefinitionEntry(ceEditModel.getCeDefinitionId(), ce.getControlEventId());
			}
			else
			{
				Map<String, Integer> dutyCycleByDeviceType = ceEditModel.getDutyCycleByDeviceType();

				for (String deviceType : dutyCycleByDeviceType.keySet())
				{
					int deviceTypeId = OpsCenterConstants.DeviceType.fromCeValue(deviceType).getId();

					// back end code is expecting 19 (TSTAT), not 0 (HVAC)
					if (deviceTypeId == OpsCenterConstants.DEVICE_TYPE_ID_HVAC)
					{
						deviceTypeId = OpsCenterConstants.DEVICE_TYPE_ID_TSTAT;
					}

					ceDefinitionBean.updateEventToDefinitionEntry(ceEditModel.getCeDefinitionId(), ce.getControlEventId(), deviceTypeId,
							dutyCycleByDeviceType.get(deviceType));
				}
			}
		}

		// Create a map of all of the CE group maps - one entry per CE Group
		// map.
		List<GroupPowerModel> groupPowerModelList = ceEditModel.getGroupPowerList();
		List<CeGroupMap> ceGroupMapSet = ce.getCeGroupMapCollection();
		Map<Integer, CeGroupMap> ceGroupMapByCeGroupId = new HashMap<Integer, CeGroupMap>();
		for (CeGroupMap ceGroupMap : ceGroupMapSet)
		{
			ceGroupMapByCeGroupId.put(ceGroupMap.getCeGroupId().getCeGroupId(), ceGroupMap);
		}

		// Create a map for group power model items. This gets filled in inside
		// the loop
		Map<Integer, double[]> grpAvailPowerList = new HashMap<Integer, double[]>();

		// Get this list here one time
		Map<Integer, List<EsiCacheData>> esiGroupMap = getAllEsi();

		for (GroupPowerModel groupPowerModel : groupPowerModelList)
		{
			// Note that since we are reducing power to remove values, power to
			// remove will be negative.
			double additionalPowerToRecoup = groupPowerModel.getPowerToRemove();
			boolean powerInPercent = OpsCenterConstants.TRUE.equals(ce.getPowerToRemoveInPercent());

			// Note that when we adjust power requested down we do not recoup an
			// additional 10%

			loadGroupPowerModel(grpAvailPowerList, groupPowerModel);

			CeGroupMap grpMap = ceGroupMapByCeGroupId.get(groupPowerModel.getGrpId());
			// This group has to be added to the CE
			if (grpMap == null)
			{
				DateTime currentTime = new DateTime();
				ControlEventPowerModel powerModelData = new ControlEventPowerModel();
				populatePowerModelDataAddingGroups(powerModelData, groupPowerModel, ce, currentTime, ceEditModel.getUserId(), ceGroupMapSet.size());
				grpMap = ceGroupMapByCeGroupId.get(groupPowerModel.getGrpId());
			}

			if (grpMap == null)
			{
				throw new ControlEventGroupNotFoundException("No Control Event Group Map found in cache for: " + groupPowerModel.getGrpId());
			}

			// Account for the 10% that we add
			additionalPowerToRecoup = additionalPowerToRecoup * EXTRA_POWER_FACTOR;

			// Power to remove (% or actual) must not be < 0.
			// If it is, set it to zero which effectively means no power will be
			// taken from this group
			double totalPowerRemovedFromGroup = grpMap.getPowerToRemove() + additionalPowerToRecoup;
			if (totalPowerRemovedFromGroup < 0)
			{
				// we are releasing all power
				totalPowerRemovedFromGroup = 0;

				// Set additional power to whatever is left
				additionalPowerToRecoup = grpMap.getPowerToRemove();
			}

			// Set new parameters in the group map, keeping units defined as
			// either percent or watts
			double groupAdditionalPowerToRemove = grpMap.getAdditionalPowerToRemove() + additionalPowerToRecoup;
			grpMap.setAdditionalPowerToRemove(groupAdditionalPowerToRemove);
			grpMap.setPowerToRemove(totalPowerRemovedFromGroup);

			// Get power in watts
			double additionalPowerToRecoupWatts = additionalPowerToRecoup;
			if (powerInPercent)
			{
				// Semantic change in powerToRemove -was percent and is now in
				// watts
				additionalPowerToRecoupWatts = computePowerInPercent(ce, groupPowerModel.getGrpId(), totalPowerRemovedFromGroup);
				logger.debug("Power request by %, convert to Watts avail = " + additionalPowerToRecoup);
			}

			grpMap.setModifiedCount(1 + grpMap.getModifiedCount());

			// Perform auto opt out - get the actual power recouped
			List<EsiCacheData> esiGroupList = esiGroupMap.get(groupPowerModel.getGrpId());
			if (esiGroupList != null)
			{
				autoOptOut(grpMap, esiGroupList, Math.abs(additionalPowerToRecoupWatts));
			}
			else
			{
				logger.warn("No ESIs found for group " + groupPowerModel.getGrpId());
			}

			// now update the GRP Map Cache
			int grpKey = groupPowerModel.getGrpId();
			if (cacheManager.getCeGrpCache().isKeyInCache(grpKey))
			{
				try
				{
					// power to remove initially should be 0.0 , as ESI are
					// added this value will increment
					cacheManager.updateCEGrpMapCache(grpMap.getCeGroupMapId(), grpMap.getAdditionalPowerToRemove(), grpMap.getPowerToRemove(),
							ce.getPowerToRemoveInPercent());
				} catch (InterruptedException e)
				{
					logger.error("Failed to update group cache: " + grpKey);
					e.printStackTrace();
				}
			}
			else
			{
				// not in cache--log error and move on
				logger.error("Group is in CE but not in cache: " + grpKey);
			}
		}

		ControlEventModel model = getControlEventDetails(ce.getControlEventId(), grpAvailPowerList);

		// return powerModelData;
		return model;
	}

	/**
	 * Opt out ESIs for this group to recoup the power requested for this group.
	 *
	 * @return
	 */
	private void autoOptOut(CeGroupMap grpMap, List<EsiCacheData> esiGroupList, double powerToRecoup) throws AbstractOpsCenterException
	{
		List<CEAccountMapCacheData> ceAcctMapOptOutList = new ArrayList<CEAccountMapCacheData>();
		List<EsiCacheData> esiOptOutList = new ArrayList<EsiCacheData>();

		long currentMillis = System.currentTimeMillis();

		double powerRecouped = 0.0;

		// Get power back from ESIs until we have the requested power to recoup
		for (EsiCacheData esiCache : esiGroupList)
		{
			double powerConsumedByEsi = esiCache.getActEnergyConsumed();
			int esiAccMapId = esiCache.getCeAccountMapId();
			if (esiAccMapId != 0)
			{
				Element accMapElement = cacheManager.getCeAccMapCache().get(esiAccMapId);
				if (accMapElement != null)
				{
					CEAccountMapCacheData ceAccMapCache = (CEAccountMapCacheData) accMapElement.getObjectValue();
					if (ceAccMapCache.getStartTime().getMillis() <= currentMillis)
					{
						esiCache.setOptOutReason(OpsCenterConstants.OptOutReason.RELEASED);

						// Record both the account and the ESI for opt out
						ceAcctMapOptOutList.add(ceAccMapCache);
						esiOptOutList.add(esiCache);

						// Accumulate power recouped
						powerRecouped += powerConsumedByEsi;
					}
				}
				else
				{
					logger.debug("Account map ID not found in AccMapCache for ESI = / AccMapId " + esiCache.getEsiId() + "/" + esiAccMapId);
				}
			}
			else
			{
				logger.debug("ESI not in CE, keep searching: esiId, esiMode, actEnergy, accountId= " + esiCache.getEsiId() + "/" + esiCache.getEsiMode() + "/"
						+ esiCache.getActEnergyConsumed() + "/" + esiCache.getAccountId());
			}

			// Stop when we have recouped enough power
			if (powerRecouped >= powerToRecoup)
			{
				break;
			}
		}

		// Recoup the power by opting out the selected ESIs
		if (!esiOptOutList.isEmpty())
		{
			optOutEsiFromCE(esiOptOutList, ceAcctMapOptOutList);
		}
	}

	/**
	 * Get all ESIs from the cache and sort by group.
	 *
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	private Map<Integer, List<EsiCacheData>> getAllEsi() throws AbstractOpsCenterException
	{
		Map<Integer, List<EsiCacheData>> allEsiByGroup = new HashMap<Integer, List<EsiCacheData>>();

		// retrieve *all* esi's since every GRP in cache and DB must be updated
		// now
		Results esiResult = cacheManager.getCacheData(cacheManager.getGwEsiCache());

		// iterate thru ALL ESI and update powerConsumed to other tables
		if (esiResult.size() > 0)
		{
			for (Result esi : esiResult.all())
			{
				EsiCacheData esiCache = (EsiCacheData) esi.getValue();
				List<Integer> grpList = esiCache.getGrpIdList();
				// Add the ESI object to each group
				for (Integer grp : grpList)
				{
					// If we don't have an ESI list for a group, create it
					if (!allEsiByGroup.containsKey(grp))
					{
						List<EsiCacheData> groupList = new ArrayList<EsiCacheData>();
						allEsiByGroup.put(grp, groupList);
					}

					// Add the ESI to the appropriate group list
					List<EsiCacheData> groupList = allEsiByGroup.get(grp);
					groupList.add(esiCache);
				}

			}
		}
		else
		{
			logger.error("No ESIs received in for ESI in cache");
		}

		return allEsiByGroup;
	}

	/**
	 * @param ceId
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	private ControlEvent getControlEvent(int ceId) throws AbstractOpsCenterException
	{
		ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceId);
		if (ce == null)
		{
			throw new ControlEventNotFoundException(OpsCenterConstants.CE_NAME + " " + ceId + " does not exit.");
		}

		if (ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_CANCELED)
				|| ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_STOPPED)
				|| ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_ENDED))
		{
			throw new ControlEventStoppedException("Before this Edit " + OpsCenterConstants.CE_NAME + " executed, Ops noticed " + OpsCenterConstants.CE_NAME
					+ " (id=" + ceId + ") is in a state");
		}

		return ce;
	}

	/**
	 * @param grpAvailPowerList
	 * @param groupPowerModel
	 */
	private void loadGroupPowerModel(Map<Integer, double[]> grpAvailPowerList, GroupPowerModel groupPowerModel)
	{
		double[] power = new double[] { 0.0, 0.0 };
		power[0] = groupPowerModel.getAdditionalPowerToRemove();
		power[1] = groupPowerModel.getInitialPowerToRemove();
		if (groupPowerModel.getDutyCycle() > 0)
		{
			power[0] = groupPowerModel.getDutyCycle();
			power[1] = 0.0;
		}
		// Must build this list to return to UI so UI can apply limits to max
		// power (%)
		grpAvailPowerList.put(groupPowerModel.getGrpId(), power);
	}

	private void loadGroupPowerModelInPercentages(Map<Integer, double[]> grpAvailPowerList, GroupPowerModel groupPowerModel)
	{
		double[] power = new double[] { 0.0, 0.0 };

		power[0] = groupPowerModel.getAdditionalPowerToRemove();
		power[1] = groupPowerModel.getInitialPowerToRemove();

		grpAvailPowerList.put(groupPowerModel.getGrpId(), power);
	}

	/**
	 * @param ceId
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	private void setCEParametersFromEditModel(ControlEvent ce, ControlEventEditModel ceEditModel) throws AbstractOpsCenterException
	{
		// PHNX-225 : The ADDITIONAL_POWER_TO_REMOVE column is not being updated
		// correctly in the CE tables.
		if (ce.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE))
		{
			logger.debug("AdditionalPowerToRemoveTotal = " + ceEditModel.getAdditionalPowerToRemoveTotal() + "PowerToRemove = " + ce.getPowerToRemove());
			ce.setAdditionalPowerToRemove(ceEditModel.getAdditionalPowerToRemoveTotal() - ce.getPowerToRemove());
			logger.debug("CE Additional Power to Remove when in percent = " + ce.getAdditionalPowerToRemove());
		}

		else
		{
			logger.debug("AdditionalPowerToRemove = " + ce.getAdditionalPowerToRemove() + "AdditionalPowerToRemoveTotal = "
					+ ceEditModel.getAdditionalPowerToRemoveTotal());
			ce.setAdditionalPowerToRemove(ce.getAdditionalPowerToRemove() + ceEditModel.getAdditionalPowerToRemoveTotal());
			logger.debug("CE Additional Power to Remove = " + ce.getAdditionalPowerToRemove());
		}

		// KRMT-2062: allow changing criticalFlag of a CE scheduled in the
		// future
		if (!ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.CE_STATUS_NEW))
		{
			if (ceEditModel.getCriticalFlag() != null && !ceEditModel.getCriticalFlag().equals(ce.getCriticalFlag()))
			{
				throw new ControlEventModeChangeNotAllowed("Cannot change CE mode of running event (id = " + ceEditModel.getCeId() + ")");
			}
		}
		else
		{
			if (ceEditModel.getCriticalFlag() != null)
			{
				ce.setCriticalFlag(ceEditModel.getCriticalFlag());
			}
			else
			{
				ce.setCriticalFlag(OpsCenterConstants.FALSE);
			}
		}
		logger.debug("CE critical setting after edit =  " + ce.getCriticalFlag());

		// Set start time
		DateTime currentTime = new DateTime();

		DateTime startDate = ceEditModel.getStartDate();
		if (startDate != null && ce.getCeStatusId().getCeStatusName().equals(OpsCenterConstants.NEW))
		{
			ce.setStartTime(startDate);
		}
		DateTime stopDate = ceEditModel.getStopDate();
		if (stopDate != null)
		{
			if (stopDate.compareTo(currentTime) < 0)
			{
				throw new ControlEventDurationNotAllowed("Stop time cannot be in the past");
			}
			ce.setStopTime(stopDate);
		}

		ce.setCycling(OpsCenterConstants.eventMode.CYCLING == ceEditModel.getMode() ? OpsCenterConstants.TRUE : OpsCenterConstants.FALSE);
	}

	/**
	 * @param ceId
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	private void flushControlEvent(ControlEvent ce) throws AbstractOpsCenterException
	{
		// now update CE Cache
		cacheManager.updateControlEventCache(ce);

		// Need to refresh before I call getControlEventDetails...
		entityManager.flush();
		entityManager.refresh(ce);

		controlEventBean.scheduleControlEvent(ce.getControlEventId());
	}

	/**
	 * @param ce
	 * @param powerModelData
	 * @param existingGroupPowerModelList
	 */
	@SuppressWarnings("unused")
	private void populatePowerRemoved(ControlEvent ce, ControlEventPowerModel powerModelData, List<GroupPowerModel> existingGroupPowerModelList)
	{
		if (!existingGroupPowerModelList.isEmpty())
		{
			Map<Integer, GroupPowerModel> groupPowerModelByCeGroupId = new HashMap<Integer, GroupPowerModel>();
			for (GroupPowerModel groupPowerModel : existingGroupPowerModelList)
			{
				groupPowerModelByCeGroupId.put(groupPowerModel.getGrpId(), groupPowerModel);
			}

			Cache ceAccMapCache = cacheManager.getCeAccMapCache();

			List<Result> esiResults = cacheManager.getCacheDataControlEventId(cacheManager.getGwEsiCache(), ce.getControlEventId()).all();

			for (Result esiResult : esiResults)
			{
				EsiCacheData esi = (EsiCacheData) esiResult.getValue();
				if (esi == null)
				{
					continue;
				}

				int ceAccountMapId = esi.getCeAccountMapId();
				Element element = ceAccMapCache.get(ceAccountMapId);
				if (element == null)
				{
					continue;
				}

				CEAccountMapCacheData ceAccountMap = (CEAccountMapCacheData) element.getObjectValue();

				double powerRemoved = ceAccountMap.getPowerConsumed();
				GroupPowerModel groupPowerModel = groupPowerModelByCeGroupId.get(ceAccountMap.getCeGrpId());
				if (groupPowerModel != null)
				{
					groupPowerModel.setPowerRemoved(groupPowerModel.getPowerToRemove() + powerRemoved);
				}
			}

			for (GroupPowerModel groupPowerModel : existingGroupPowerModelList)
			{
				groupPowerModelByCeGroupId.put(groupPowerModel.getGrpId(), groupPowerModel);
				powerModelData.setPowerRemoved(powerModelData.getPowerRemoved() + groupPowerModel.getPowerRemoved());
			}
		}
	}

	/**
	 *
	 * @param controlEventId
	 *            - If null then returns all control events
	 * @param startRange
	 *            - Not nullable, eventtime >= startTime
	 * @param endRange
	 *            - Not nullable, eventtime < endTime
	 * @return results sorted from oldest to newest
	 */
	@Override
	public SortedSet<CeLogModel> getLogsByCeAndRange(ControlEventDataFilterCriteriaModel ceFilterCriteriaModel, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		Integer controlEventId = ceFilterCriteriaModel.getControlEventId();
		DateTime startRange = ceFilterCriteriaModel.getStartRange();
		DateTime endRange = ceFilterCriteriaModel.getEndRange();

		logger.info(">> getLogsByCeAndRange ceId=" + controlEventId + "\tstart=" + startRange + "\tend=" + endRange);

		List<CeLogModel> ceLogList = controlEventId == null ? controlEventBeanFacade.getCeLogByDateRange(startRange, endRange) : controlEventBeanFacade
				.getCeLogByControlEventIdAndDateRange(controlEventId, startRange, endRange);
		SortedSet<CeLogModel> ceLogModelSet = new TreeSet<CeLogModel>();
		ceLogModelSet.addAll(ceLogList);

		List<CeLogModel> ceEsiLogList = controlEventId == null ? controlEventBeanFacade.getCeEsiLogByDateRange(startRange, endRange) : controlEventBeanFacade
				.getCeEsiLogByControlEventIdAndDateRange(controlEventId, startRange, endRange);
		ceLogModelSet.addAll(ceEsiLogList);

		List<CeLogModel> ceDevicesLogList = controlEventId == null ? controlEventBeanFacade.getCeDevicesLogByDateRange(startRange, endRange)
				: controlEventBeanFacade.getCeDevicesLogByControlEventIdAndDateRange(controlEventId, startRange, endRange);
		ceLogModelSet.addAll(ceDevicesLogList);

		// KRMT-2123: limit the maximum number of returned logs to value
		// configured in table UTILITY_PROPERTY
		SortedSet<CeLogModel> ceLogModels = new TreeSet<CeLogModel>();
		int i = 0;
		int maxNumLogs = genericBean.getMaximumNumberOfCeLogsForUI();
		for (Iterator<CeLogModel> itor = ceLogModelSet.iterator(); itor.hasNext() && i < maxNumLogs; i++)
		{
			ceLogModels.add(itor.next());
		}

		return ceLogModels;
	}

	/**
	 * Log an exception and its causes
	 *
	 * @param exp
	 */
	private void logException(Throwable exp, String message)
	{
		logger.error("ControlEventPowerBean: " + message + ": " + exp.getMessage());

		Throwable cause = exp.getCause();
		while (cause != null)
		{
			logger.error("ControlEventPowerBean: Cause: " + cause.getMessage());
			cause = cause.getCause();
		}
	}

	@Override
	public List<CeDeviceTypeModel> getDeviceLogsForControlEvent(int controlEventId)
	{
		logger.info("[ENTER] List<CeDeviceTypeModel> ControlEventPowerBean.getDeviceLogsForControlEvent(controlEventId = " + controlEventId + ")");

		List<CeDeviceTypeModel> deviceTypes = getCeDeviceTypeModelCollection(controlEventId, TenantContext.getCurrentTenant());

		logger.info("[ EXIT] ControlEventPowerBean.getDeviceLogsForControlEvent");

		return deviceTypes;
	}

	/**
	 * Count how many devices for an account are still active in a specific
	 * event
	 *
	 * @param accId
	 *            - account_id
	 * @param ceId
	 *            - ce_id
	 * @return number of active devices remaining in event for this account
	 */
	private int getActiveDevicesLeftForAccount(int accId, int ceId)
	{
		logger.info("[ENTER] int ControlEventPowerBean.getActiveDevicesLeftForAccount(accId = " + accId + ", ceId = " + ceId + ")");

		EsiDcCacheData esiDcCache = null;

		int activeDeviceCount = 0;

		Results esiDcResults = cacheManager.getCacheDataByAccId(cacheManager.getGwDCCache(), accId);

		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCache = (EsiDcCacheData) esiDcResult.getValue();

			if (esiDcCache.getCeId() == ceId && (esiDcCache.getDcMode() == OpsCenterConstants.ESI_MODE_CONTROL || "1".equalsIgnoreCase(esiDcCache.getStrDMEventStatusFlag())))
			{
				activeDeviceCount++;
			}
		}

		logger.info("[ EXIT] ControlEventPowerBean.getActiveDevicesLeftForAccount");

		return activeDeviceCount;
	}

	@Override
	public boolean optOutIndividualDeviceFromCE(int accId, int esiDcId, int ceId) throws AbstractOpsCenterException
	{
		return optOutIndividualDeviceFromCE(accId, esiDcId, ceId, OptOutReason.GUI);
	}

	@Override
	public boolean optOutIndividualDeviceFromCE(int accId, int esiDcId, int ceId, OptOutReason reason) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] boolean ControlEventPowerBean.optOutIndividualDeviceFromCE(accId = " + accId + ", esiDcId = " + esiDcId + ", ceId = " + ceId
				+ ", reason = " + reason + ")");

		int activeDevicesLeftForThisAccount = 0;
		boolean found = false;

		/*
		 * First thing to do is to check to see if this is the last active
		 * device in the event for this account.
		 * 
		 * If so, just do a regular optOut for the entire account
		 */
		activeDevicesLeftForThisAccount = getActiveDevicesLeftForAccount(accId, ceId);

		if (activeDevicesLeftForThisAccount == 0 || activeDevicesLeftForThisAccount == 1)
		{
			logger.info("ControlEventPowerBean.optOutIndividualDeviceFromCE last active device for this account");

			return optOutEsiFromCE(accId, reason);
		}

		/*
		 * More than one device left in the control event for this account? Then
		 * just remove it from the relevant caches, then update the DB
		 * accordingly
		 */

		found = optOutIndividualDeviceInAccount(accId, esiDcId, reason, TenantContext.getCurrentTenant());

		logger.info("[ EXIT] ControlEventPowerBean.optOutIndividualDeviceFromCE");

		return found;
	}

	/**
	 * Searches through the caches to opt out the specified device (by esiDcId)
	 *
	 * @param accId
	 *            - ID of account this device belongs to
	 * @param esiDcId
	 *            - ID of devices to opt out for this event
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	@Override
	public boolean optOutIndividualDeviceInAccount(int accId, int esiDcId, OpsCenterConstants.OptOutReason reason, Integer tenantId) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] boolean ControlEventPowerBean.optOutIndividualDeviceInAccount(accId = " + accId + ", esiDcId = " + esiDcId + ")");
		TenantContext.setCurrentTenant(tenantId);
		boolean found = false;

		CEAccountMapCacheData ceAccountMapCacheData = null;
		EsiDcCacheData esiDcCacheData = null;

		// TODO - CR optOutIndividualDeviceInAccount

		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), esiDcId);
		Results ceAccountMapResults = cacheManager.getCacheDataByCeAccId(cacheManager.getCeAccMapCache(), accId);

		logger.debug("esiDcResults.size() = " + esiDcResults.size());
		logger.debug("ceAccountMapResults.size() = " + ceAccountMapResults.size());
		if (ceAccountMapResults == null || ceAccountMapResults.size() <= 0)
		{
			logger.error("Device not In CE, opt-out not allowed for esiDcId = " + esiDcId);
			throw new ControlEventOptOutNotAllowed(DefaultResources.CEV_ERR_CODE_CE_OPTOUT_NOT_ALLOWED, "EsiDc not active in the system ceId=", +esiDcId);

		}
		ceAccountMapCacheData = (CEAccountMapCacheData) ceAccountMapResults.all().get(0).getValue();

		for (Result esiDcResult : esiDcResults.all())
		{
			esiDcCacheData = (EsiDcCacheData) esiDcResult.getValue();

			if (esiDcCacheData.getEsiDcId() == esiDcId)
			{
				esiDcCacheData.setOptOutReason(reason);
				optOutGSDeviceFromCE(esiDcCacheData, ceAccountMapCacheData);
				logger.debug("Found GS device and successfully opted out: esiDcId = " + esiDcCacheData.getEsiDcId() + ", esiDc cache key = "
						+ esiDcCacheData.getCacheKey());
				found = true;
			}
		}

		logger.info("[ EXIT] ControlEventPowerBean.optOutIndividualDeviceInAccount");
		esiDcResults.discard();
		ceAccountMapResults.discard();
		return found;
	}

	@Override
	public boolean optOutSelectedDevicesInAccountFromCE(int accId, List<Integer> esiDcIdList, int ceId) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] boolean ControlEventPowerBean.optOutSelectedDevicesInAccountFromCE(int accId, List<Integer> esiDcIdList, int ceId)");

		boolean found = false;

		for (Integer deviceId : esiDcIdList)
		{
			found = optOutIndividualDeviceFromCE(accId, deviceId, ceId);
		}

		logger.info("[ EXIT] ControlEventPowerBean.optOutSelectedDevicesInAccountFromCE");

		return found;
	}

	@Override
	public boolean optOutSelectedDevicesInAccountFromCE(int accId, List<Integer> esiDcIdList, int ceId, OptOutReason reason) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] boolean ControlEventPowerBean.optOutSelectedDevicesInAccountFromCE(int accId, List<Integer> esiDcIdList, int ceId, OptOutReason reason)");

		boolean found = false;

		for (Integer deviceId : esiDcIdList)
		{
			found = optOutIndividualDeviceFromCE(accId, deviceId, ceId, reason);
		}

		logger.info("[ EXIT] ControlEventPowerBean.optOutSelectedDevicesInAccountFromCE");

		return found;
	}

	@SuppressWarnings("unused")
	private ControlEventModel getGroupCountsForCeId(ControlEventModel controlEventModel)
	{

		try
		{
			logger.debug("Entering getGroupCountsForCeId for ceId: " + controlEventModel.getCeId());
			int totalCountForCE = 0;
			int totalCountForCEInControl = 0;
			int totalCountForCEInNormal = 0;

			List<CEGroupMapCacheData> ceGroups = getCeGroupMapsByCe(controlEventModel.getCeId());
			for (CEGroupMapCacheData ceGroup : ceGroups)
			{
				logger.debug("Found ceGroupId in cache: " + ceGroup.getCeGrpId());
				Results ceDevicesResults = cacheManager.getCacheDataByGrpMapId(cacheManager.getCeDevCache(), ceGroup.getCeGrpMapId());
				int countInControl = 0;
				int countInNormal = 0;
				for (Result ceDevicesResult : ceDevicesResults.all())
				{

					CEDevicesCacheData ceDevicesCacheData = (CEDevicesCacheData) ceDevicesResult.getValue();

					Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), ceDevicesCacheData.getEsiDcId());
					for (Result dcResult : esiDcResults.all())
					{
						EsiDcCacheData dcCacheData = (EsiDcCacheData) dcResult.getValue();

						byte dcMode = dcCacheData.getDcMode();
						if (OpsCenterConstants.ESI_MODE_NORMAL == dcMode)
						{

							countInNormal++;
							totalCountForCEInNormal++;
						}
						if (OpsCenterConstants.ESI_MODE_CONTROL == dcMode)
						{
							countInControl++;
							totalCountForCEInControl++;
						}
					}
					esiDcResults.discard();
				}

				int totalCountForGroup = countInControl + countInNormal;
				totalCountForCE += totalCountForGroup;
				if (controlEventModel.getCeGroupMapModelCollection() == null)
				{
					logger.debug("Rec null at  getCeGroupMapModelCollection ");
				}
				else
				{
					for (CeGroupMapModel ceGroupModel : controlEventModel.getCeGroupMapModelCollection())
					{
						if (ceGroupModel.getCeGroupId() == ceGroup.getCeGrpId())
						{
							ceGroupModel.setNumberOfDcs(totalCountForGroup);
							ceGroupModel.setNumberOfDcsInControl(countInControl);
							ceGroupModel.setNumberOfDcsInNormal(countInNormal);
						}
					}
				}
				logger.debug("CeGroup results: " + ceGroup.getCeGrpId() + ", totalCountForGroup - " + totalCountForGroup + ", countInControl - "
						+ countInControl + ", countInNormal - " + countInNormal);

			}

			logger.debug("Total Ce results: " + controlEventModel.getCeId() + ", totalCountForCE - " + totalCountForCE + ", totalCountForCEInControl - "
					+ totalCountForCEInControl + ", totalCountForCEInNormal - " + totalCountForCEInNormal);
			controlEventModel.setNumberOfDcs(totalCountForCE);
			controlEventModel.setNumberOfDcsInControl(totalCountForCEInControl);
			controlEventModel.setNumberOfDcsInNormal(totalCountForCEInNormal);

		} catch (Exception e)
		{
			logger.error("Unable to determine CE device counts: " + e.getMessage(), e);
		}
		return controlEventModel;
	}

	/**
	 * Calculate cycle control. Cycle control = 0 tells the device to enter its
	 * cycle immediately. Cycle control = 0xff tells the device to randomize the
	 * start time of the cycle.
	 *
	 * @param broadcastCEData
	 * @return
	 */
	@Override
	public byte calcCycleControl(int ceId, Map<Integer, Integer> dutyCycleByDeviceTypeMap, byte rampMode, CeDefinition ceDefinition)
	{
		byte cycleControl = 0;

		// If event is immediate ramp in ...
		// If it is not immediate ramp in then device entry will alredy be
		// randomized.
		if (ceDefinition != null)
		{
			// hmbrd-480
			// if ramp mode = 00 must be immediate in-- determine how to set
			// cycling offset
			if (rampMode == 0)
			{
				// If duty cycle for any group is < 100% ...
				// If duty cycle is 100% off then no need to stagger the ramp
				// in.
				if (ceDefinition.getDutyOff() != 0xff) // this if grp duty cycle
				{
					List<CEGroupMapCacheData> ceGroupCacheList = getCeGroupMapsByCe(ceId);
					for (CEGroupMapCacheData ceGroupCache : ceGroupCacheList)
					{
						if (ceGroupCache.getDutyCycle() < 100)
						{
							// Set the cycle control to start the cycle at a
							// random
							// point in time
							cycleControl = (byte) 0xff;
						}
					}
				}
				else
				{
					// dev-2964, DC by dev type
					for (Integer deviceType : dutyCycleByDeviceTypeMap.keySet())
					{
						int dc = dutyCycleByDeviceTypeMap.get(deviceType);

						// back end code is expecting 19 (TSTAT), not 0 (HVAC)
						if (dc < 100)
						{
							cycleControl = (byte) 0xff;
							break;
						}
					}
				}

			}
		}

		return cycleControl;
	}

	@Override
	public void startControlEvent(ControlEvent ce) throws AbstractOpsCenterException
	{

		logger.info("Entering startControlEvent (ce) ");

		DateTime currTime = new DateTime();
		Element element = null;

		@SuppressWarnings("unused")
		double utilPowerConsumed = 0.0;
		double utilPowerRemoved = 0.0;
		@SuppressWarnings("unused")
		double utilPowerAvail = 0.0;
		CEGroupCacheData grpCacheData = null;

		String ceStatusName = OpsCenterConstants.IN_PROGRESS;
		CeStatus status = entityManager.getReference(CeStatus.class, OpsCenterConstants.ceStatusNameToCEStatusID.get(ceStatusName).intValue());

		ce.setCeStatusId(status);
		// KRMT-2427, For some reason this call to merge is necessary...
		controlEventBeanFacade.updateControlEvent(ce);

		ceNotificationBean.notifyStatusChange(ce.getName(), ceStatusName);

		// now record in the log table that a CE has started
		CeLog ceLog = new CeLog();
		ceLog.setControlEventId(ce);
		ceLog.setDateCreated(currTime);
		ceLog.setLogMessage(OpsCenterConstants.CE_NAME + " is " + status.getCeStatusName());
		ceLog.setCeStatusId(status);
		try
		{
			controlEventBeanFacade.createCeLog(ceLog);
		} catch (Exception e1)
		{
			logException(e1, ceLog.getLogMessage());

			throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for " + OpsCenterConstants.CE_NAME);
		}
		// now update CE Cache
		cacheManager.updateControlEventCache(ce);

		// List<ControlEvent> ceList =
		// controlEventBeanFacade.getControlEventByControlEventId(ce.getControlEventId());

		startCeRun(ce);

	}

	private void startCeRun(ControlEvent ce) throws AbstractOpsCenterException
	{
		Element element = null;

		@SuppressWarnings("unused")
		double utilPowerConsumed = 0.0;
		double utilPowerRemoved = 0.0;
		@SuppressWarnings("unused")
		double utilPowerAvail = 0.0;
		CEGroupCacheData grpCacheData = null;

		User user = userAccBeanFacade.findUserByUsername(ce.getUserCreated());

		List<CeGroupMap> ceGrpMapList = controlEventBeanFacade.getCeGroupMapByControlEventId(ce.getControlEventId());
		GroupPowerGatewayData grpPowerData = new GroupPowerGatewayData();
		int numGws = 0;
		double grpPowerAvail = 0.0;
		double grpPowerToRemove = 0.0;
		boolean powerInPercent = ce.getPowerToRemoveInPercent().equals(OpsCenterConstants.TRUE);
		double grpReqPwrToRem = 0.0;
		for (CeGroupMap reqGrpsMap : ceGrpMapList)
		{
			// find this grp in CE_GROUP cache
			int grpKey = reqGrpsMap.getCeGroupId().getCeGroupId();
			if (!cacheManager.getCeGrpCache().isKeyInCache(grpKey))
			{
				// not in cache--what to do??
				logger.error("Grp requested from  CE scheduler not found in cache--error??");
			}
			else
			{
				element = cacheManager.getCeGrpCache().get(grpKey);
				grpCacheData = (CEGroupCacheData) element.getObjectValue();
				// this is total power avail for utility--all grps
				utilPowerConsumed += grpCacheData.getProjPowerConsumed();
				utilPowerAvail += grpCacheData.getProjPowerAvailable();

				if (ce.getCycling().equals(OpsCenterConstants.TRUE))
				{
					grpPowerToRemove = 0.0;
					grpPowerData.setGrpPowerToRemove(grpReqPwrToRem);
					grpPowerData.setNumGws(numGws);

					Collection<String> ceTypeSet = getDeviceClass(ce);
					logger.debug("Looking for ESIs for types: " + ceTypeSet);

					grpPowerData = addDevicesToCyclingCE(reqGrpsMap, grpPowerData, ce.getStartTime(), user.getUserId());
					logger.debug("CE requested by Dev Class, , grab all ESI");

					numGws = grpPowerData.getNumGws();
					double powerRemoved = grpPowerData.getGrpPowerRemoved();
					grpPowerAvail = Math.max(grpPowerAvail - powerRemoved, 0.0);
					utilPowerRemoved = utilPowerRemoved + grpReqPwrToRem;
				}
				else
				{

					// did we request more powr than avail?
					// add 10% to compensate in case we dont meet the requested
					// R3.2 power requested can be a percent
					if (powerInPercent)
					{
						grpPowerToRemove = computePowerInPercent(ce, reqGrpsMap.getCeGroupId().getCeGroupId(), reqGrpsMap.getPowerToRemove());
						logger.debug("Power request by %, convert to GrpId/Watts avail = " + grpPowerToRemove);

					}
					else
					{
						grpPowerToRemove = reqGrpsMap.getPowerToRemove();
						logger.debug("Power requested in WATTS for GrpId/reqGrpPwrToRemove = " + reqGrpsMap.getCeGroupId().getCeGroupId() + "/"
								+ grpPowerToRemove);
					}
					if (grpPowerToRemove == 0.0)
					{
						// no power in grp?? what to do here
						logger.error("No Power Found in Cache for grpMapKey = " + grpKey);
					}
					else
					{ // now compute % of curr grp power avail and use that
						// going fwd
						reqGrpsMap.setPowerToRemove(grpPowerToRemove * EXTRA_POWER_FACTOR);
						grpReqPwrToRem = reqGrpsMap.getPowerToRemove();
					}
					// Added for Wifi Tstat Devices
					int iGroupId = grpCacheData.getCeGrpId();
					List<Integer> grpAccIdListGS = controlEventBeanFacade.getActiveCeGroupAccountMapIdListByCeGroupId(iGroupId,
							OpsCenterConstants.GRIDSTREAM_RF_DELIVERY_ID);
					ControlEventCacheData ceControlEventCacheData = null;
					String strHoneywellEnabled = null;
					Results ceControlEventCache = cacheManager.getCacheDataControlEventId(cacheManager.getControlEventCache(), ce.getControlEventId());
					if (ceControlEventCache == null || ceControlEventCache.size() == 0)
					{
						logger.error("ControlEventPowerBean:startCeRun ControlEvent cache is null");
						return;
					}
					for (Result ceResult : ceControlEventCache.all())
					{
						ceControlEventCacheData = (ControlEventCacheData) ceResult.getValue();
						strHoneywellEnabled = ceControlEventCacheData.getStrHoneywellEnabled();
					}
					logger.debug("ControlEventPowerBean:startCeRun:The Honeywell enableddd is" + strHoneywellEnabled);
					boolean isWifiThirdPartyGroup = false;
					if (strHoneywellEnabled != null && strHoneywellEnabled.length() > 0 && strHoneywellEnabled.equalsIgnoreCase("Y")) {
					 Results dcAvail = cacheManager.getAllCacheDataDcModeAndAccId(cacheManager.getGwDCCache(), grpAccIdListGS);
					logger.warn("ControlEventPowerBean:startCeRun:dcAvail size= " + dcAvail.size());
					for (Result dc : dcAvail.all())
					{
						EsiDcCacheData dcCacheData = (EsiDcCacheData) dc.getValue();
						logger.debug("ControlEventPowerBean:startCeRun:The Device Type is" + dcCacheData.getDeviceType());
						if (dcCacheData.getDeviceType().equalsIgnoreCase(OpsCenterConstants.THIRD_PARTY_TSTAT))
						{
							isWifiThirdPartyGroup = true;
							break;
						}
					}
					 }
					logger.debug("ControlEventPowerBean:startCeRun The isWifiThirdPartyGroup" + isWifiThirdPartyGroup);
					if (grpReqPwrToRem > 0.0 || isWifiThirdPartyGroup)
					{
						// we have met all requested power to remove, exit from
						// this group
						// returns all Esi ordered by RR count
						// List <Esi> esiList =
						// esiBeanFacade.getEsiByGroupIdAndRoundRobin(grpMap.getCeGroupId().getCeGroupId());
						// now dermine which ESIs / DCs to include in CE

						grpPowerData.setGrpPowerToRemove(grpReqPwrToRem);
						grpPowerData.setNumGws(numGws);

						Collection<String> ceTypeSet = getDeviceClass(ce);
						logger.debug("ControlEventPowerBean:startCeRun:Looking for ESIs with power for types: " + ceTypeSet);

						grpPowerData = addDevicesToCe(reqGrpsMap, grpPowerData, ce.getStartTime(), user.getUserId(), grpAccIdListGS, isWifiThirdPartyGroup);
						logger.debug("ControlEventPowerBean:startCeRun:CE requested by Dev Class, looking for Esi");

						numGws = grpPowerData.getNumGws();
						double powerRemoved = grpPowerData.getGrpPowerRemoved();
						grpPowerAvail = Math.max(grpPowerAvail - powerRemoved, 0.0);
						utilPowerRemoved = utilPowerRemoved + grpReqPwrToRem;
					}// if (grpReqPwrToRem > 0.0) {
				}

				// now update the GRP Map Cache
				try
				{
					// power to remove initially should be 0.0 , as ESI are
					// added this value will increment
					cacheManager.updateCEGrpMapCache(reqGrpsMap.getCeGroupMapId(), reqGrpsMap.getAdditionalPowerToRemove(), grpReqPwrToRem,
							ce.getPowerToRemoveInPercent());
				} catch (InterruptedException e)
				{
					e.printStackTrace();
				}
				// if (reqGrpsMap != null)
			}
			// once we reach the CE power to remove originally requeusted, then
			// we are done
			// krmt-5040-- dont worry about utility total, always use GRP total
			// power to remove
			/*
			 * if (utilPowerRemoved >= ce.getPowerToRemove()) break;
			 */
		}// for (GroupPowerModel reqGrps:grpList)
		logger.info("Exiting startControlEvent (ce), powerRemoved = " + utilPowerRemoved);
	}

	@Override
	@Asynchronous
	public void stopControlEvent(int ceId, boolean stoppedEarly, Integer tenantId) throws AbstractOpsCenterException

	{

		logger.info("Entering stopControlEvent for ceId = " + ceId);
		TenantContext.setCurrentTenant(tenantId);

		ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceId);

		DateTime currTime = new DateTime();

		if (!cacheManager.getControlEventCache().isKeyInCache(ceId))
		{

			if (OpsCenterConstants.CE_STATUS_STOPPED.equals(ce.getCeStatusId().getCeStatusName())
					|| OpsCenterConstants.CE_STATUS_ENDED.equals(ce.getCeStatusId().getCeStatusName())
					|| OpsCenterConstants.CE_STATUS_CANCELED.equals(ce.getCeStatusId().getCeStatusName()))
			{
				throw new ControlEventNotFoundException(DefaultResources.CEV_ERR_CODE_CONTROL_EVENT_NOT_FOUND, OpsCenterConstants.CE_NAME
						+ " not active in the system ceId=" + ce.getControlEventId());
			}
			logger.info("This " + OpsCenterConstants.CE_NAME + " is not found in cache, CeId =" + ceId);
		}

		final String ceStatusName;
		if (OpsCenterConstants.CE_STATUS_NEW.equals(ce.getCeStatusId().getCeStatusName()))
		{
			ceStatusName = OpsCenterConstants.CE_STATUS_CANCELED;
		}
		else
		{
			if (stoppedEarly)
			{
				ceStatusName = OpsCenterConstants.CE_STATUS_STOPPED;
			}
			else
			{
				ceStatusName = OpsCenterConstants.CE_STATUS_ENDED;
			}
		}
		CeStatus status = entityManager.getReference(CeStatus.class, OpsCenterConstants.ceStatusNameToCEStatusID.get(ceStatusName).intValue());
		ce.setCeStatusId(status);
		// Just in case the scheduler is firing off late
		ce.setStopTime(currTime);
		ceNotificationBean.notifyStatusChange(ce.getName(), ceStatusName);

		final Integer controlEventId = ceId;
		new Thread(new Runnable()
		{
			@SuppressWarnings("synthetic-access")
			@Override
			public void run()
			{
				try
				{
					deleteCeGroupsForCeId(controlEventId, tenantId);
				} catch (Exception e)
				{
					logger.error(e.getMessage(), e);
				}
			}
		}).start();

		// now add log to CeLog table
		// now record in the log table that a CE has ended
		CeLog ceLog = new CeLog();
		ceLog.setControlEventId(ce);
		ceLog.setDateCreated(currTime);
		ceLog.setCeStatusId(status);
		// krmt-4088
		ceLog.setLogMessage(OpsCenterConstants.CE_NAME + " has ended");
		if (OpsCenterConstants.CE_STATUS_STOPPED.equals(status.getCeStatusName()) || OpsCenterConstants.CE_STATUS_CANCELED.equals(status.getCeStatusName()))
		{
			ceLog.setLogMessage(OpsCenterConstants.CE_NAME + " is " + status.getCeStatusName());
		}

		try
		{
			controlEventBeanFacade.createCeLog(ceLog);
		} catch (Exception e1)
		{
			logException(e1, ceLog.getLogMessage());

			throw new DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED, "DB Create failed for " + OpsCenterConstants.CE_NAME);
		}

		final DateTime ceStopTime = currTime;
		// rdrn-521 clear ce indicator for each grp in this CE--
		List<CeGroupMap> grpMapList = controlEventBeanFacade.getCeGroupMapByControlEventId(ceId);
		for (CeGroupMap grpMap : grpMapList)
		{
			Results grpMapResults = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpCache(), grpMap.getCeGroupId().getCeGroupId());
			for (Result grpMapResult : grpMapResults.all())
			{
				CEGroupCacheData grpCache = (CEGroupCacheData) grpMapResult.getValue();
				if (grpCache == null)
				{
					continue;
				}
				logger.info("stopControlEvent- grpCache.getCeGrpId(): " + grpCache.getCeGrpId() + ", ceStartTime: " + grpCache.getCeStartTime());
				calculateTotalTimeInCe(grpCache.getCeGrpId());
				grpCache.setAutoCeAdded(OpsCenterConstants.FALSE);
				grpCache.setCeId(0);
				grpCache.setCeTotalMinsCalculated(false);
				Element element = new Element(grpCache.getCeGrpId(), grpCache);
				cacheManager.getCeGrpCache().put(element);
				logger.debug("just cleared auto Flag for grpId = " + grpMap.getCeGroupId().getCeGroupId());

			}
		}
		// now reset the autoCe flag if grp was added using AutoCE
		if (OpsCenterConstants.TRUE.equals(ce.getAutoCe()))
		{
			multiScadaAPI.setAutoCeEnabledFalse(ce.getScadaReferenceId());
		}

		controlEventPowerBean.processRemainderOfCeStop(controlEventId, ceStopTime, TenantContext.getCurrentTenant());

		cacheManager.deleteControlEventCacheEntry(ceId);
	}

	@Asynchronous
	public void deleteCeGroupsForCeId(Integer ceId, Integer tenantId)
	{

		TenantContext.setCurrentTenant(tenantId);
		Element grpMapElement = null;
		CEGroupMapCacheData grpMapCache = null;

		List<CeGroupMap> ceGrpMapDbList = controlEventBeanFacade.getCeGroupMapByControlEventId(ceId);
		for (CeGroupMap grpMap : ceGrpMapDbList)
		{
			logger.debug("Updating CeGrpMap on Stop CE, for GrpMapId =  " + grpMap.getCeGroupMapId());
			Integer grpMapKey = grpMap.getCeGroupMapId();
			grpMapElement = cacheManager.getCeGrpMapCache().get(grpMapKey);
			if (grpMapElement == null)
			{
				// grp never added to CE in cache, keep searching
				continue;
			}
			grpMapCache = (CEGroupMapCacheData) grpMapElement.getObjectValue();
			// now update the DB in CeGroupMap table with cache data
			grpMap.setPowerToRemove(grpMapCache.getPowerToRemove());
			grpMap.setAdditionalPowerToRemove(grpMapCache.getAdditionalPowerToRemove());
			grpMap.setGroupPowerFallenFlag(grpMapCache.getGrpPowerFallenFlag());
			grpMap.setCeGroupOrder(grpMapCache.getGrpOrder());
			grpMap.setModifiedCount(grpMapCache.getModifiedCount());
			// update complete now clear cache
			try
			{
				cacheManager.deleteCEGroupMapCacheEntry(grpMapKey);
			} catch (AbstractOpsCenterException aoce)
			{
				logger.error("Unable to delete CE group map cache entry for CE Id " + ceId + ", grpMapKey " + grpMapKey);
			}
		}
	}

	@Asynchronous
	public void processRemainderOfCeStop(Integer ceId, DateTime currTime, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		CEAccountMapCacheData accMapCache = null;
		CEDevicesCacheData devMapCache = null;
		EsiCacheData esiCache = null;

		ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceId);

		List<Integer> ceAccMapIdList = new ArrayList<Integer>();
		Results accMapResults = cacheManager.getCacheDataControlEventId(cacheManager.getCeAccMapCache(), ceId);
		for (Result accMapResult : accMapResults.all())
		{
			accMapCache = (CEAccountMapCacheData) accMapResult.getValue();
			ceAccMapIdList.add(accMapCache.getCeAccMapId());

			try
			{
				cacheManager.deleteCEAccountMapCacheEntry(accMapCache.getCeAccMapId());
			} catch (AbstractOpsCenterException aoce)
			{
				logger.error("Unable to delete CE account map cache entry for CE Id " + ceId + ", accMapCache.getCeAccMapId() " + accMapCache.getCeAccMapId());
			}
		}

		// for perf reasons we must spin up background thread to allow ceDevices
		// table to get updated
		// without causing threading timout issues....

		int accRead = 0;
		int accRunningSize = BATCH_SIZE_ESI;
		Integer[] ceAccMapIdArray = ceAccMapIdList.toArray(new Integer[ceAccMapIdList.size()]);
		logger.debug("Size of accMap at CE Stop " + ceAccMapIdArray.length);

		while (accRead < ceAccMapIdArray.length)
		{
			int accRemaining = ceAccMapIdArray.length - accRead;
			if (accRemaining <= BATCH_SIZE_ESI)
			{// this catches smaller chunks under 5k
				accRunningSize = accRemaining;
			}

			Integer[] accListArray = new Integer[accRunningSize];

			try
			{
				System.arraycopy(ceAccMapIdArray, accRead, accListArray, 0, accListArray.length);
				accRead = accRead + accRunningSize;
			} catch (Exception e)
			{
				e.printStackTrace();
				return;
			}
			List<Integer> accList = new ArrayList<Integer>(accListArray.length);
			for (Integer acc : accListArray)
			{
				accList.add(acc);

			}
			controlEventPowerBean.updateCeTablesOnStop(accList, ceId, currTime, TenantContext.getCurrentTenant());

		}

		controlEventBeanFacade.updateCeAccountMapStopTimes(ce);

		Results esiResults = cacheManager.getCacheDataControlEventId(cacheManager.getGwEsiCache(), ceId);
		logger.debug("Removing CeId from Esis, esiResults.size() =  " + esiResults.size());
		for (Result esiResult : esiResults.all())
		{
			esiCache = (EsiCacheData) esiResult.getValue();
			if (esiCache == null)
			{
				continue;
			}

			boolean createLog = esiCache.getCeAccountMapId() > 0;

			esiCache.setCeId(0);
			esiCache.setOptOutFlag(OpsCenterConstants.FALSE);
			esiCache.setCeAccountMapId(0);
			esiCache.setCeDeviceMqIds(null);
			esiCache.setCeDeviceMacIds(null);
			// dev-470-- wait to set mode after GW responds to prevent mode
			// mismatch in DB
			// esiCache.setEsiMode(OpsCenterConstants.ESI_MODE_NORMAL);
			esiCache.setDutyCycle(0);
			// do we need to reset it here?? esiCache.setRoundRobinCnt(0);
			// now add ESI log
			Element esiElement = new Element(esiCache.getCacheKey(), esiCache); // cacheManager.getGwEsiCache().get(esiCache.getCacheKey());
			cacheManager.getGwEsiCache().put(esiElement);

			if (createLog)
			{
				Esi refEsi = controlEventBeanFacade.getRefEsiByEsiId(esiCache.getEsiId());

				logger.info("Creating CE Esi log for Ref Esi Id = " + refEsi.getEsiId());

				CeEsiLog ceEsiLog = new CeEsiLog();
				ceEsiLog.setControlEventId(ce);
				ceEsiLog.setDateCreated(currTime);
				ceEsiLog.setEsiId(refEsi);
				ceEsiLog.setLogMessage("Gateway is Stopping participation in the " + OpsCenterConstants.CE_NAME);
				// PHNX-28 STOPPING no more will be use so replacing STOPPING ->
				// STOPPED
				CeEsiStatus ceEsiStatusId = controlEventBeanFacade.getRefCeEsiStatusByCeEsiStatusId(OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(
						OpsCenterConstants.STOPPED).intValue());
				ceEsiLog.setCeEsiStatusId(ceEsiStatusId);

				controlEventBeanFacade.createCeEsiLog(ceEsiLog);
			}
		}
		esiResults.discard();

		// now clear CE info from any GS devices
		Results dcResults = cacheManager.getCacheDataControlEventId(cacheManager.getGwDCCache(), ceId);

		for (Result dc : dcResults.all())
		{
			EsiDcCacheData dcCache = (EsiDcCacheData) dc.getValue();
			// dcCache.setCeId(0);
			// now clear the optout flag for the TSTAT correspoding to the RMM
			// DC
			// DEV-3253 Send Ce Data to NISC MDM
			// When mode changed from Control to Normal we need to update
			// CeDevices table to set rampout_end_time = reading time;
			// set ceDevice id in esiDc Cache
			logger.info("Setting CeDevId in cache");
			Results devResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getCeDevCache(), dcCache.getEsiDcId());
			CEDevicesCacheData devCache = null;
			for (Result devResult : devResults.all())
			{
				devCache = (CEDevicesCacheData) devResult.getValue();
				if (devCache != null)
				{
					logger.info("CeDevice id is " + devCache.getCeDevicesId());
					dcCache.setLastCeDeviceId(devCache.getCeDevicesId());
				}
			}
			//Now check DRLC ResponseTime-- if null, that means device never responded to drlc start and was never in current CE
			//so clear the dcMode / ceLastCeDeviceId to allow it to go into a new CE--KRMT-7751
			if (dcCache.getDrlcResponseTime() == null) {
				dcCache.setDcMode(OpsCenterConstants.ESI_MODE_NORMAL);
			    dcCache.setLastCeDeviceId(0);
			}
			dcCache.setOptOutReason(null);
			logger.debug("Clearing OPTOUT flag for esiDcId =  " + dcCache.getEsiDcId());

			dcCache.setOptOutFlag(OpsCenterConstants.FALSE);
			dcCache.setCeId(0);
			dcCache.setOptOutWindowStarttime(null);
			dcCache.setOptOutWindowEndtime(null);
			dcCache.setCeStartMsgP2P(null);
			dcCache.setDrlcStartTime(null);
			dcCache.setDrlcResponseTime(null);
			dcCache.setDrlcRetransmitCount(0);
			dcCache.setCurrentManageModeName(null);
			dcCache.setCurrentManageModeTimeStamp(null);
			dcCache.setOptOutTimeStamp(null);

			Element dcElement = new Element(dcCache.getCacheKey(), dcCache); // cacheManager.getGwEsiCache().get(esiCache.getCacheKey());
			cacheManager.getGwDCCache().put(dcElement);
		}
		Results devResults = cacheManager.getCacheDataByAccMapId(cacheManager.getCeDevCache(), ceAccMapIdList);

		for (Result devResult : devResults.all())
		{
			devMapCache = (CEDevicesCacheData) devResult.getValue();
			if (devMapCache == null)
			{
				continue;
			}
			int devId = devMapCache.getCeDevicesId();
			if (devMapCache.getEndTime() == 0)
			{
				CeDevices dbCeDev = controlEventBeanFacade.getRefCeDevicesByCeDevicesId(devId);
				logger.debug("Updating CeDeviceLogs on Stop CE, for ceDevId =  " + devMapCache.getCeDevicesId());

				// now add Devices log
				CeDevicesLog ceDevicesLog = new CeDevicesLog();
				ceDevicesLog.setControlEventId(ce);
				ceDevicesLog.setDateCreated(currTime);
				ceDevicesLog.setCeDevicesId(dbCeDev);
				// krmt-2094-- add device name to log
				String devName = OpsCenterConstants.deviceTypeToNameMap.get(devMapCache.getDevTypeId());
				ceDevicesLog.setLogMessage("Device " + devName + " Stopping participation in " + OpsCenterConstants.CE_NAME);
				// PHNX-28 STOPPING no more will be use so replacing STOPPING ->
				// STOPPED
				CeEsiStatus ceEsiStatusId = controlEventBeanFacade.getRefCeEsiStatusByCeEsiStatusId(OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(
						OpsCenterConstants.STOPPED).intValue());
				ceDevicesLog.setCeEsiStatusId(ceEsiStatusId);
				try
				{
					controlEventBeanFacade.createCeDevicesLog(ceDevicesLog);
				} catch (Exception ex)
				{
					logException(ex, ceDevicesLog.getLogMessage());
					// throw new
					// DatabaseUpdateFailed(DefaultResources.DB_ERR_CODE_UPDATE_FAILED,
					// "DB Create failed for CeDevicesLog for ceDevicesId = "
					// + dbCeDev.getCeDevicesId());
				}
			}

			try
			{
				cacheManager.deleteCEDevicesCacheEntry(devId);
			} catch (AbstractOpsCenterException aoce)
			{
				logger.error("Unable to delete CE devices cache entry for CE Id " + ceId + ", devMapCache.getCeDevicesId() " + devId);
			}

		}// for (Result devResult : devResults.all()) ....
		devResults.discard();
	}

	private Map<Integer, EsiCacheData> getEsiIdToEsiMap(Cache esiCache)
	{
		Map<Integer, EsiCacheData> esiIdToEsiMap = new HashMap<Integer, EsiCacheData>();

		List<?> cacheKeys = esiCache.getKeys();

		for (Object cacheKey : cacheKeys)
		{
			EsiCacheData esi = (EsiCacheData) (esiCache.get(cacheKey)).getObjectValue();
			esiIdToEsiMap.put(esi.getEsiId(), esi);

		}

		return esiIdToEsiMap;
	}

	private Results getCacheDataByCeIdV2(Cache cache, int id)
	{

		Attribute<Integer> ceId = cache.getSearchAttribute("ceId");
		Query query = cache.createQuery();
		query.includeValues();
		query.addCriteria(ceId.eq(id));
		Results results = query.execute();
		query.end();
		return results;
	}

	@Override
	public void updateCeDataAfterAddBack(ControlEventCacheData ceCache, EsiDcCacheData dcCache, EsiCacheData esiCache, boolean addCeAcc)
	{

		logger.info("Enter updateCeDataAfterAddBack, devMac=  " + dcCache.getDeviceMacId());

		// first find ceAccount map cache
		Results accMapResults = cacheManager.getCacheDataByCeIdAndEsiId(cacheManager.getCeAccMapCache(), ceCache.getCeId(), esiCache.getEsiId());
		CeAccountMap ceAccMap = null;

		ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceCache.getCeId());
		if (ce.getStopTime() != null && ce.getStopTime().getMillis() <= new DateTime().getMillis())
		{
			logger.debug("CE has already ended, so ignore trying to add data back for CEid= " + ce.getControlEventId());
			return;
		}
		final Map<Integer, CeAccountMapModel> esiToAcctMap = new HashMap<Integer, CeAccountMapModel>();
		List<Integer> esiList = new ArrayList<Integer>();
		Map<Integer, Integer> esiDcToEsi = new HashMap<Integer, Integer>();
		esiDcToEsi.put(dcCache.getEsiDcId(), esiCache.getEsiId());
		DateTime currTime = new DateTime();
		CEAccountMapCacheData accMap = null;
		int ceGrpMap = 0;
		for (Result accMapResult : accMapResults.all())
		{
			accMap = (CEAccountMapCacheData) accMapResult.getValue();
			if (accMap != null)
			{
				// found ceAccMap in cache, no need to add
				ceAccMap = controlEventBeanFacade.findCeAccountMapByCeAccountMapId(accMap.getCeAccMapId());
				ceGrpMap = accMap.getCeGroupMapId();
				cacheManager.updateCEAccountMapCache(ceAccMap, ceGrpMap, esiCache.getEsiId(), ce);
				break;
			}
		}

		if (ceAccMap == null)
		{
			// this means the cache was cleared for ceAccountMap--so go to db
			List<CeAccountMap> ceAccMapList = controlEventBeanFacade.getCeAccountMapByControlEventIdAccountId(ce.getControlEventId(), esiCache.getAccountId());
			if (ceAccMapList != null && !ceAccMapList.isEmpty())
			{
				ceAccMap = ceAccMapList.get(0);
				List<CeGroupMap> ceGrpMapList = controlEventBeanFacade.getCeGroupMapByControlEventId(ceCache.getCeId());
				if (ceGrpMapList != null && ceGrpMapList.size() > 0)
					ceGrpMap = ceGrpMapList.get(0).getCeGroupMapId();
				else
				{
					logger.error("No Grp Map found in DB for ce Id = " + ceCache.getCeId());
					return;
				}
				// now update CeAccountMapCache
				cacheManager.updateCEAccountMapCache(ceAccMap, ceGrpMap, esiCache.getEsiId(), ce);

			}
		}

		if (addCeAcc && ceAccMap == null)
		{

			CeGroupMap grpMap = null;
			List<CeGroupMap> ceGrpMapList = controlEventBeanFacade.getCeGroupMapByControlEventId(ceCache.getCeId());
			if (ceGrpMapList == null || ceGrpMapList.size() <= 0)
			{
				logger.error("no ceGrpMap found in db for ceId = " + ceCache.getCeId() + " exiting");
				return;
			}
			List<Integer> esiGrpList = esiCache.getGrpIdList();
			for (Iterator<CeGroupMap> iterator = ceGrpMapList.iterator(); iterator.hasNext();)
			{
				grpMap = iterator.next();
				if (esiGrpList.contains(grpMap.getCeGroupId().getCeGroupId()))
				{
					logger.debug("found CE grp for acc id-- grp/accid =  " + grpMap.getCeGroupId().getCeGroupId() + "/" + esiCache.getAccountId());
					ceGrpMap = grpMap.getCeGroupId().getCeGroupId();
					break;
				}
			}

			CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
			ceAccMapModel.setCeGroupId(ceGrpMap);
			ceAccMapModel.setAccountId(esiCache.getAccountId());
			ceAccMapModel.setInitialPowerRemovable(0);
			ceAccMapModel.setPowerConsumed(0);
			ceAccMapModel.setPowerToRemove(0);
			// If this account was added at the start of the CE then
			// this
			// value must equal the CE start time
			ceAccMapModel.setStartTime(ceCache.getStartTime());
			ceAccMapModel.setStopTime(null);
			User user = null;
			try
			{
				user = userAccBeanFacade.findUserByUsername(ce.getUserCreated());
			} catch (UserNotUniqueException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			ceAccMapModel.setUserId(user.getUserId());
			ceAccMapModel.setControlEventId(ce.getControlEventId());
			ceAccMapModel.setOptOutFlag(OpsCenterConstants.FALSE);
			ceAccMapModel.setMissingReadsFlag(OpsCenterConstants.FALSE);
			ceAccMapModel.setCeGroupMapId(grpMap.getCeGroupMapId());
			ceAccMapModel.setEsiCacheKey(esiCache.getCacheKey());
			ceAccMapModel.setDutyCycle(ceGrpMapList.get(0).getDutyCycle());
			esiList.add(esiCache.getEsiId());
			esiToAcctMap.put(esiCache.getEsiId(), ceAccMapModel);

			addCeAccountMapOnly(ceCache.getCeId(), esiList, esiToAcctMap);
			entityManager.flush();
			List<CeAccountMap> ceAccMapList = controlEventBeanFacade.getCeAccountMapByControlEventIdAccountId(ceCache.getCeId(), esiCache.getAccountId());
			if (ceAccMapList == null || ceAccMapList.size() <= 0)
			{
				logger.error("Cannot find ceAccountMap in DB for Mac address = " + dcCache.getDeviceMacId() + " exiting");
				return;
			}
			ceAccMap = ceAccMapList.get(0);

		}

		if (ceAccMap == null)
		{
			logger.error("Cannot find ceAccountMap in DB or cache for Mac address = " + dcCache.getDeviceMacId() + " exiting");
			return;
		}

		CeAccountMapModel ceAccMapModel = new CeAccountMapModel();
		ceAccMapModel.setCeGroupMapId(ceGrpMap);
		esiToAcctMap.put(esiCache.getEsiId(), ceAccMapModel);

		List<CeDevicesLog> ceDevicesList = new ArrayList<CeDevicesLog>();
		Element esiElement = cacheManager.getGwEsiCache().get(esiCache.getCacheKey());
		EsiCacheData esiCacheData = (EsiCacheData) esiElement.getObjectValue();
		esiCacheData.setCeId(ce.getControlEventId());
		cacheManager.getGwEsiCache().put(esiElement);
		// the mode of GS devices is managed at the device level, so check
		// here for VPP and dont set mode if = GS

		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), dcCache.getEsiDcId());
		Result dc = null;
		for (Result esiDcResult : esiDcResults.all())
		{
			dc = esiDcResult;
		}

		final CeEsiStatus ceEsiStatusId = entityManager.getReference(CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(OpsCenterConstants.IN_PROGRESS).intValue());

		try
		{
			CeDevicesLogData ceDevicesLogData = addDeviceToCE(dc, ceAccMap, esiCache.getEsiId(), ce, ceAccMap.getCeGroupId().getCeGroupId(), currTime, currTime);

			if (null != ceDevicesLogData)
			{
				// we must now create the entity since we are now managed by the
				// session bean
				CeDevicesLog ceLog = new CeDevicesLog();
				ceLog.setControlEventId(ceDevicesLogData.getControlEventId());
				ceLog.setDateCreated(ceDevicesLogData.getDateCreated());
				ceLog.setCeDevicesId(ceDevicesLogData.getCeDevicesId());
				ceLog.setLogMessage(ceDevicesLogData.getLogMessage());
				ceLog.setCeEsiStatusId(ceEsiStatusId);
				ceDevicesList.add(ceLog);
			}
			controlEventBeanFacade.persistCeDevicesList(ceDevicesList);
			for (CeDevicesLog ceDeviceLog : ceDevicesList)
			{

				updateCeDevicesCache(ceDeviceLog, esiToAcctMap, ce, esiDcToEsi);
			}
			// dev-343-- set the start time in case this grp is getting added
			// back to CE fresh
			// if start is not ZERO means this grp is still in CE
			Results grpResult = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpCache(), ceAccMap.getCeGroupId().getCeGroupId());
			for (Result grp : grpResult.all())
			{
				CEGroupCacheData ceGroupCache = (CEGroupCacheData) grp.getValue();
				if (ceGroupCache.getCeStartTime() == 0)
				{
					ceGroupCache.setCeStartTime(new DateTime().getMillis());
					ceGroupCache.setCeId(ceCache.getCeId());
					Element grpElement = new Element(ceGroupCache.getCeGrpId(), ceGroupCache);
					cacheManager.getCeGrpCache().put(grpElement);
				}
			}
		} catch (AbstractOpsCenterException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		esiDcResults.discard();
		logger.info("Finished updating CE data in cache after re-add, exiting ");

	}

	@Override
	public Map<Integer, Integer> getDutyCycleByDeviceTypeForCeId(int ceId)
	{
		Map<Integer, Integer> dutyCycleByDeviceType = new HashMap<Integer, Integer>();

		List<DefinitionEventMap> defnEventList = controlEventBeanFacade.getCeDefinitionEventMapByCeId(ceId);

		// null values for deviceTypeId and dutyCycle denote this as a duty
		// cycle by group event
		if (defnEventList == null || defnEventList.isEmpty() || defnEventList.get(0).getDeviceTypeId() == null || defnEventList.get(0).getDutyCycle() == null)
		{
			return dutyCycleByDeviceType;
		}

		for (DefinitionEventMap defnEvent : defnEventList)
		{
			dutyCycleByDeviceType.put(defnEvent.getDeviceTypeId().getDeviceTypeId(), defnEvent.getDutyCycle());
		}

		return dutyCycleByDeviceType;
	}

	@Override
	public Map<Integer, Integer> getDutyCycleByDeviceTypeValuesForCeId(int ceId)
	{
		return getDutyCycleByDeviceTypeForCeId(ceId);
	}

	private double calculatePowerAvailForCE(int ceId)
	{
		Integer tenantId = TenantContext.getCurrentTenant();
		DateTime lastTSPowerAvailForCEsCalculated = new DateTime();
		if(lastTSPowerAvailForCEsCalculatedMap.get(tenantId) == null) {
			lastTSPowerAvailForCEsCalculatedMap.put(tenantId, lastTSPowerAvailForCEsCalculated);
		} else {
			lastTSPowerAvailForCEsCalculated = lastTSPowerAvailForCEsCalculatedMap.get(tenantId);
		}
		
		if(powerAvailForCEsMap.get(tenantId) == null) {
			powerAvailForCEsMap.put(tenantId, new HashMap<Integer, Double>());
		}
		
		DateTime currentTS = new DateTime();
		if (lastTSPowerAvailForCEsCalculated.getMillis() + 60000 < currentTS.getMillis())
		{
			lastTSPowerAvailForCEsCalculated = new DateTime();
			// Get a set of CE Group Ids involved in this CE
			List<CEGroupMapCacheData> ceGroupMapList = getCeGroupMapsByCe(ceId);
			List<Integer> grpPowerIdList = new ArrayList<Integer>();
			List<Integer> powerEndedInGroup = new ArrayList<Integer>();
			// Get a list of all DCs in and out of the CE
			long now = System.currentTimeMillis();

			Cache ceDevCache = cacheManager.getCeDevCache();
			for (CEGroupMapCacheData ceGroupMap : ceGroupMapList)
			{
				// Get the Group Power Ids for this group
				ArrayList<Integer> grpPowerIdListForGroup = getGroupPowerIdsForGroup(ceGroupMap.getCeGrpId());
				grpPowerIdList.addAll(grpPowerIdListForGroup);

				// Get the CE Devices for this group power
				Results ceDevicesResults = cacheManager.getCacheDataByGrpMapId(ceDevCache, ceGroupMap.getCeGrpMapId());
				for (Result ceDevicesResult : ceDevicesResults.all())
				{
					CEDevicesCacheData ceDevicesCacheData = (CEDevicesCacheData) ceDevicesResult.getValue();
					if (ceDevicesCacheData == null)
					{
						continue;
					}

					// Get the ESI DC IDs for CE Devices ended for this group
					// power
					if (ceDevicesCacheData.getEndTime() > 0 && ceDevicesCacheData.getEndTime() <= now)
					{
						powerEndedInGroup.add(ceDevicesCacheData.getEsiDcId());
					}
				}
				ceDevicesResults.discard();
			}

			// Loop through the DCs and accumulate power available
			double powerForCe = 0.0;
			double powerOptedOut = 0.0;
			Results dcResults = cacheManager.getCacheData(cacheManager.getGwDCCache());
			for (Result dcResult : dcResults.all())
			{
				EsiDcCacheData esiDcCacheData = (EsiDcCacheData) dcResult.getValue();

				boolean isInGroup = false;
				for (int groupPowerId : esiDcCacheData.getGrpPowerIdList())
				{
					// For each ESI DC for any of the groups in the CE
					if (grpPowerIdList.contains(groupPowerId))
					{
						isInGroup = true;
						break;
					}
				}

				if (isInGroup)
				{
					// Accumulate power for any ESI that has not ended in this
					// CE
					if (!powerEndedInGroup.contains(esiDcCacheData.getEsiDcId()))
					{
						powerForCe += esiDcCacheData.getActEnergyAvail();
					}
					else
					{
						powerOptedOut += esiDcCacheData.getActEnergyAvail();
					}
				}
			}
			dcResults.discard();

			logger.debug("getPowerAvailForCE Power Opted Out = " + powerOptedOut);
			logger.debug("getPowerAvailForCE Power Avail For DB = " + powerForCe);

			powerAvailForCEsMap.get(tenantId).put(ceId, powerForCe);
			lastTSPowerAvailForCEsCalculatedMap.put(tenantId, new DateTime());
			return powerForCe;
		}
		else
		{
			double powerAvailForCE = 0.0;
			if (null != powerAvailForCEsMap.get(tenantId).get(ceId))
			{
				powerAvailForCE = powerAvailForCEsMap.get(tenantId).get(ceId);
			}
			return powerAvailForCE;
		}
	}

	/**
	 * @param controlEventId
	 * @return
	 */
	private Set<String> checkForDutyCycleByDeviceType(int controlEventId)
	{
		logger.info("[ENTER] Set<String> checkForDutyCycleByDeviceType(controlEventId = " + controlEventId + ")");

		Map<Integer, Integer> dutyCycleByDeviceTypeMap = getDutyCycleByDeviceTypeForCeId(controlEventId);

		Set<String> deviceTypeNames = new TreeSet<String>();

		if (dutyCycleByDeviceTypeMap.isEmpty())
		{
			logger.info("[ EXIT] checkForDutyCycleByDeviceType");
			return null;
		}

		for (Integer deviceTypeId : dutyCycleByDeviceTypeMap.keySet())
		{
			String devType = null;

			if (deviceTypeId == OpsCenterConstants.DEVICE_TYPE_ID_TSTAT)
			{
				devType = OpsCenterConstants.DC_HVAC;
			}
			else
			{
				devType = OpsCenterConstants.DeviceType.fromId(deviceTypeId).getValue();
			}

			deviceTypeNames.add(devType);
		}

		return deviceTypeNames;
	}

	private ControlEventPowerModel calculatePowerAvail(Integer controlEventId, Set<Integer> ceGroupIdSet, OpsCenterConstants.eventMode eventMode)
	{
		logger.info("[ENTER] ControlEventPowerModel ControlEventPowerBean.calculatePowerAvail(controlEventId = " + controlEventId + ", ceGroupIdSet = "
				+ ceGroupIdSet + ", eventMode = " + eventMode + ")");

		lastTSPowerAvailCalculatedMap.put(TenantContext.getCurrentTenant(), new DateTime());
		CEGroupCacheData grpCacheData = null;
		Results grpResult = cacheManager.getCacheData(cacheManager.getCeGrpCache());
		for (Result grResult : grpResult.all())
		{

			grpCacheData = (CEGroupCacheData) grResult.getValue();
			logger.info("The Group Id is" + grpCacheData.getCeGrpId());
		}

		if (grpResult.size() == 0)
		{
			logger.error("No GRP entries found in cache, cant compute power avail");
			logger.info("[ EXIT] ControlEventPowerBean.getPowerAvail");
			return null;
		}

		List<GroupPowerModel> grpList = new ArrayList<GroupPowerModel>();

		double utilPowerRemoved = 0.0;

		DateTime currTime = new DateTime();
		ControlEventPowerModel ceModel = new ControlEventPowerModel();

		Map<Integer, Integer> activeGwCntByCeGroupId = controlEventBeanFacade.getCountOfActiveAccountsForCeGroupId();

		Map<Integer, Integer> ceGroupIdByEsiIdInControl = new HashMap<Integer, Integer>();

		// There are two outputs to this code segment
		// ceAccountMapIdsByCeGroupMapId: a map of CE account Maps organized by
		// CE Group Map
		// ceGroupIdByEsiIdInControl: a map of ESIs organized by CE Group Map
		Map<Integer, List<Integer>> ceAccountMapIdsByCeGroupMapId = new HashMap<Integer, List<Integer>>();
		Results accMapResults = cacheManager.getCacheData(cacheManager.getCeAccMapCache());
		for (Result accMap : accMapResults.all())
		{
			CEAccountMapCacheData accMapCache = (CEAccountMapCacheData) accMap.getValue();
			if (accMapCache == null)
			{
				continue;
			}
			List<Integer> accMapIdList = ceAccountMapIdsByCeGroupMapId.get(accMapCache.getCeGroupMapId());
			if (accMapIdList == null)
			{
				accMapIdList = new ArrayList<Integer>();
				ceAccountMapIdsByCeGroupMapId.put(accMapCache.getCeGroupMapId(), accMapIdList);
			}
			accMapIdList.add(accMapCache.getCeAccMapId());
			logger.debug("found an acc in ctrl, accMapId = " + accMapCache.getCeAccMapId());
			ceGroupIdByEsiIdInControl.put(accMapCache.getEsiId(), accMapCache.getCeGrpId());
		}
		accMapResults.discard();

		// Get a list of CE Group IDs organized by CE Group Power ID.
		// Include only for requested CE Groups.
		Map<Integer, Integer> ceGrpPowerIdToCeGrp = new HashMap<Integer, Integer>();
		Results ceGrpPowerResults = cacheManager.getCacheData(cacheManager.getCeGrpPowerCache());
		for (Result result : ceGrpPowerResults.all())
		{
			CEGroupPowerCacheData ceGroupPowerCache = (CEGroupPowerCacheData) result.getValue();
			if (ceGroupPowerCache != null)
			{
				if (ceGroupIdSet == null || ceGroupIdSet.contains(ceGroupPowerCache.getCeGrpId()))
				{
					ceGrpPowerIdToCeGrp.put(ceGroupPowerCache.getGrpPowerId(), ceGroupPowerCache.getCeGrpId());
					logger.debug("adding grpId to grpPowerId hash, grp Id =  " + ceGroupPowerCache.getCeGrpId());

				}
			}
		}

		Set<Integer> consumingEsiIds = new HashSet<Integer>();
		HashMap<Integer, Integer> consumingEsiByGrp = new HashMap<Integer, Integer>();
		Set<Integer> uniqueEsiIds = new HashSet<Integer>();
		Map<Integer, Map<String, DeviceClassPowerSummaryData>> powerByCeGroupId = new HashMap<Integer, Map<String, DeviceClassPowerSummaryData>>();

		Results dcResults = cacheManager.getCacheData(cacheManager.getGwDCCache());
		PowerAvailData powerAvail = new PowerAvailData();
		for (Result dcResult : dcResults.all())
		{
			EsiDcCacheData dcCache = (EsiDcCacheData) dcResult.getValue();
			if (dcCache != null)
			{
				DcCacheData dcData = new DcCacheData();
				dcData.setCeGrpPowerIdList(dcCache.getGrpPowerIdList());
				dcData.setReadingTime(dcCache.getReadingTime());
				dcData.setEsiId(dcCache.getEsiId());
				dcData.setActEnergyConsumed(dcCache.getActEnergyConsumed());
				dcData.setActEnergyAvail(dcCache.getActEnergyAvail());
				dcData.setDevType(dcCache.getDeviceType());
				// DEV-1922 deviceCount never got updated before,
				// which is why it was always 0 in the logs
				dcData.setDeviceCount(dcData.getDeviceCount() + 1);
				determineDcPower(dcData, ceGroupIdByEsiIdInControl, ceGrpPowerIdToCeGrp, consumingEsiIds, eventMode, powerByCeGroupId, consumingEsiByGrp,
						uniqueEsiIds, powerAvail);
			}
		}
		dcResults.discard();

		LinkedHashMap<String, Double> utilPowerAvailList = new LinkedHashMap<String, Double>();
		utilPowerAvailList.put(OpsCenterConstants.HVAC, powerAvail.getUtilHvacAvail());
		utilPowerAvailList.put(OpsCenterConstants.WH, powerAvail.getUtilWhAvail());
		utilPowerAvailList.put(OpsCenterConstants.PP, powerAvail.getUtilPpAvail());
		utilPowerAvailList.put(OpsCenterConstants.EV, powerAvail.getUtilEvChargerAvail());
		utilPowerAvailList.put(OpsCenterConstants.IP, powerAvail.getUtilIrrigationPumpAvailable());
		utilPowerAvailList.put(OpsCenterConstants.HS, powerAvail.getUtilHvacSwitchAvail());
		utilPowerAvailList.put(OpsCenterConstants.CH, powerAvail.getUtilCropHeatAvailable());
		utilPowerAvailList.put(OpsCenterConstants.GEN, powerAvail.getUtilGeneratorAvailable());
		utilPowerAvailList.put(OpsCenterConstants.SH, powerAvail.getUtilSingleHeatAvailable());
		utilPowerAvailList.put(OpsCenterConstants.DH, powerAvail.getUtilDualHeatAvailable());

		ceModel.setPowerAvailByDeviceTypeID(utilPowerAvailList);

		LinkedHashMap<String, Integer> utilDeviceList = new LinkedHashMap<String, Integer>();
		utilDeviceList.put(OpsCenterConstants.HVAC, powerAvail.getUtilHvacCount());
		utilDeviceList.put(OpsCenterConstants.WH, powerAvail.getUtilWhCount());
		utilDeviceList.put(OpsCenterConstants.PP, powerAvail.getUtilPpCount());
		utilDeviceList.put(OpsCenterConstants.EV, powerAvail.getUtilEvChargerCount());
		utilDeviceList.put(OpsCenterConstants.IP, powerAvail.getUtilIrrigationCount());
		utilDeviceList.put(OpsCenterConstants.HS, powerAvail.getUtilHvacSwitchCount());
		utilDeviceList.put(OpsCenterConstants.CH, powerAvail.getUtilCropHeatCount());
		utilDeviceList.put(OpsCenterConstants.GEN, powerAvail.getUtilGeneratorCount());
		utilDeviceList.put(OpsCenterConstants.SH, powerAvail.getUtilSingleHeatCount());
		utilDeviceList.put(OpsCenterConstants.DH, powerAvail.getUtilDualHeatCount());

		ceModel.setDeviceCountByDeviceTypeID(utilDeviceList);

		ceModel.setNumberOfGateways(uniqueEsiIds.size());
		uniqueEsiIds = null;
		ceModel.setPowerAvailable(powerAvail.getUtilPowerAvail());
		ceModel.setNumberOfGatewaysConsuming(consumingEsiIds.size());
		logger.debug("# of GWs consuming = " + ceModel.getNumberOfGatewaysConsuming());

		double powerAvailMultipler = genericBean.getCeEstFuturePowerAvailPerGw();
		for (Result grpR : grpResult.all())
		{
			double totalHvacAvail = 0.0;
			double totalWhAvail = 0.0;
			double totalPpAvail = 0.0;
			double totalHvacSwitchAvail = 0.0;
			double totalEvChargerAvail = 0.0;
			double totalIrrigationPumpAvailable = 0.0;
			double totalCropHeatAvail = 0.0;
			double totalGeneratorAvail = 0.0;
			double totalSingleHeatAvail = 0.0;
			double totalDualHeatAvailable = 0.0;
			
			double totalHvacConsumed = 0.0;
			double totalWhConsumed = 0.0;
			double totalPpConsumed = 0.0;
			double totalHvacSwitchConsumed = 0.0;
			double totalEvChargerConsumed = 0.0;
			double totalIrrigationPumpConsumed = 0.0;
			double totalCropHeatConsumed = 0.0;
			double totalGeneratorConsumed = 0.0;
			double totalSingleHeatConsumed = 0.0;
			double totalDualHeatConsumed = 0.0;

			int hvacDeviceCount = 0;
			int whDeviceCount = 0;
			int ppDeviceCount = 0;
			int hvacSwitchDeviceCount = 0;
			int evChargerDeviceCount = 0;
			int irrigationPumpDeviceCount = 0;
			int cropHeatDeviceCount = 0;
			int generatorDeviceCount = 0;
			int singleHeatDeviceCount = 0;
			int dualHeatDeviceCount = 0;

			CEGroupCacheData grpCache = (CEGroupCacheData) grpR.getValue();

			// Apply filter
			if (ceGroupIdSet != null && !ceGroupIdSet.contains(grpCache.getCeGrpId()))
			{
				continue;
			}

			GroupPowerModel grpPwr = new GroupPowerModel();
			grpPwr.setGrpId(grpCache.getCeGrpId());
			grpPwr.setName(grpCache.getName());
			grpPwr.setAlreadyInControl(OpsCenterConstants.FALSE);
			grpPwr.setAdditionalPowerToRemove(0.0);
			grpPwr.setPowerToRemove(0.0);
			grpPwr.setNumberOfGatewaysConsuming(0);
			grpPwr.setDutyCycle(0xff);
			logger.debug("GRP id from grpCacheData : " + grpCache.getCeGrpId());

			if (consumingEsiByGrp.get(grpCache.getCeGrpId()) != null)
			{
				grpPwr.setNumberOfGatewaysConsuming(consumingEsiByGrp.get(grpCache.getCeGrpId()));
				logger.debug(String.format("# of GW consuming for grpId %d : %d", grpCache.getCeGrpId(), grpPwr.getNumberOfGatewaysConsuming()));
			}

			grpPwr.setAuto(grpCache.getAutoGroupCreateFlag().equals(OpsCenterConstants.TRUE));
			grpPwr.setGroupType(grpCache.getAutoGroupCreateTypeId());

			Integer count = activeGwCntByCeGroupId.get(grpCache.getCeGrpId());
			if (count != null)
			{
				grpPwr.setNumberOfGateways(count);
				grpPwr.setMaxFuturePowerAvailable(powerAvailMultipler * count);
			}

			Map<String, DeviceClassPowerSummaryData> powerByDevice = powerByCeGroupId.get(grpCache.getCeGrpId());

			if (powerByDevice != null)
			{
				Set<String> deviceTypeSet = powerByDevice.keySet();
				for (String deviceType : deviceTypeSet)
				{
					DeviceClassPowerSummaryData power = powerByDevice.get(deviceType);

					logger.debug(String.format("%s power available: %.2f, power consumed: %.2f, device count : %d", deviceType, power.powerAvailable,
							power.powerConsumed, power.deviceCount));

					if (OpsCenterConstants.DC_HVAC.equals(deviceType))
					{
						totalHvacAvail += power.powerAvailable;
						totalHvacConsumed += power.powerConsumed;
						hvacDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_WATER_HEATER.equals(deviceType))
					{
						totalWhAvail += power.powerAvailable;
						totalWhConsumed += power.powerConsumed;
						whDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_POOL_PUMP.equals(deviceType))
					{
						totalPpAvail += power.powerAvailable;
						totalPpConsumed += power.powerConsumed;
						ppDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_EV_CHARGER.equals(deviceType))
					{
						totalEvChargerAvail += power.powerAvailable;
						totalEvChargerConsumed += power.powerConsumed;
						evChargerDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_IRRIGATION_PUMP.equals(deviceType))
					{
						totalIrrigationPumpAvailable += power.powerAvailable;
						totalIrrigationPumpConsumed += power.powerConsumed;
						irrigationPumpDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_HVAC_SWITCH.equals(deviceType))
					{
						totalHvacSwitchAvail += power.powerAvailable;
						totalHvacSwitchConsumed += power.powerConsumed;
						hvacSwitchDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_CROP_HEAT.equals(deviceType))
					{
						totalCropHeatAvail += power.powerAvailable;
						totalCropHeatConsumed += power.powerConsumed;
						cropHeatDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_GENERATOR.equals(deviceType))
					{
						totalGeneratorAvail += power.powerAvailable;
						totalGeneratorConsumed += power.powerConsumed;
						generatorDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_SINGLE_HEAT.equals(deviceType))
					{
						totalSingleHeatAvail += power.powerAvailable;
						totalSingleHeatConsumed += power.powerConsumed;
						singleHeatDeviceCount += power.deviceCount;
					}
					else if (OpsCenterConstants.DC_DUAL_HEAT.equals(deviceType))
					{
						totalDualHeatAvailable += power.powerAvailable;
						totalDualHeatConsumed += power.powerConsumed;
						dualHeatDeviceCount += power.deviceCount;
					}

				}
			}

			logger.debug(String.format("Total device counts, HVAC: %d, WH: %d, PP: %d, EV: %d, IP: %d, CH: %d, GEN: %d%s,", hvacDeviceCount, whDeviceCount, 
					ppDeviceCount, evChargerDeviceCount, irrigationPumpDeviceCount, cropHeatDeviceCount, generatorDeviceCount,
					eventMode.equals(OpsCenterConstants.eventMode.CYCLING) ? ", HS: " + hvacSwitchDeviceCount + ", SH: "+singleHeatDeviceCount + ", DH: "+dualHeatDeviceCount
							: ""));

			logger.debug(String.format("Total device power, HVAC: %.2f, WH: %.2f, PP: %.2f, EV: %.2f, IP: %.2f, CH: %.2f, GEN: %.2f%s",
					totalHvacAvail, totalWhAvail, totalPpAvail,	totalEvChargerAvail, totalIrrigationPumpAvailable, totalCropHeatAvail, totalGeneratorAvail,
					eventMode.equals(OpsCenterConstants.eventMode.CYCLING) ? ", HS: " + totalHvacSwitchAvail + ", SH: "+totalSingleHeatAvail + ", DH: "+totalDualHeatAvailable
							: ""));

			LinkedHashMap<String, Double> projPowerAvailList = new LinkedHashMap<String, Double>();
			projPowerAvailList.put(OpsCenterConstants.HVAC, totalHvacAvail);
			projPowerAvailList.put(OpsCenterConstants.WH, totalWhAvail);
			projPowerAvailList.put(OpsCenterConstants.PP, totalPpAvail);
			projPowerAvailList.put(OpsCenterConstants.EV, totalEvChargerAvail);
			projPowerAvailList.put(OpsCenterConstants.IP, totalIrrigationPumpAvailable);
			projPowerAvailList.put(OpsCenterConstants.HS, totalHvacSwitchAvail);
			projPowerAvailList.put(OpsCenterConstants.CH, totalCropHeatAvail);
			projPowerAvailList.put(OpsCenterConstants.GEN, totalGeneratorAvail);
			projPowerAvailList.put(OpsCenterConstants.SH, totalSingleHeatAvail);
			projPowerAvailList.put(OpsCenterConstants.DH, totalDualHeatAvailable);

			grpPwr.setPowerAvailByDeviceTypeID(projPowerAvailList);

			LinkedHashMap<String, Integer> deviceCountMap = new LinkedHashMap<String, Integer>();
			deviceCountMap.put(OpsCenterConstants.HVAC, hvacDeviceCount);
			logger.debug("grp dev count by grpId, dev " + grpPwr.getGrpId() + " " + hvacDeviceCount);
			deviceCountMap.put(OpsCenterConstants.WH, whDeviceCount);
			logger.debug("grp dev count by grpId, dev " + grpPwr.getGrpId() + " " + whDeviceCount);

			deviceCountMap.put(OpsCenterConstants.PP, ppDeviceCount);
			logger.debug("grp dev count by grpId, dev " + grpPwr.getGrpId() + " " + ppDeviceCount);

			deviceCountMap.put(OpsCenterConstants.EV, evChargerDeviceCount);
			deviceCountMap.put(OpsCenterConstants.IP, irrigationPumpDeviceCount);
			deviceCountMap.put(OpsCenterConstants.HS, hvacSwitchDeviceCount);
			deviceCountMap.put(OpsCenterConstants.CH, cropHeatDeviceCount);
			deviceCountMap.put(OpsCenterConstants.GEN, generatorDeviceCount);
			deviceCountMap.put(OpsCenterConstants.SH, singleHeatDeviceCount);
			deviceCountMap.put(OpsCenterConstants.DH, dualHeatDeviceCount);

			grpPwr.setDeviceCountByDeviceTypeID(deviceCountMap);

			// grpPwr.setProjPowerAvailable(grpCache.getProjPowerAvailable());
			// grpPwr.setProjPowerConsumed(grpCache.getProjPowerConsumed());
			grpPwr.setProjPowerAvailable(totalHvacAvail + totalWhAvail + totalPpAvail + totalEvChargerAvail + totalIrrigationPumpAvailable
					+ totalHvacSwitchAvail + totalCropHeatAvail + totalGeneratorAvail + totalSingleHeatAvail + totalDualHeatAvailable);
			grpPwr.setProjPowerConsumed(totalHvacConsumed + totalWhConsumed + totalPpConsumed + totalEvChargerConsumed + totalIrrigationPumpConsumed
					+ totalHvacSwitchConsumed + totalCropHeatConsumed + totalGeneratorConsumed + totalSingleHeatConsumed + totalDualHeatConsumed);
			logger.debug("Project power available : "+grpPwr.getProjPowerAvailable());
			logger.debug("Project power consumed : "+grpPwr.getProjPowerConsumed());
			double grpPowerRemoved = 0;

			List<ControlEvent> ceList = new ArrayList<ControlEvent>();
			if (controlEventId == null || controlEventId == 0)
			{
				ceList = controlEventBeanFacade.getActiveAndFutureControlEventByTime(currTime);
			}
			else
			{
				ceList = controlEventBeanFacade.getControlEventByControlEventId(controlEventId);
			}

			// Including future fixes 2 issues
			// 1) if CE's are scheduled in the future, then they did not show
			// power to remove on edit
			// 2) reduces the likelihood that 2 future CEs will include the same
			// group

			for (ControlEvent ce : ceList)
			{
				Map<Integer, Integer> dutyCycleByDeviceTypeMap = getDutyCycleByDeviceTypeForCeId(ce.getControlEventId());

				List<CeGroupMap> ceGroupMapList = ce.getCeGroupMapCollection();
				for (CeGroupMap ceGrpMap : ceGroupMapList)
				{
					if (ceGrpMap.getCeGroupId().getCeGroupId() == grpCache.getCeGrpId())
					{
						// this grp found in the ESI tbl is in a CE--set CE id
						// in model
						logger.debug("CeGroup #" + ceGrpMap.getCeGroupId().getCeGroupId() + " is in or scheduled to be in CE #"
								+ ceGrpMap.getControlEventId().getControlEventId());

						grpPwr.setCeId(ceGrpMap.getControlEventId().getControlEventId());
						grpPwr.setPowerToRemove(ceGrpMap.getTotalRequestedPowerToRemove());
						// I don't want this to show up on the UI, showing
						// powerToRemove (initial + additional)
						// grpPwr.setAdditionalPowerToRemove(ceGrpMap.getAdditionalPowerToRemove());
						grpPwr.setAlreadyInControl(OpsCenterConstants.TRUE);

						List<Integer> accMapIdList = ceAccountMapIdsByCeGroupMapId.get(ceGrpMap.getCeGroupMapId());
						if (accMapIdList != null)
						{
							Results ceDevicesResults = cacheManager.getCacheDataByAccMapIdAndNotEnded(cacheManager.getCeDevCache(), accMapIdList);
							for (Result ceDevicesResult : ceDevicesResults.all())
							{
								CEDevicesCacheData ceDevicesCacheData = (CEDevicesCacheData) ceDevicesResult.getValue();
								if (ceDevicesCacheData == null)
								{
									logger.error("Null CEDevicesCacheData entry trying to retrieve powerRemoved");
									continue;
								}
								grpPowerRemoved += ceDevicesCacheData.getIntialPowerRemoveable();
							}
							ceDevicesResults.discard();
						}

						grpPwr.setPowerRemoved(grpPowerRemoved);
						grpPwr.setDutyCycle(ceGrpMap.getDutyCycle());

						if (null != ceGrpMap.getUtilityReleased())
						{
							grpPwr.setUtilityReleased(ceGrpMap.getUtilityReleased());
						}
						else
						{
							grpPwr.setUtilityReleased("0");
						}

						setDutyCycleByDeviceTypeForGroupPowerModel(grpPwr, dutyCycleByDeviceTypeMap);

						if (grpPwr.getDutyCycle() <= 0 && ce.getCycling().equals(OpsCenterConstants.FALSE))
						{
							// if duty cycle in the DB is 0 or less, then this
							// grp is not in the event
							// set a marker for UI to properly reflect this grp
							// not avail for event
							grpPwr.setDutyCycle(0xff);
						}

						logger.debug("duty cycle for grp id = " + ceGrpMap.getDutyCycle() + "/" + grpPwr.getGrpId());

						break;
					}
				}
			}

			utilPowerRemoved = utilPowerRemoved + grpPwr.getPowerRemoved();
			if (count != null && count > 0)
			{
				grpList.add(grpPwr);
			}
		}
		grpResult.discard();

		ceModel.setGroupPowerList(grpList);
		ceModel.setPowerRemoved(utilPowerRemoved);
		logger.debug(String.format("Utility Power Removed / Power Available = %.2f / %.2f", utilPowerRemoved, powerAvail.getUtilPowerAvail()));

		totalPowerAvailMap.put(TenantContext.getCurrentTenant(), ceModel);
		lastTSPowerAvailCalculatedMap.put(TenantContext.getCurrentTenant(), new DateTime());

		logger.info("[ EXIT] ControlEventPowerBean.calculatePowerAvail");

		return ceModel;
	}

	@Override
	public ControlEventPowerModel getPowerAvail(Integer controlEventId, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		if (controlEventId == null)
		{
			logger.error("controlEventId passed in is null.  Returning all power available instead");
			return getPowerAvail(tenantId);
		}

		ControlEventModel ceModel = getControlEventDetails(controlEventId, TenantContext.getCurrentTenant());

		if (ceModel == null)
		{
			logger.error("ControlEventPowerModel for ceId : " + controlEventId + " not found.  Returning all power available instead");
			return getPowerAvail(tenantId);
		}

		return getPowerAvail(ceModel.getControlEventId(), ceModel.getMode());
	}

	private ControlEventPowerModel getPowerAvail(Integer controlEventId, eventMode mode)
	{
		return getPowerAvail(controlEventId, null, mode);
	}

	private void setEsiDcOptOutReason(Integer esiDcId)
	{
		Results esiDcResults = cacheManager.getCacheDataByEsiDcId(cacheManager.getGwDCCache(), esiDcId);
		for (Result dcResult : esiDcResults.all())
		{
			EsiDcCacheData dcCacheData = (EsiDcCacheData) dcResult.getValue();
			if (dcCacheData != null && dcCacheData.getDeviceMacId() != 0)
			{
				dcCacheData.setOptOutReason(OpsCenterConstants.OptOutReason.TSTAT_OVERRIDE);
			}
		}
		esiDcResults.discard();
	}

	/**
	 * Determines whether a CE can be started or stopped. Currently, CEs can
	 * always be started and stopped unless the utility is using broadcast and a
	 * broadcast message is on the network.
	 *
	 * @return
	 * @throws Exception
	 */
	@Override
	public boolean canStartStopCE(Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		boolean canStartStopCE = true;

		// Are we using broadcast?
		if (isCCBroadcast(TenantContext.getCurrentTenant()))
		{
			// Do not allow DRLC start/stop if we cannot publish
			if (!controlEventBroadcastBean.canBroadcast())
			{
				canStartStopCE = false;
			}
		}

		return canStartStopCE;
	}

	/**
	 * Get a property
	 *
	 * @return
	 * @throws Exception
	 */

	@Override
	public boolean isCCBroadcast(Integer tenantId)
	{
		boolean isCCBroadcast = false;
		TenantContext.setCurrentTenant(tenantId);
		List<UtilityProperty> returnedProperties = genericFacade.getUtilityPropertyByKey(OpsCenterConstants.UTILITY_COMMAND_CENTER_USE_BROACAST);
		if (returnedProperties != null && returnedProperties.size() > 0)
		{
			if (returnedProperties.size() == 1)
			{
				UtilityProperty property = returnedProperties.get(0);
				String value = property.getValue();
				if (value.equalsIgnoreCase(OpsCenterConstants.TRUE))
				{
					isCCBroadcast = true;
				}
			}
			// More than one instance is an error
			else
			{
				logger.error("Multiple broadcast properties in DB for key " + OpsCenterConstants.UTILITY_COMMAND_CENTER_USE_BROACAST);
			}
		}
		// No property defaults to broadcast not used.
		else
		{
			logger.debug("No broadcast property in DB for key " + OpsCenterConstants.UTILITY_COMMAND_CENTER_USE_BROACAST);
		}

		return isCCBroadcast;
	}

	@Override
	public List<ControlEventBroadCastWindow> getFutureCyclingCeWindow(Integer tenantId)
	{
		logger.debug("[ENTER] getFutureCyclingCeWindow()");
		TenantContext.setCurrentTenant(tenantId);
		List<ControlEventBroadCastWindow> ceWindowList = null;
		List<ControlEventBroadCastWindow> newCeWindowList = new ArrayList<ControlEventBroadCastWindow>();
		ceWindowList = controlEventBeanFacade.getFutureCyclingCeWindow();
		for (ControlEventBroadCastWindow ceWindow : ceWindowList)
		{
			ControlEventBroadCastWindow newCeWindow = new ControlEventBroadCastWindow();
			newCeWindow.setCeId(ceWindow.getCeId());
			newCeWindow.setCeName(ceWindow.getCeName());
			newCeWindow.setCeStartTime(ceWindow.getCeStartTime());
			newCeWindow.setCeEndTime(ceWindow.getCeEndTime());
			newCeWindowList.add(newCeWindow);
			logger.debug(newCeWindow.toString());
		}
		logger.debug("[EXIT] getFutureCyclingCeWindow()");
		return newCeWindowList;
	}

	private void addCeAccountMapOnly(int ceId, List<Integer> esiList, Map<Integer, CeAccountMapModel> esiToAcctMapModel)
	{
		ControlEvent ce = controlEventBeanFacade.findControlEventByControlEventId(ceId);

		for (int esiId : esiList)
		{
			CeAccountMap ceAccMap = new CeAccountMap();
			CeAccountMapModel ceAccMapModel = esiToAcctMapModel.get(esiId);

			Account account = userAccBeanFacade.getRefAccountByAccountId(ceAccMapModel.getAccountId());

			CeGroup ceGrp = controlEventBeanFacade.getRefCeGroupByCeGroupId(ceAccMapModel.getCeGroupId());
			ceAccMap.setCeGroupId(ceGrp);
			ceAccMap.setAccountId(account);
			ceAccMap.setInitialPowerRemovable(ceAccMapModel.getInitialPowerRemovable());
			ceAccMap.setPowerConsumed(ceAccMapModel.getPowerConsumed());
			ceAccMap.setPowerToRemove(ceAccMapModel.getPowerToRemove());
			// If this account was added at the start of the CE then this value
			// must
			// equal the CE start time
			ceAccMap.setStartTime(ceAccMapModel.getStartTime());
			ceAccMap.setStopTime(ceAccMapModel.getStopTime());
			ceAccMap.setUserId(userAccBeanFacade.getRefUserByUserId(ceAccMapModel.getUserId()));
			ceAccMap.setControlEventId(ce);
			ceAccMap.setOptOutFlag(ceAccMapModel.getOptOutFlag());
			ceAccMap.setMissingReadsFlag(OpsCenterConstants.FALSE);
			ceAccMap.setGuiOptOutFlag(OpsCenterConstants.FALSE);
			ceAccMap.setTstatOptOutFlag(OpsCenterConstants.FALSE);
			ceAccMap.setReleasedFlag(OpsCenterConstants.FALSE);
			ceAccMap.setOutOfSyncFlag(OpsCenterConstants.FALSE);
			ceAccMap.setDoNotManageFlag(OpsCenterConstants.FALSE);
			ceAccMap.setLostCommsFlag(OpsCenterConstants.FALSE);
			ceAccMap.setRejectedCeStartRequest(OpsCenterConstants.FALSE);
			ceAccMap.setDutyCycle(ceAccMapModel.getDutyCycle());
			controlEventBeanFacade.createCeAccountMap(ceAccMap);

			// now update CeAccountMapCache
			cacheManager.updateCEAccountMapCache(ceAccMap, ceAccMapModel.getCeGroupMapId(), esiId, ce);

			// Update esiCache with CeAccountMapId
			int ceAccMapId = ceAccMap.getCeAccountMapId();

			logger.debug("Added ceAccMapId=" + ceAccMapId + " to database and cache for ceId=" + ceId);

			ceAccMapModel.setCeAccountMapId(ceAccMapId);

			// now do a put to push cache update to far cache
			String cacheKey = ceAccMapModel.getEsiCacheKey();
			Element esiElement = cacheManager.getGwEsiCache().get(cacheKey);
			EsiCacheData esiCacheData = (EsiCacheData) esiElement.getObjectValue();
			esiCacheData.setCeAccountMapId(ceAccMap.getCeAccountMapId());
			cacheManager.getGwEsiCache().put(esiElement);

		}

		ControlEvent cevent = controlEventBeanFacade.getRefControlEventByControlEventId(ceId);
		for (int esiId : esiList)
		{
			addEsiCELog(esiId, cevent);

		}
		controlEventBeanFacade.flush();

	}

	@Override
	public int updateCeDevicesRampoutEndTimeById(Integer ceDeviceId, DateTime stopTime)
	{
		logger.info("[ENTER] ControlEventPowerBean.updateCeDevicesRampoutEndTimeById() for ceDeviceId : " + ceDeviceId);
		int count = 0;
		count = controlEventBeanFacade.updateCeDevicesRampoutEndTimeById(ceDeviceId, stopTime);
		logger.info("[EXIT] ControlEventPowerBean.updateCeDevicesRampoutEndTimeById() with update count " + count);
		return count;
	}

	@Override
	public int updateCeGroupCeTotalTimeByGrpId(Integer grpId, Integer minutes)
	{
		logger.debug("[ENTER] ControlEventPowerBean.updateCeGroupCeTotalTimeByGrpId() for grpId : " + grpId);
		int count = 0;
		count = controlEventBeanFacade.updateCeGroupCeTotalTimeByGrpId(grpId, minutes);
		logger.debug("[EXIT] ControlEventPowerBean.updateCeGroupCeTotalTimeByGrpId() with update count " + count);
		return count;
	}

	private Map<Integer, GroupPowerDeviceData> collectAutoCeGrpPower(String today, double powerToRemove, List<String> devClassList, Integer scadaReferenceId)
	{

		logger.info("[ENTER] collectAutoCeGrpPower");

		List<CeDayGroupModel> grpIdList = autoControlBean.getPrioritizedCeGroupsOfDay(today, scadaReferenceId);

		logger.debug("size of day_grp_list" + grpIdList.size());

		Map<Integer, GroupPowerDeviceData> grpPowerMap = new HashMap<Integer, GroupPowerDeviceData>();

		// first determine how much power grp is currently consuming
		double powerRequested = new Double(powerToRemove).doubleValue();

		logger.debug("power to remove after conversion =  " + powerRequested);

		boolean doneAdding = false;
		double totalPower = 0;

		for (CeDayGroupModel grp : grpIdList)
		{

			boolean grpInCe = false;
			Results results = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpCache(), grp.getCeGroupId());
			CEGroupCacheData ceGroupCache = null;
			for (Result result : results.all())
			{
				ceGroupCache = (CEGroupCacheData) result.getValue();
				grpInCe = (OpsCenterConstants.TRUE.equals(ceGroupCache.getAutoCeAdded()) || ceGroupCache.getCeId() != 0);

			}
			if (grpInCe)
			{
				logger.debug("grp is already in CE-skipping, grpId  = " + grp.getCeGroupId());
				continue;
			}

			Results ceGrpPowerResults = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpPowerCache(), grp.getCeGroupId());

			for (Result result : ceGrpPowerResults.all())
			{
				CEGroupPowerCacheData grpCache = (CEGroupPowerCacheData) result.getValue();
				String devType = grpCache.getDevType();
				boolean add;
				totalPower = totalPower + grpCache.getProjPowerAvailable();
				add = false;
				if (OpsCenterConstants.DC_HVAC.equals(devType) && devClassList.contains(OpsCenterConstants.DC_HVAC))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_WATER_HEATER.equals(devType) && devClassList.contains(OpsCenterConstants.DC_WATER_HEATER))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_POOL_PUMP.equals(devType) && devClassList.contains(OpsCenterConstants.DC_POOL_PUMP))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_HVAC_SWITCH.equals(devType) && devClassList.contains(OpsCenterConstants.DC_HVAC_SWITCH))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_SINGLE_HEAT.equals(devType) && devClassList.contains(OpsCenterConstants.DC_SINGLE_HEAT))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_DUAL_HEAT.equals(devType) && devClassList.contains(OpsCenterConstants.DC_DUAL_HEAT))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_EV_CHARGER.equals(devType) && devClassList.contains(OpsCenterConstants.DC_EV_CHARGER))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_IRRIGATION_PUMP.equals(devType) && devClassList.contains(OpsCenterConstants.DC_IRRIGATION_PUMP))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_CROP_HEAT.equals(devType) && devClassList.contains(OpsCenterConstants.DC_CROP_HEAT))
				{
					add = true;
				}
				else if (OpsCenterConstants.DC_GENERATOR.equals(devType) && devClassList.contains(OpsCenterConstants.DC_GENERATOR))
				{
					add = true;
				}
				if (add)
				{

					GroupPowerDeviceData grpData = new GroupPowerDeviceData();
					// when grp has no power always add to CE or if we have
					// not met requested power, keep adding grps
					if (totalPower == 0.0 || totalPower < powerRequested)
					{
						grpData.setPowerAvail(grpCache.getProjPowerAvailable());
						grpData.setCeDef(grp.getCeDefnId());
						grpPowerMap.put(grp.getCeGroupId(), grpData);
						logger.debug("adding more grps, added grpId/ projPowerAvail " + grp.getCeGroupId() + "/" + grpCache.getProjPowerAvailable());
						break;
					}
					if (totalPower >= powerRequested)
					{
						// once we have met requested power, no more grps
						// needed, exit
						grpData.setPowerAvail(grpCache.getProjPowerAvailable());
						grpData.setCeDef(grp.getCeDefnId());
						grpPowerMap.put(grp.getCeGroupId(), grpData);
						logger.debug("done adding grps -grpId/ projPowerAvail " + grp.getCeGroupId() + "/" + grpCache.getProjPowerAvailable());
						doneAdding = true;
						break;
					}

				}

			}
			if (doneAdding)
			{
				logger.debug("met requested power, no more grps added ");
				break;
			}
		}
		logger.info("[EXIT] collectAutoCeGrpPower");

		// once power and devices are determined-- try and start/update the CE
		return grpPowerMap;

	}

	@Asynchronous
	public void startOrUpdateAutoCe(double powerToRemove, LocalTime startTime,
			LocalTime endTime, CEStart ceStart, Integer tenantId) {

		logger.info("[ENTER] startOrUpdateAutoCe");
		TenantContext.setCurrentTenant(tenantId);
		CeDefinitionModel ceDefModel = null;
		DateTime currTime = new DateTime();
		DateTimeZone tz = genericBean.getUtilityTimeZone();
		LocalDate localDate = new DateTime(tz).toLocalDate();
		LocalTime time = new DateTime(tz).toLocalTime();
		// Added for Multiscada changes ALM-17
		Integer iScadaReferenceId = ceStart.getIscadareferenceid();
		logger.debug("localTime/ dayOfWeek " + time + "/"
				+ localDate.getDayOfWeek());

		String today = OpsCenterConstants.jodaDayToCtrlDay.get(localDate
				.getDayOfWeek());

		Map<Integer, GroupPowerDeviceData> grpPowerMap = new HashMap<Integer, GroupPowerDeviceData>();
		List<GroupPowerModel> groupPowerList = new ArrayList<GroupPowerModel>();
		ArrayList<String> devClassList = new ArrayList<String>();

		Results ceResults = cacheManager.getCacheData(cacheManager
				.getControlEventCache());
		String update = OpsCenterConstants.FALSE;

		LinkedHashMap<String, String> targetDevices = new LinkedHashMap<String, String>();
		int ceId = 0;
		DateTime existingCeStopTime = null;

		for (Result ceResult : ceResults.all()) {
			ControlEventCacheData ceCache = (ControlEventCacheData) ceResult
					.getValue();
			// find the auto ce-- there could be manual CEs running as well
			// Added for Multiscada changes ALM-17
			if (null != iScadaReferenceId
					&& iScadaReferenceId.equals(ceCache.getiScadaReferenceID())) {
				update = OpsCenterConstants.TRUE.equals(ceCache.getAutoCe()) ? OpsCenterConstants.TRUE
						: OpsCenterConstants.FALSE;
				existingCeStopTime = ceCache.getStopTime();
			}
			ceId = ceCache.getCeId();
			if (OpsCenterConstants.TRUE.equals(update))
				break;
		}
		// Added for getting the DTMap from Multiscada Service
		List<AutoScadaConfigDT> autoScadaConfigDt = null;
		try {

			autoScadaConfigDt = ceStart.getAutoscadaconfigdtmap();
			if (null == autoScadaConfigDt || autoScadaConfigDt.isEmpty()) {
				logger.error("ControlEventPowerBean:startOrUpdateAutoCe DT Map is null");
				return;
			}
		} catch (Exception e) {
			logger.error("ControlEventPowerBean:startOrUpdateAutoCe Exception thrown in Getting the DT Map");
			return;
		}
		for (AutoScadaConfigDT auto : autoScadaConfigDt) {
			DeviceType deviceType = deviceBeanFacade
					.findDeviceTypeByDeviceTypeId(auto.getDtId());
			if (null == deviceType) {
				logger.error("ControlEventPowerBean:startOrUpdateAutoCe Device Type Not Found");
				return;
			}
			devClassList.add(deviceType.getDeviceTypeName());
		}
		grpPowerMap = collectAutoCeGrpPower(today, powerToRemove, devClassList, ceStart.getIscadareferenceid());
		
		//Calculate Duration
		LocalTime localTime = new DateTime(tz).toLocalTime();
		int duration = (endTime.getMillisOfDay() - localTime
				.getMillisOfDay()) / 1000 / 60;
		logger.debug("duration = " + duration);
		
		//Calculate CE Stop Time
		DateTime ceStopTime = currTime.plusMinutes(duration);
		
		logger.debug("Existing stop time : "+existingCeStopTime);
		logger.debug("Current stop time : "+ceStopTime);
		
		if(OpsCenterConstants.TRUE.equals(update) && existingCeStopTime != null && (existingCeStopTime.getMinuteOfDay() != ceStopTime.getMinuteOfDay())){
			logger.debug("CE Stop time have been modified. Continue to update CE with new CE stop time even if no group change is done..");
		}
		else if (grpPowerMap.isEmpty() || grpPowerMap.size() <= 0) {
			logger.warn("No assigned grps avail to add for new or running ce");
			return;
		}
		
		ControlEventStartModel ceModel = new ControlEventStartModel();
		Double power = new Double(powerToRemove).doubleValue();

		for (Integer grpId : grpPowerMap.keySet()) {

			GroupPowerModel grpPower = new GroupPowerModel();
			// TODO grpPower.setGroupType(groupType)??
			grpPower.setPowerToRemove(new Double(powerToRemove));
			grpPower.setGrpId(grpId);
			grpPower.setAlreadyInControl(OpsCenterConstants.FALSE);
			grpPower.setInitialPowerToRemove(power.doubleValue());
			ceModel.setCeDefinitionId(grpPowerMap.get(grpId).getCeDef());
			try {
				if (ceDefModel == null
						&& OpsCenterConstants.FALSE.equals(update)) {
					ceDefModel = ceDefinitionBean
							.retrieveDefinitionById(ceModel.getCeDefinitionId()
									.intValue(), TenantContext.getCurrentTenant());
				} else if (ceDefModel == null
						&& OpsCenterConstants.TRUE.equals(update)) {
					// RDRN-598 Change CeDefinition for the ControlDay in
					// AutoCESettings will be valid to next CE but not current
					// running CE.
					// Current running CE use same CeDefinition on which CE is
					// started.
					ceDefModel = ceDefinitionBean
							.retrieveDefinitionByCeId(ceId, TenantContext.getCurrentTenant());
				}
			} catch (AbstractOpsCenterException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			grpPower.setDutyCycle(ceDefModel.getDutyPercentage());
			logger.debug("defId / grpId = "
					+ ceModel.getCeDefinitionId().intValue() + "/" + grpId);

			groupPowerList.add(grpPower);
		}
		AutoControlEventModel autoModel = null;
		List<User> usr = userAccBeanFacade.getUserByUsername("admin_prov");
		if (OpsCenterConstants.FALSE.equals(update)) {
			
			// RDRN-587 minimum duration of new AUTO CE is 30 minutes.
			if (30 > duration) {
				duration = 30;
			}
			
			// ALm-156 : Implementing staggering logic of Auto CE
			DateTime ceStartTime = null;
			DateTime existingCEStartTime = null;
			//find the existingCEStartTime which is equal to current Auto CE start time
			for (Result ceResult : ceResults.all()) {
				ControlEventCacheData ceCache = (ControlEventCacheData) ceResult
						.getValue();
				if(OpsCenterConstants.TRUE.equals(ceCache.getAutoCe())) {
					if(currTime == ceCache.getStartTime()) {
						//if any running Auto CE have the same start time as current Auto CE to be started
						existingCEStartTime = ceCache.getStartTime();
						break;
					} else {
						// if not, find the CE start time of latest running Auto CE
						if(existingCEStartTime == null || ceCache.getStartTime().isAfter(existingCEStartTime)) {
							existingCEStartTime = ceCache.getStartTime();
						} 
					}
				}
			}
			if(existingCEStartTime != null) {
				logger.debug("Already another Auto CE running with start time : "+existingCEStartTime);
				if((currTime.getSecondOfDay()-existingCEStartTime.getSecondOfDay()) <= ceStart.getStaggeringtime()) {
					ceStartTime = currTime.plusSeconds(ceStart.getStaggeringtime());
				} else {
					ceStartTime = currTime;
				}
			} else {
				logger.debug("No Auto CE is running. Start Auto CE with the current time");
				ceStartTime = currTime;
			}

			autoModel = ceStart.getAutocontrolevent();
			ceModel.setDuration(duration);
			ceModel.setPowerRequestedInPercent(OpsCenterConstants.FALSE);
			ceModel.setStartDate(ceStartTime);
			ceModel.setMode(OpsCenterConstants.eventMode.CYCLING);
			ceModel.setTotalPowerToRemove(powerToRemove);
			if(ceStart.getUsePrimaryScadaConfig()) {
				ceModel.setCriticalCE(autoModel.getEventType().equalsIgnoreCase(
					"Critical") ? OpsCenterConstants.TRUE
					: OpsCenterConstants.FALSE);
			} else {
				ceModel.setCriticalCE(autoModel.getEventType2().equalsIgnoreCase(
						"Critical") ? OpsCenterConstants.TRUE
						: OpsCenterConstants.FALSE);
			}
			ceModel.setAutoCe(OpsCenterConstants.TRUE);
			// Setting Scada Reference ID
			ceModel.setiScadaReferenceId(iScadaReferenceId);
			ceModel.setGroupPowerList(groupPowerList);
			ceModel.setName("ControlEvent");
			if (usr.size() <= 0) {
				logger.error("No admin_prov user in DB, cannot start DB");
				return;
			}
			ceModel.setUserId(usr.get(0).getUserId());
			for (String devName : devClassList) {
				String devType = OpsCenterConstants.DeviceType.fromValue(
						devName).getCeValue();
				targetDevices.put(devType, OpsCenterConstants.TRUE);
				logger.debug("adding devType = " + devType);

			}

			ceModel.setTargetDeviceTypeIDs(targetDevices);
			ceModel.setDutyCycle(OpsCenterConstants.dutyCycle.GROUP);
			if (ceDefModel.getDutyPercentage() == OpsCenterConstants.DUTY_CYCLE_BY_DEVICE_TYPE_DUTY_PERCENTAGE) {
				ceModel.setDutyCycle(OpsCenterConstants.dutyCycle.DEVICE);
				ceModel.setDutyCycleByDeviceType(ceDefinitionBean
						.getDutyCycleByCeDefId(ceDefModel.getDefinitionId(),
								targetDevices));

			}
			try {
				startControlEvent(ceModel, tenantId);
				updateGrpInCeCache(ceModel.getGroupPowerList());
			} catch (AbstractOpsCenterException e) {
				// TODO Auto-generated catch block
				logger.error("StartControlEvent Exception " + e.getMessage());
			}
		} else {
			logger.debug("updating an existing CE ");
			if (ceId == 0) {
				logger.error("update CE requires a running CE, no grp addition occurred");
				return;
			}
			try{
				if (ceDefModel == null) {
					logger.debug("Fetching CE definition for the existing running CE for CE id : "+ceId);
					ceDefModel = ceDefinitionBean.retrieveDefinitionByCeId(ceId, TenantContext.getCurrentTenant());
					logger.debug("Definition id fetched : " + ceDefModel.getDefinitionId());
				}
			} catch (AbstractOpsCenterException e1) {
				logger.error("Error occured while fetching the CE definition");
			}

			ControlEventEditModel editModel = new ControlEventEditModel();
			editModel.setCeId(ceId);
			editModel.setGroupPowerList(groupPowerList);
			editModel.setTargetDeviceTypeIDs(targetDevices);
			editModel.setAdditionalPowerToRemoveTotal(power.doubleValue());
			editModel.setPowerRequestedInPercent(OpsCenterConstants.FALSE);
			editModel.setCeDefinitionId(ceDefModel.getDefinitionId());
			editModel.setMode(OpsCenterConstants.eventMode.CYCLING);
			editModel.setStopDate(ceStopTime);
			editModel.setOrigStopDate(existingCeStopTime);

			for (String devName : devClassList) {
				String devType = OpsCenterConstants.DeviceType.fromValue(
						devName).getCeValue();
				targetDevices.put(devType, OpsCenterConstants.TRUE);
			}

			editModel.setTargetDeviceTypeIDs(targetDevices);
			editModel.setDutyCycle(OpsCenterConstants.dutyCycle.GROUP);
			if (ceDefModel.getDutyPercentage() == OpsCenterConstants.DUTY_CYCLE_BY_DEVICE_TYPE_DUTY_PERCENTAGE) {
				editModel.setDutyCycle(OpsCenterConstants.dutyCycle.DEVICE);
				editModel.setDutyCycleByDeviceType(ceDefinitionBean
						.getDutyCycleByCeDefId(ceDefModel.getDefinitionId(),
								targetDevices));

			}

			for (GroupPowerModel grp : groupPowerList) {

				Results groupCacheMapsForGroup = cacheManager
						.getCacheDataByCeGrpId(cacheManager.getCeGrpMapCache(),
								grp.getGrpId());
				for (Result result : groupCacheMapsForGroup.all()) {
					CEGroupMapCacheData grpCacheMapData = (CEGroupMapCacheData) result
							.getValue();
					grp.setInitialPowerToRemove(grpCacheMapData
							.getIntialPowerToRemoveable());
					grp.setAdditionalPowerToRemove(power.doubleValue());

				}

			}
			editModel.setGroupPowerList(groupPowerList);

			if (usr.size() <= 0) {
				logger.error("No admin_prov user in DB, cannot start DB");
				return;
			}
			editModel.setUserId(usr.get(0).getUserId());
			try {
				editControlEventIncreasePowerToRemove(editModel);
				updateGrpInCeCache(editModel.getGroupPowerList());

			} catch (AbstractOpsCenterException e) {
				// TODO Auto-generated catch block
				logger.error("Could not update running Auto CE"
						+ e.getMessage());
				e.printStackTrace();
			}

		}
		logger.info("[EXIT] startOrUpdateAutoCe");

	}

	private void updateGrpInCeCache(List<GroupPowerModel> groupPowerList)
	{

		for (GroupPowerModel grp : groupPowerList)
		{

			Results results = cacheManager.getCacheDataByCeGrpId(cacheManager.getCeGrpCache(), grp.getGrpId());
			CEGroupCacheData ceGroupCache = null;
			for (Result result : results.all())
			{
				ceGroupCache = (CEGroupCacheData) result.getValue();
				ceGroupCache.setAutoCeAdded(OpsCenterConstants.TRUE);
				Element grpElement = new Element(grp.getGrpId(), ceGroupCache);
				cacheManager.getCeGrpCache().put(grpElement);
			}

		}
	}

	@Override
	public RemoveGroupFromCeResponse removeGrpFromCeForScadaReferenceId(Integer scadaReferenceId) throws AbstractOpsCenterException {

		logger.debug("[Enter] ControlEventPowerBean removeGrpFromCeForScadaReferenceId: scadaReferenceId = "+scadaReferenceId);
		List<GroupPowerModel> groupPowerModelList = new ArrayList<>();
		Results ceResults = cacheManager.getCacheData(cacheManager.getControlEventCache());
		int ceId = 0;
		for (Result ceResult : ceResults.all()) {
			ControlEventCacheData ceCache = (ControlEventCacheData) ceResult.getValue();
			logger.debug("inside for loop,scada ref = : " +ceCache.getiScadaReferenceID());

			if (scadaReferenceId.intValue() == ceCache.getiScadaReferenceID().intValue()) {
				ceId = ceCache.getCeId();
				break;
			}
		}
		
		if(ceId == 0) {
			logger.error("No CE running for Scada Reeference Id : " +scadaReferenceId);
			return null;
		}
		logger.debug("CE Definition Id for the scadareference id : "+ceId);
		
		Results grpMapResults = cacheManager.getCacheDataControlEventId(cacheManager.getCeGrpMapCache(), ceId);
		for (Result grpMap : grpMapResults.all()) {
			GroupPowerModel model = new GroupPowerModel();
			CEGroupMapCacheData ceGrpMapCache = (CEGroupMapCacheData) grpMap.getValue();

			model.setGrpId(ceGrpMapCache.getCeGrpId());
			model.setCeId(ceId);
			
			groupPowerModelList.add(model);
		}

		logger.debug("groupPowerModelList --> "+groupPowerModelList);
		RemoveGroupFromCeResponse response = removeGrpFromCe(groupPowerModelList, TenantContext.getCurrentTenant());
		logger.debug("[Exit] ControlEventPowerBean removeGrpFromCeForScadaReferenceId");
		return response;
	}
	
	
	/*
	 * This method will opt-out all GS devices in requested grp that is in ctrl
	 * for passed in CE id all devices will get a DRLC cancel message
	 */
	@Override
	public RemoveGroupFromCeResponse removeGrpFromCe(List<GroupPowerModel> grpList, Integer tenantId) throws AbstractOpsCenterException
	{
		logger.info("[ENTER] removeGrpFromCe");
		TenantContext.setCurrentTenant(tenantId);
		List<EsiDcCacheData> dcList = new ArrayList<EsiDcCacheData>();
		List<CEAccountMapCacheData> ceAccMapList = new ArrayList<CEAccountMapCacheData>();
		List<Integer> updatedGrpIds = new ArrayList<Integer>();

		RemoveGroupFromCeResponse serviceResponse = new RemoveGroupFromCeResponse();
		List<GroupPowerModel> failedGroupList = serviceResponse.getFailedGroupList();
		List<GroupPowerModel> succesfulGroupList = serviceResponse.getSuccesfulGroupList();

		Integer ceId = 0;

		for (GroupPowerModel grp : grpList)
		{

			List<Integer> esiIdList = new ArrayList<Integer>();
			EsiDcCacheData dcCache = null;
			List<Esi> esiList = esiBeanFacade.getEsiByGroupId(grp.getGrpId());
			for (Esi esi : esiList)
			{
				esiIdList.add(esi.getEsiId());
			}
			ceId = grp.getCeId();
			Results results = cacheManager.getCacheDataByCeIdAndMode(cacheManager.getGwDCCache(), ceId, esiIdList);
			if (results.size() <= 0)
			{
				logger.error("no devices in control mode for GrpId= " + grp.getGrpId());
				failedGroupList.add(grp);

			}
			else
			{
				updatedGrpIds.add(grp.getGrpId());
				succesfulGroupList.add(grp);
			}
			for (Result result : results.all())
			{
				dcCache = (EsiDcCacheData) result.getValue();

				// only opt out this DC if not already UtilityReleased
				if (OpsCenterConstants.OptOutReason.UTILITY_RELEASED != dcCache.getOptOutReason())
				{

					CEAccountMapCacheData accMapCache = null;
					dcList.add(dcCache);
					logger.debug("opting out dcId = " + dcCache.getEsiDcId());

					Results accMapResults = cacheManager.getCacheDataByCeAccId(cacheManager.getCeAccMapCache(), dcCache.getAccountId());
					for (Result accMap : accMapResults.all())
					{
						accMapCache = (CEAccountMapCacheData) accMap.getValue();
						// must now save the data for opt-out reason
						dcCache.setOptOutReason(OpsCenterConstants.OptOutReason.UTILITY_RELEASED);

						Element element = new Element(dcCache.getCacheKey(), dcCache);
						cacheManager.getGwDCCache().put(element);
						ceAccMapList.add(accMapCache);
					}
				}

			}
		}
		if (grpList.size() <= 0)
		{
			logger.error("No grps received in request, no GRPs can be released, exiting");
			return serviceResponse;
		}
		if (dcList.size() > 0 && ceAccMapList.size() > 0)
		{
			optOutGSDeviceFromCE(dcList, ceAccMapList);
			logger.debug("just opted Out all devices");
		}

		// Get CEGroupMapCacheData and setUtilityReleased = 1
		List<CEGroupMapCacheData> ceGroupMapCacheList = getCeGroupMapsByCe(ceId);
		for (CEGroupMapCacheData ceGroupMapCache : ceGroupMapCacheList)
		{
			for (Integer updatedGrpId : updatedGrpIds)
			{
				if (updatedGrpId == ceGroupMapCache.getCeGrpId())
				{
					ceGroupMapCache.setUtilityReleased(OpsCenterConstants.TRUE);

					Element element = new Element(ceGroupMapCache.getCeGrpMapId(), ceGroupMapCache);
					cacheManager.getCeGrpMapCache().put(element);
				}
			}
		}

		// Update the utility released flag in the ce_grp_map table.
		if (0 < updatedGrpIds.size())
		{
			// flush the total power available so that the ce details can be
			// refreshed with the latest group information.
			totalPowerAvailMap.put(tenantId, null);
			controlEventBeanFacade.updateCeGroupMapUtilityReleasedByGrpIds(updatedGrpIds, ceId, OpsCenterConstants.TRUE);
		}

		logger.info("[EXIT] removeGrpFromCe");

		return serviceResponse;
	}

	@Override
	public void calculateTotalTimeInCe(Integer ceGrpId)
	{

		logger.info("[ENTER] calculateTotalTimeInCe(Integer ceGrpId): " + ceGrpId);

		Results grpResults = cacheManager.getCacheDataByCeIdNotNull(cacheManager.getCeGrpCache());
		CEGroupCacheData ceGroupCacheData = null;
		for (Result grpResult : grpResults.all())
		{
			CEGroupCacheData tempCeGroupCache = (CEGroupCacheData) grpResult.getValue();
			if (ceGrpId.equals(tempCeGroupCache.getCeGrpId()))
			{
				ceGroupCacheData = tempCeGroupCache;
				break;
			}
		}

		if (ceGroupCacheData == null)
		{
			logger.info("ceGrpId : " + ceGrpId + " -> ceGroupCacheData is null.");
		}
		else if (ceGroupCacheData.isCeTotalMinsCalculated())
		{
			logger.info("ceGrpId : " + ceGrpId + " -> Total time already calculated.");
		}

		if (ceGroupCacheData != null && !ceGroupCacheData.isCeTotalMinsCalculated())
		{
			int timeInCE = 0;
			boolean isCycling = false;
			boolean isCEManualStop = false;

			int ceId = ceGroupCacheData.getCeId();
			long ceStartTime = ceGroupCacheData.getCeStartTime();
			logger.info("ceStartTime : " + ceStartTime);

			DateTime stopTimeDt = null;
			Element ceElement = cacheManager.getControlEventCache().get(ceId);
			if (ceElement != null)
			{
				ControlEventCacheData ceCache = (ControlEventCacheData) ceElement.getObjectValue();
				stopTimeDt = ceCache.getStopTime();
				if (OpsCenterConstants.eventMode.CYCLING == ceCache.getMode())
				{
					isCycling = true;
				}
			}

			long endTime = new DateTime().getMillis();
			int remainingTime = 0;

			long stopTime = stopTimeDt != null ? stopTimeDt.getMillis() : 0L;
			if ((stopTime - endTime) > 0)
			{
				isCEManualStop = true;
				remainingTime = (int) (Math.round(((stopTime - endTime) / MINUTE_CONVERSION)));
			}

			if (isCycling)
			{ // Cyclic CE
				CeDefinition ceDefinition = controlEventBean.getCeDefinitionForCe(ceId);

				CeDefinitionModel ceDefinitionModel = null;
				try
				{
					ceDefinitionModel = ceDefinitionBean.retrieveDefinitionById(ceDefinition.getDefinitionId(), TenantContext.getCurrentTenant());
				} catch (AbstractOpsCenterException e1)
				{
					logger.error("Could not retrieve CE definition by CE Id " + e1.getMessage());
					e1.printStackTrace();
				}

				List<Integer> deviceTypeIdList = controlEventBeanFacade.getDeviceTypeListByCeGroupId(ceGrpId);

				if (ceDefinitionModel.getDutyPercentage() != OpsCenterConstants.DUTY_CYCLE_BY_DEVICE_TYPE_DUTY_PERCENTAGE)
				{ // By group
					int grpRampOutWindow = ceDefinitionModel.getRampOutWindow();
					if (isCEManualStop)
					{
						if (remainingTime > 5)
						{ // CE manually stopped well before the last 5 minutes
							// window
							// Check if the ramp-out is immediate or not
							if (grpRampOutWindow > 0)
							{ // Not immediate
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + MANUAL_BUFFER_RAMPOUT);
							}
							else
							{ // Immediate - no ramp-out
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)));
							}
						}
						else
						{ // CE manually stopped within the last 5 minutes
							// window
							// Check if the ramp-out is immediate or not
							if (grpRampOutWindow > 0)
							{ // Not immediate
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + grpRampOutWindow);
							}
							else
							{ // Immediate - no ramp-out
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)));
							}
						}
						logger.info("CE by group - manual stop, endTime: " + endTime + ", timeInCE: " + timeInCE + ", grpRampOutWindow: " + grpRampOutWindow
								+ ", remainingTime: " + remainingTime);
					}
					else
					{ // Graceful end
						timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + grpRampOutWindow);
						logger.info("CE by group - gracefully ended, endTime: " + endTime + ", timeInCE: " + timeInCE + ", grpRampOutWindow: "
								+ grpRampOutWindow);
					}

				}
				else
				{ // By device type
					Cache esiDcCache = cacheManager.getGwDCCache();
					Results dcResults = cacheManager.getCacheData(esiDcCache);
					List<EsiDcCacheData> esiDcCacheDataList = new ArrayList<EsiDcCacheData>();
					for (Result dcResult : dcResults.all())
					{
						EsiDcCacheData esiDcCacheData = (EsiDcCacheData) dcResult.getValue();
						if (ceId == esiDcCacheData.getCeId() && esiDcCacheData.getGrpIdList().contains(ceGrpId))
						{
							esiDcCacheDataList.add(esiDcCacheData);
						}
					}

					int maxRampOutWindow = 0;
					List<CeCycleStrategyModel> ceCycleStrategyModelList = ceDefinitionModel.getIncludedRoutStrategys();
					if (ceCycleStrategyModelList != null && ceCycleStrategyModelList.size() > 0)
					{
						for (CeCycleStrategyModel ceCycleStrategyModel : ceCycleStrategyModelList)
						{
							int rampoutWindow = ceCycleStrategyModel.getRampOutWindow();
							if (deviceTypeIdList != null && deviceTypeIdList.size() > 0)
							{
								int deviceTypeId = ceCycleStrategyModel.getDeviceTypeId() == 19 ? 0 : ceCycleStrategyModel.getDeviceTypeId();

								// Check that the device has not opted out
								if (isDeviceTypeInGroup(esiDcCacheDataList, deviceTypeId))
								{
									if (deviceTypeIdList.contains(deviceTypeId) && rampoutWindow > maxRampOutWindow)
									{
										maxRampOutWindow = rampoutWindow;
									}
								}
							}
						}
					}
					if (isCEManualStop)
					{
						if (remainingTime > 5)
						{ // CE manually stopped well before the last 5 minutes
							// window
							// Check if the ramp-out is immediate or not
							if (maxRampOutWindow > 0)
							{ // Not immediate
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + MANUAL_BUFFER_RAMPOUT);
							}
							else
							{ // Immediate - no ramp-out
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)));
							}
						}
						else
						{ // CE manually stopped within the last 5 minutes
							// window
							// Check if the ramp-out is immediate or not
							if (maxRampOutWindow > 0)
							{ // Not immediate
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + maxRampOutWindow);
							}
							else
							{ // Immediate - no ramp-out
								timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)));
							}
						}
						logger.info("CE by device - manual stop, endTime: " + endTime + ", timeInCE: " + timeInCE + ", maxRampOutWindow: " + maxRampOutWindow
								+ ", remainingTime: " + remainingTime);
					}
					else
					{ // Graceful end
						timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + maxRampOutWindow);
						logger.info("CE by device type, endTime: " + endTime + ", timeInCE: " + timeInCE + ", maxRampOutWindow: " + maxRampOutWindow);
					}
				}
			}
			else
			{ // VPP CE
				if (isCEManualStop)
				{
					if (remainingTime > 5)
					{ // CE manually stopped well before the last 5 minutes
						// window
						timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + MANUAL_BUFFER_RAMPOUT);
					}
					else
					{ // CE manually stopped within the last 5 minutes window
						timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + BUFFER_SP_STOP_TIME);
					}
					logger.info("VPP CE - manual stop, endTime: " + endTime + ", timeInCE: " + timeInCE + ", remainingTime: " + remainingTime);
				}
				else
				{ // Graceful end
					timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)) + BUFFER_SP_STOP_TIME);
					logger.info("VPP CE. Adding " + BUFFER_SP_STOP_TIME + " as buffer, endTime: " + endTime + ", timeInCE: " + timeInCE);
				}
			}

			updateCeGroupCeTotalTimeByGrpId(ceGrpId, timeInCE);
			ceGroupCacheData.setOptOutDeviceCounter(0);
			ceGroupCacheData.setCeStartTime(0);
			logger.info("Finally calculated for ceGrpId: " + ceGrpId + ", timeInCE: " + timeInCE);
		}
		else
		{
			logger.info("ceGrpId: " + ceGrpId + " not in getCacheDataByCeIdNotNull or total time already calculated while last device opted out");
		}
		logger.info("[EXIT] calculateTotalTimeInCe(Integer ceGrpId): " + ceGrpId);
	}

	/*
	 * Checks if the device in the group is still active and has not opted out
	 */
	private boolean isDeviceTypeInGroup(List<EsiDcCacheData> esiDcCacheDataList, int deviceTypeId)
	{
		boolean isDeviceInGrp = false;
		String devType = OpsCenterConstants.DeviceType.fromId(deviceTypeId).getValue();
		logger.info("Enter isDeviceTypeInGroup, devType: " + devType);

		for (EsiDcCacheData esiDcCacheData : esiDcCacheDataList)
		{
			String tempDeviceType = esiDcCacheData.getDeviceType();
			if (!tempDeviceType.isEmpty() && tempDeviceType.equals(devType) && OpsCenterConstants.FALSE.equals(esiDcCacheData.getOptOutFlag()))
			{
				isDeviceInGrp = true;
				break;
			}
		}
		logger.info("Exit isDeviceTypeInGroup, deviceTypeId: " + deviceTypeId + ", isDeviceInGrp: " + isDeviceInGrp);
		return isDeviceInGrp;
	}

	public void calculateTimeInCeForOptOut(Integer ceGrpId)
	{
		logger.info("[ENTER] calculateTimeInCeForOptOut(Integer ceGrpId): " + ceGrpId);

		Results grpResults = cacheManager.getCacheDataByCeIdNotNull(cacheManager.getCeGrpCache());
		CEGroupCacheData ceGroupCacheData = null;
		for (Result grpResult : grpResults.all())
		{
			CEGroupCacheData tempCeGroupCache = (CEGroupCacheData) grpResult.getValue();
			if (ceGrpId.equals(tempCeGroupCache.getCeGrpId()))
			{
				ceGroupCacheData = tempCeGroupCache;
				break;
			}
		}

		if (ceGroupCacheData != null)
		{
			int timeInCE = 0;
			long ceStartTime = ceGroupCacheData.getCeStartTime();
			long endTime = new DateTime().getMillis();

			timeInCE = (int) (Math.round(((endTime - ceStartTime) / MINUTE_CONVERSION)));

			updateCeGroupCeTotalTimeByGrpId(ceGrpId, timeInCE);
			ceGroupCacheData.setOptOutDeviceCounter(0);
			ceGroupCacheData.setCeStartTime(0);
			logger.info("calculateTimeInCeForOptOut method -- ceGrpId: " + ceGrpId + "ceStartTime : " + ceStartTime + ", endTime: " + endTime + ", timeInCE: "
					+ timeInCE);
			// KGFR-73 must do a put to ensure other server sees update
			Element grpElement = new Element(ceGroupCacheData.getCeGrpId(), ceGroupCacheData);
			cacheManager.getCeGrpCache().put(grpElement);

		}
		else
		{
			logger.info("ceGrpId: " + ceGrpId + " not in getCacheDataByCeIdNotNull");
		}
		logger.info("[EXIT] calculateTimeInCeForOptOut(Integer ceGrpId): " + ceGrpId);
	}
	
	/**
	 * Method for clearing the Device Cache
	 * @param EsiDcCacheData
	 *
	 */
	
	@Override
	public void clearDeviceFromCE(EsiDcCacheData dcCache)
			throws AbstractOpsCenterException {
		logger.info("[ENTER] void ControlEventPowerBean.clearDeviceFromCE"
				+ "The AccountId" + dcCache.getAccountId() + "The ESIDCID is"
				+ dcCache.getEsiDcId() + "The CEID is" + dcCache.getCeId());
		if(dcCache.getCeId()<=0 || dcCache.getEsiDcId()<=0 || dcCache.getAccountId()<=0)
		{
			logger.error("ControlEventPowerBean.clearDeviceFromCE The CEID or DCID or AccountID is not valid");
			return;
		}
		int activeDevicesLeftForThisAccount = 0;
		/*
		 * First thing to do is to check to see if this is the last active
		 * device in the event for this account.
		 * 
		 * If so, clear whole account cache
		 */
		try
		{
		activeDevicesLeftForThisAccount = getActiveDevicesLeftForAccount(
				dcCache.getAccountId(), dcCache.getCeId());
		if(activeDevicesLeftForThisAccount==0)
		{
			logger.error("ControlEventPowerBean.clearDeviceFromCE There is  no active device in this account");
			return;
		}
		CeEsiStatus stoppedCeEsiStatusId = entityManager.getReference(
				CeEsiStatus.class,
				OpsCenterConstants.ceEsiStatusNameToCeEsiStatusID.get(
						OpsCenterConstants.STOPPED));
		ControlEvent refControlEvent = controlEventBeanFacade
				.getRefControlEventByControlEventId(dcCache.getCeId());
		DateTime currTime = new DateTime();
		CEAccountMapCacheData accMapCache = null;
		Results accMapResults = cacheManager.getCacheDataByCeAccId(
				cacheManager.getCeAccMapCache(), dcCache.getAccountId());
		for (Result accMap : accMapResults.all()) {
			accMapCache = (CEAccountMapCacheData) accMap.getValue();
		}
		accMapResults.discard();
		if(accMapCache==null)
		{
			logger.error("ControlEventPowerBean.clearDeviceFromCE Account map cache is null");
			return;
		}

		if (activeDevicesLeftForThisAccount == 1) {
			logger.info("ControlEventPowerBean.clearDeviceFromCE last active device for this account");
			EsiCacheData esiCache = null;
			List<Integer> esiIdList = new ArrayList<Integer>();
			Results esiResults = cacheManager.getCacheDataByAccId(
					cacheManager.getGwEsiCache(), dcCache.getAccountId());
			for (Result esiResult : esiResults.all()) {
				esiCache = (EsiCacheData) esiResult.getValue();
			}
			if(esiCache==null)
			{
				logger.info("ControlEventPowerBean.clearDeviceFromCE The ESI cache is null");
				return;
			}
			esiResults.discard();
			if(esiCache.getCeId()<=0)
			{
				logger.error("ControlEventPowerBean.clearDeviceFromCE The esi CE ID is null");
				return;
			}
			
			esiIdList.add(esiCache.getEsiId());
			// On DM Rejection set powerAvail to zero for the devices
			Cache gwDCCache = cacheManager.getGwDCCache();
			Results results = cacheManager
					.getCacheDataByEsiDcId(gwDCCache, dcCache.getEsiDcId());
			for (Result dcResult : results.all()) {
				EsiDcCacheData esiDcCache = (EsiDcCacheData) dcResult
						.getValue();
				if (esiDcCache == null) {
					continue;
				}
				esiDcCache.setActEnergyAvail(0.0);
				gwDCCache
						.put(new Element(esiDcCache.getCacheKey(), esiDcCache));
			}
			results.discard();
			// first log the Rejected ESI in DB
			CeEsiLog esiLog = new CeEsiLog();
			esiLog.setControlEventId(refControlEvent);
			esiLog.setDateCreated(currTime);
			esiLog.setEsiId(controlEventBeanFacade.getRefEsiByEsiId(esiCache
					.getEsiId()));

			esiLog.setLogMessage("ESI is stopped for "
					+ OpsCenterConstants.CE_NAME);
			esiLog.setCeEsiStatusId(stoppedCeEsiStatusId);
			controlEventBeanFacade.createCeEsiLog(esiLog);
			esiCache.setCeAccountMapId(0);
			esiCache.setCeDeviceMqIds(null);
			Element esiElement = new Element(esiCache.getCacheKey(), esiCache);
			cacheManager.getGwEsiCache().put(esiElement);
			// delete ceAccMapCache entry--
			logger.debug("Cache has been deleted for DM rejected ESI = "
					+ esiCache.getEsiId());
			List<CeAccountMap> ceAccountMap = controlEventBeanFacade
						.getCeAccountMapByAccountId(accMapCache.getCeAccId());
			logger.debug("ControlEventPowerBean.clearDeviceFromCE The CE AccounTID"+accMapCache.getCeAccMapId());
			cacheManager.deleteCEAccountMapCacheEntry(accMapCache
					.getCeAccMapId());
			controlEventBeanFacade.updateCeAccountMapStopTimes(refControlEvent,currTime);
			clearDeviceOnlyFromCE(dcCache,stoppedCeEsiStatusId,refControlEvent,accMapCache.getCeAccMapId(),currTime);
		} else {

			/*
			 * More than one device left in the control event for this account?
			 * Then just delete from the relevant caches, then delete from the
			 * DB
			 */
			// On DM Event Rejection powerAvail to zero for all devices
			clearDeviceOnlyFromCE(dcCache,stoppedCeEsiStatusId,refControlEvent,accMapCache.getCeAccMapId(),currTime);

		}
		}
		catch(Exception ex)
		{
			logger.error("ControlEventPowerBean.clearDeviceFromCE The exception is"+ex.getMessage());
			
		}
		logger.info("[ EXIT] ControlEventPowerBean.clearDeviceFromCE");
	}

	/**
	 * Method for clearing the Device only Cache
	 * @param EsiDcCacheData
	 *
	 */

	
	private void clearDeviceOnlyFromCE(EsiDcCacheData dcCache,CeEsiStatus stoppedCeEsiStatusId,ControlEvent refControlEvent,int iAccountMapID,DateTime currTime)
			throws AbstractOpsCenterException {
		logger.info("[ENTER] void ControlEventPowerBean.clearDeviceOnlyFromCE"
				+ "The AccountId" + dcCache.getAccountId() + "The ESIDCID is"
				+ dcCache.getEsiDcId() + "The CEID is" + dcCache.getCeId()+"The AccountMapID is"+iAccountMapID+"The CurrentTime is"+currTime);
		try
		{
		Cache gwDCCache = cacheManager.getGwDCCache();
		dcCache.setCeId(0);
		dcCache.setActEnergyAvail(0.0);
		dcCache.setSendDrlcEnd(true);
		logger.debug("Updating ESIDcache for esiDcId during clearing device cache =  "
				+ dcCache.getEsiDcId());
		gwDCCache.put(new Element(dcCache.getCacheKey(), dcCache));
		Results devResults = cacheManager.getCacheDataByEsiDcId(
				cacheManager.getCeDevCache(),
				Arrays.asList(dcCache.getEsiDcId()));
		for (Result devResult : devResults.all()) {
			CEDevicesCacheData devMapCache = (CEDevicesCacheData) devResult
					.getValue();

			if (devMapCache == null) {
				continue;
			}
			
			int devId = devMapCache.getCeDevicesId();
			CeDevices ceDevice = controlEventBeanFacade
					.getRefCeDevicesByCeDevicesId(devId);
           logger.debug("ControlEventPowerBean.clearDeviceOnlyFromCE The CE devices ID"+devId);
			//
			CeDevicesLog ceDevicesLog = new CeDevicesLog();
		    ceDevicesLog.setControlEventId(refControlEvent);
			ceDevicesLog.setDateCreated(currTime);
			ceDevicesLog.setCeDevicesId(ceDevice);
			// krmt-2094-- add device name to log
			String devName = OpsCenterConstants.deviceTypeToNameMap
					.get(devMapCache.getDevTypeId());
			ceDevicesLog.setLogMessage("Device " + devName
					+ " has been rejected because DM CE  in progress "
					+ OpsCenterConstants.CE_NAME);
			ceDevicesLog.setCeEsiStatusId(stoppedCeEsiStatusId);
			controlEventBeanFacade.createCeDevicesLog(ceDevicesLog);
			// updating DB as well
			controlEventBeanFacade.updateCeDevicesStop(iAccountMapID, currTime,devId);
			// Clearing device cache
			cacheManager.deleteCEDevicesCacheEntry(devMapCache.getCeDevicesId());
		}
		devResults.discard();
		logger.info("[ EXIT] ControlEventPowerBean.clearDeviceOnlyFromCE");
		}
		catch(Exception ex)
		{
			logger.info("ControlEventPowerBean.clearDeviceOnlyFromCE The exception is"+ex.getMessage());
			
		}
			

		}
	
	@Override
	public Boolean isAutoCERunning(Integer scadaReferenceId)
			throws AbstractOpsCenterException {

		Results ceResults = cacheManager.getCacheData(cacheManager.getControlEventCache());
		for (Result ceResult : ceResults.all()) {
			ControlEventCacheData ceCache = (ControlEventCacheData) ceResult
					.getValue();
			
			if (null != scadaReferenceId
					&& scadaReferenceId.equals(ceCache.getiScadaReferenceID())) {
				return true;
			}
		}
		return false;
	}

}
