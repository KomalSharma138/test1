package com.consert.service.ns.consertaccountprovisioning;

import static com.consert.core.ejb.constant.DefaultResources.ACC_ERR_CODE_DEPROVISIONABLE_GS_DEVICE_NOT_FOUND;
import static com.consert.core.ejb.constant.DefaultResources.DEMAND_MANAGER_DEVICE_ASSOCIATED;
import static com.consert.core.ejb.constant.DefaultResources.SCH_ERR_CODE_DATA_INVALID;
import static com.consert.core.ejb.constant.OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING;
import static java.lang.Long.parseLong;
import static org.apache.commons.lang.StringUtils.defaultIfEmpty;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.jws.HandlerChain;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.ws.WebServiceContext;

import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.consert.core.ejb.constant.DefaultResources;
import com.consert.core.ejb.constant.OpsCenterConstants;
import com.consert.core.ejb.exception.AbstractOpsCenterException;
import com.consert.core.ejb.exception.AccountNotFoundException;
import com.consert.core.ejb.exception.CompoundAccountKeyException;
import com.consert.core.ejb.exception.CompoundAccountKeyNotEnabled;
import com.consert.core.ejb.exception.CompoundAccountKeyNotUniqueException;
import com.consert.core.ejb.exception.DemandManagerException;
import com.consert.core.ejb.exception.ElectricMeterNotFoundException;
import com.consert.core.ejb.exception.EsiElectricMeterAlreadyExistsException;
import com.consert.core.ejb.exception.EsiGatewayAlreadyExistsException;
import com.consert.core.ejb.exception.EsiNotFoundException;
import com.consert.core.ejb.exception.GatewayNotFoundException;
import com.consert.core.ejb.exception.ProgramNotFoundException;
import com.consert.core.ejb.exception.ProgramTemplateException;
import com.consert.core.ejb.exception.SchemaDataInvalidException;
import com.consert.core.ejb.exception.SepVersionMismatchException;
import com.consert.core.ejb.multitenant.TenantContext;
import com.consert.core.ejb.session.CacheManagerBean;
import com.consert.core.ejb.session.CcMultispeakBean;
import com.consert.core.ejb.session.CcUtil;
import com.consert.core.ejb.session.facade.interfaces.DeviceBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.DeviceHealthCheckBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.EsiBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.GenericFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.ProgramBeanFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.ProgramTemplateFacadeLocal;
import com.consert.core.ejb.session.facade.interfaces.UserAccountBeanFacadeLocal;
import com.consert.core.ejb.session.interfaces.DemandManagerBeanLocal;
import com.consert.core.ejb.session.interfaces.local.UserProgramBeanLocal;
import com.consert.core.ejb.session.messages.GatewayMessagingWorkflowBean;
import com.consert.core.ejb.session.provisioning.services.ConfigurationException_Exception;
import com.consert.core.ejb.session.provisioning.services.Device;
import com.consert.core.ejb.session.provisioning.services.GatewayConfigurationServiceLocal;
import com.consert.core.ejb.session.utility.CompoundAccountKey;
import com.consert.core.entities.Account;
import com.consert.core.entities.Activatable;
import com.consert.core.entities.CeGroupAccountMap;
import com.consert.core.entities.Dc;
import com.consert.core.entities.DcMakeModel;
import com.consert.core.entities.DcTransitionPoint;
import com.consert.core.entities.DeviceType;
import com.consert.core.entities.DiagnosticResponse;
import com.consert.core.entities.DiagnosticResponseDevice;
import com.consert.core.entities.DiagnosticResponseDeviceLed;
import com.consert.core.entities.Esi;
import com.consert.core.entities.EsiDc;
import com.consert.core.entities.EsiGateway;
import com.consert.core.entities.EsiLcs;
import com.consert.core.entities.EsiTstat;
import com.consert.core.entities.EsiTstatWallPlate;
import com.consert.core.entities.ExternalAccountXRef;
import com.consert.core.entities.Gateway;
import com.consert.core.entities.GatewayMessagingWorkflow;
import com.consert.core.entities.GatewayMessagingWorkflowOrigin;
import com.consert.core.entities.GatewayMessagingWorkflowPlusSerialNo;
import com.consert.core.entities.GatewayMessagingWorkflowStep;
import com.consert.core.entities.GatewayMessagingWorkflowType;
import com.consert.core.entities.GatewayMessagingWorkflowTypeStep;
import com.consert.core.entities.GsProvisionable;
import com.consert.core.entities.HvacType;
import com.consert.core.entities.Lcs;
import com.consert.core.entities.ManageMode;
import com.consert.core.entities.MessagingOpcode;
import com.consert.core.entities.Program;
import com.consert.core.entities.ProgramScheduleMonthDay;
import com.consert.core.entities.ProgramScheduleRange;
import com.consert.core.entities.ProgramTemplate;
import com.consert.core.entities.ProgramTemplateProgram;
import com.consert.core.entities.ProgramTemplateScheduleMonthDay;
import com.consert.core.entities.ProgramTemplateScheduleRange;
import com.consert.core.entities.ProvStatusFlags;
import com.consert.core.entities.RemovalCode;
import com.consert.core.entities.Tstat;
import com.consert.core.entities.TstatDcGroup;
import com.consert.core.entities.TstatDcMap;
import com.consert.core.entities.TstatMakeModel;
import com.consert.core.entities.TstatTransitionPoint;
import com.consert.core.entities.TstatWallPlate;
import com.consert.core.entities.UserAccountMap;
import com.consert.core.entities.Utility;
import com.consert.core.model.AccountPartDefinitionModel;
import com.consert.core.model.AccountPartsModel;
import com.consert.core.model.UserProgramModel;
import com.consert.core.utils.PersistenceUtilities;
import com.consert.core.utils.ProvisioningEsiBean;
import com.consert.core.utils.TenantPropertyUtil;
import com.consert.core.utils.ValueBean;
import com.consert.service.ns.WebServiceUtil;
import com.consert.service.ns.xml.ConsertAccountDeprovisionReason;
import com.consert.service.ns.xml.ConsertAccountDeprovisionSimpleRequest;
import com.consert.service.ns.xml.ConsertAccountMeterDivorce;
import com.consert.service.ns.xml.ConsertAccountMeterMarriage;
import com.consert.service.ns.xml.ConsertAccountMeterReMarriage;
import com.consert.service.ns.xml.ConsertAccountProgramTemplateReMarriage;
import com.consert.service.ns.xml.ConsertAccountProvisioningResponse;
import com.consert.service.ns.xml.ConsertAccountProvisioningResponseStatus;
import com.consert.service.ns.xml.ConsertAccountReprovisionSimpleRequest;
import com.consert.service.ns.xml.ConsertAccountVppDivorce;
import com.consert.service.ns.xml.ConsertAccountVppMarriage;
import com.consert.service.ns.xml.ConsertAccountVppMigration;
import com.consert.service.ns.xml.ConsertAccountVppSwapRequest;
import com.consert.service.ns.xml.ConsertCompoundAccountKey;
import com.consert.service.ns.xml.ConsertDeviceSearchCriteria;
import com.consert.service.ns.xml.ConsertDeviceSearchResults;
import com.consert.service.ns.xml.ConsertDeviceSwap;
import com.consert.service.ns.xml.ConsertDeviceSwapRequest;
import com.consert.service.ns.xml.ConsertDiagnostic;
import com.consert.service.ns.xml.ConsertDiagnosticDevice;
import com.consert.service.ns.xml.ConsertDiagnosticDeviceLed;
import com.consert.service.ns.xml.ConsertDiagnosticRequest;
import com.consert.service.ns.xml.ConsertElectricHvacType;
import com.consert.service.ns.xml.ConsertElectricHvacTypeView;
import com.consert.service.ns.xml.ConsertElectricMeter;
import com.consert.service.ns.xml.ConsertError;
import com.consert.service.ns.xml.ConsertErrorById;
import com.consert.service.ns.xml.ConsertMeterSwapRequest;
import com.consert.service.ns.xml.ConsertPage;
import com.consert.service.ns.xml.ConsertProgramTemplate;
import com.consert.service.ns.xml.ConsertRelay;
import com.consert.service.ns.xml.ConsertReply;
import com.consert.service.ns.xml.ConsertUnprovisionedDeviceSearchCriteria;
import com.consert.service.ns.xml.ConsertVppBinaryChain;
import com.consert.service.ns.xml.ConsertVppBinaryDeviceController;
import com.consert.service.ns.xml.ConsertVppBinaryDeviceType;
import com.consert.service.ns.xml.ConsertVppBinaryPhysicalDevice;
import com.consert.service.ns.xml.ConsertVppHvacChain;
import com.consert.service.ns.xml.ConsertVppHvacDeviceController;
import com.consert.service.ns.xml.ConsertVppHvacPhysicalDevice;
import com.consert.service.ns.xml.ConsertVppHvacRemotelyMeasuredDevice;
import com.consert.service.ns.xml.ConsertVppLcsChain;
import com.consert.service.ns.xml.ConsertVppManagementRequest;
import com.consert.service.ns.xml.ConsertVppRelay;
import com.consert.service.ns.xml.ConsertVppRelayChain;
import com.consert.service.ns.xml.ConsertVppThermostat;
import com.consert.service.ns.xml.ConsertWorkflow;
import com.consert.service.ns.xml.ConsertWorkflowStatus;
import com.consert.service.ns.xml.ConsertWorkflowStep;
import com.consert.service.ns.xml.ConsertWorkflowTrackRequest;
import com.consert.service.ns.xml.ConsertWorkflowTrackResponse;
import com.consert.service.ns.xml.DiagnosticDeviceType;
import com.consert.service.ns.xml.DiagnosticLedResultType;
import com.consert.service.ns.xml.DiagnosticResultType;


@Stateless
@javax.jws.WebService(endpointInterface = "com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioning", targetNamespace = "http://service.consert.com/ns/ConsertAccountProvisioning", serviceName = "ConsertAccountProvisioning", portName = "ConsertAccountProvisioningPort", wsdlLocation = "META-INF/wsdl/ConsertAccountProvisioning.wsdl")
@HandlerChain(file="handlers.xml")
public class ConsertAccountProvisioningImpl implements
		ConsertAccountProvisioning, ConsertAccountProvisioningLocal, ConsertAccountProvisioningRemote
{	
	@Resource
	WebServiceContext wsctx;
	
	private static final int MAX_UNPROVISIONED_DEVICE_SEARCH_MINUTES = 60*24*14;

	private static final class ProvStateImpl implements ProvState, Serializable {

		private static final long serialVersionUID = 1L;
		
		private Esi esi;
		private Set<EsiTstat> provEsiTstatSet = new HashSet<EsiTstat>();
		private Set<EsiLcs> provEsiLcsSet = new HashSet<EsiLcs>();
		private Set<EsiLcs> deprovEsiLcsSet = new HashSet<EsiLcs>();
		private Set<EsiTstat> deprovEsiTstatSet = new HashSet<EsiTstat>();
		private Set<Lcs> swappedLcsSet = new HashSet<Lcs>();
		private Set<TstatWallPlate> swappedTstatWallPlateSet = new HashSet<TstatWallPlate>();
		
		/**
		 * 
		 */
		public ProvStateImpl()
		{
			// TODO Auto-generated constructor stub
		}
		/**
		 * @return the esi
		 */
		@Override
		public Esi getEsi()
		{
			return esi;
		}
		/**
		 * @param esi the esi to set
		 */
		public void setEsi(Esi esi)
		{
			this.esi = esi;
		}
		/**
		 * @return the provEsiTstatSet
		 */
		@Override
		public Set<EsiTstat> getProvEsiTstatSet()
		{
			return provEsiTstatSet;
		}
		/**
		 * @param provEsiTstatSet the provEsiTstatSet to set
		 */
		public void addEsiTstat(EsiTstat esiTstat)
		{
			this.provEsiTstatSet.add(esiTstat);
		}
		/**
		 * @return the provEsiLcsSet
		 */
		@Override
		public Set<EsiLcs> getProvEsiLcsSet()
		{
			return provEsiLcsSet;
		}
		/**
		 * @param provEsiLcsSet the provEsiLcsSet to set
		 */
		public void addEsiLcs(EsiLcs esiLcs)
		{
			this.provEsiLcsSet.add(esiLcs);
		}

		/**
		 * @param lcs the LCS to add to deprovLcsSet
		 */
		public void addDeprovEsiLcs(EsiLcs esiLcs)
		{
			this.deprovEsiLcsSet.add(esiLcs);
		}
		
		/**
		 * @param tstatWallPlate to add to deprovTstatWallPlateSet
		 */
		public void addDeprovEsiTstat(EsiTstat esiTstat)
		{
			this.deprovEsiTstatSet.add(esiTstat);
		}
		
		/**
		 * 
		 */
		@Override
		public Set<EsiLcs> getDeprovEsiLcsSet()
		{
			return this.deprovEsiLcsSet;
		}
		
		/**
		 * 
		 */
		@Override
		public Set<EsiTstat> getDeprovEsiTstatSet()
		{
			return this.deprovEsiTstatSet;
		}
		
		/**
		 * @param lcs the LCS to add to swappedLcsSet
		 */
		public void addSwappedLcs(Lcs lcs)
		{
			this.swappedLcsSet.add(lcs);
		}
		
		/**
		 * @param tstatWallPlate to add to swappedTstatWallPlateSet
		 */
		public void addSwappedTstatWallPlate(TstatWallPlate twp)
		{
			this.swappedTstatWallPlateSet.add(twp);
		}
		
		
		/**
		 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioningLocal.ProvState#getSwappedLcsSet()
		 */
		@Override
		public Set<Lcs> getSwappedLcsSet()
		{
			return this.swappedLcsSet;
		}
		
		/**
		 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioningLocal.ProvState#getSwappedTstatWallPlateSet()
		 */
		@Override
		public Set<TstatWallPlate> getSwappedTstatWallPlateSet()
		{
			return this.swappedTstatWallPlateSet;
		}		
	}

	public static final String DC_NAME_BMM = "BMM DC";

	@EJB
	private UserAccountBeanFacadeLocal userAccountBeanFacade;

	@EJB
	private ProgramBeanFacadeLocal programBeanFacade;

	@EJB
	private EsiBeanFacadeLocal esiBeanFacade;

	@EJB
	private DeviceBeanFacadeLocal deviceBeanFacade;

	@EJB
	private GatewayMessagingWorkflowBean gatewayMessagingWorkflowBean;

	@EJB
	private DeviceHealthCheckBeanFacadeLocal deviceHealthCheckBeanFacade;

	@EJB
	private GatewayConfigurationServiceLocal gatewayConfigurationService;

	@EJB
	private CacheManagerBean cacheManager;

	@EJB
	private GenericFacadeLocal genericFacade;

	@EJB
	private CcMultispeakBean ccMultispeakBean;
	
	@EJB
	private ConsertAccountProvisioningLocal consertAccountProvisioning;
	
	@EJB
	private ProgramTemplateFacadeLocal programTemplateFacade;
	
	@EJB
	private UserProgramBeanLocal userProgramBean;

	@EJB
	private DemandManagerBeanLocal demandManagerBeanLocal;

	@Resource
	private SessionContext context;

	private final Logger log = LoggerFactory.getLogger(getClass());
	
	@Override
	public List<ConsertAccountProvisioningResponse> vppManagementEnd(
			ConsertVppManagementRequest request)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		return doVppManagement(request, false);
	}

	@Override
	public List<ConsertAccountProvisioningResponse> vppManagementBegin(
			ConsertVppManagementRequest request)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		return doVppManagement(request, true);
	}

	/**
	 * @param compoundAccountKey
	 * @param accountNumber
	 * @param workflowTypeId
	 * @param workflowOriginId
	 * @return
	 */
	private List<ConsertAccountProvisioningResponse> doVppManagement(
			ConsertVppManagementRequest request, final boolean isManagementBegin)
	{
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();
		String accountNumber = request.getAccountNumber();
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();

		Exception exception = null;
		ConsertError consertCreateUpdateError = null;

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}

		Esi esi = null;
		EsiTstat esiTstat = null;
		EsiLcs esiLcs = null;
		try
		{

			CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
			final AccountPartsModel accountParts;
			try
			{
				accountParts = compoundAccountKeyUtility.getAccountParts();
			} catch (Exception e)
			{
				// Compound Account Key Error
				throw new CompoundAccountKeyException("Unexpected Error", e);
			}
			final Account account = getAccount(accountNumber,
					compoundAccountKey, accountParts);
			List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
					.getAccountId());
			if (esiList == null || esiList.isEmpty())
			{
				throw new EsiNotFoundException(
						DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"Account not provisioned");
			}

			// Use the one ESI assignment to determine the gateway.
			esi = esiList.get(0);
			
			final String lcsSerialNumber = WebServiceUtil.killWhitespace(request.getLcsSerialNumber());
			final String wallplateSerialNumber = WebServiceUtil.killWhitespace(request.getWallplateSerialNumber());
			
			if (lcsSerialNumber != null && wallplateSerialNumber != null)
			{
				throw new SchemaDataInvalidException(
						"Cannot populate both lcsSerialNumber and wallplateSerialNumber");
			}
			
			if (wallplateSerialNumber != null)
			{
				final TstatWallPlate tstatWallPlate = deviceBeanFacade
						.getTstatWallPlateBySerialNo(wallplateSerialNumber);
				if (tstatWallPlate == null)
				{
					throw new SchemaDataInvalidException(
							"Wallplate Serial Number "
									+ wallplateSerialNumber
									+ " is not recognized");
				}
				
				EsiTstatWallPlate esiTstatWallPlate = esiBeanFacade.getEsiTstatWallPlateByDeviceMacId(tstatWallPlate
						.getDeviceMacId());
				
				if (esiTstatWallPlate == null)
				{
					throw new SchemaDataInvalidException(
							"Wallplate Serial Number "
									+ wallplateSerialNumber
									+ " is not associated with any account");
				}
				
				esiTstat = esiBeanFacade.getEsiTstatByDeviceMacIdAndEsiId(tstatWallPlate.getDeviceMacId(), esiTstatWallPlate.getEsiId().getEsiId());
				
				if (esiTstat == null)
				{
					throw new SchemaDataInvalidException(
							"Wallplate Serial Number "
									+ wallplateSerialNumber
									+ " is not associated with a tstat");
				}
			}
			else if (lcsSerialNumber != null)
			{
				final Lcs lcs = deviceBeanFacade
						.getLcsByGsSbrSerialNo(lcsSerialNumber);
				if (lcs == null)
				{
					throw new SchemaDataInvalidException(
							"LCS Seria lNumber "
									+ lcsSerialNumber
									+ " is not recognized");
				}

				esiLcs = esiBeanFacade.getEsiLcsByDeviceMacId(lcs
								.getDeviceMacId());
				
				if (esiLcs == null)
				{
					throw new SchemaDataInvalidException(
							"LCS Serial Number "
									+ lcsSerialNumber
									+ " is not associated with any account");
				}
			}

		} catch (AbstractOpsCenterException e)
		{
			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(e.getErrorCode());
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);
			// response.setError(consertCreateUpdateError);
			e.setContext(getContext(errorObjectDetails));
			exception = e;
		}
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		int workflowTypeId;
		int workflowOriginId;
		boolean isGridStream = false;
		if (esi != null)
		{
			isGridStream = esi.getNetworkDeliveryId() == 2 ? true : false;
		}
		// For GS/Vpp Management Begin
		if (isManagementBegin)
		{
			if (isGridStream)
			{
				workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_MANAGEMENT_BEGIN;
			} else
			{
				workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_VPP_MANAGEMENT_BEGIN;
			}
			workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPMANAGEMENT_BEGIN;
		} else
		{
			// For GS/VPP Management End
			if (isGridStream)
			{
				workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_MANAGEMENT_END;
			} else
			{
				workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_VPP_MANAGEMENT_END;
			}
			workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPMANAGEMENT_END;
		}

		if (isGridStream && exception == null && esi != null)
		{	
			if (esiTstat != null)
			{
				ConsertAccountProvisioningResponse response = startWorkflow(esiTstat, datatypeFactory, request,
						workflowTypeId, workflowOriginId, userCreated);
				responseList.add(response);
				
			}
			else if (esiLcs != null)
			{
				ConsertAccountProvisioningResponse response = startWorkflow(esiLcs, datatypeFactory, request,
						workflowTypeId, workflowOriginId, userCreated);
				responseList.add(response);
			}
			else
			{
				final List<EsiTstat> esiTstatList = esiBeanFacade
						.getEsiTstatByEsiId(esi.getEsiId());
				for (EsiTstat esiTstat2 : esiTstatList)
				{
					ConsertAccountProvisioningResponse response = startWorkflow(esiTstat2, datatypeFactory, request,
							workflowTypeId, workflowOriginId, userCreated);
					responseList.add(response);
				}
				final List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(esi
						.getEsiId());
				for (EsiLcs esiLcs2 : esiLcsList)
				{
					ConsertAccountProvisioningResponse response = startWorkflow(esiLcs2, datatypeFactory, request,
							workflowTypeId, workflowOriginId, userCreated);
					responseList.add(response);
				}
			}
		} else
		{
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);
			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowTypeId(esiBeanFacade
							.getRefGatewayMessagingWorkflowType(workflowTypeId));
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowOriginId(esiBeanFacade
							.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
			gatewayMessagingWorkflow.setEsiId(esi);
			try
			{
				populateWorkflowWithReply(gatewayMessagingWorkflow,
						request.getReply());
			} catch (SchemaDataInvalidException exp)
			{
				exception = exp;
				exp.printStackTrace();
			}
			gatewayMessagingWorkflowBean.startWorkflow(
					gatewayMessagingWorkflow, exception);
			response.setTrackingId(gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				response.setTrackingType(gatewayMessagingWorkflowOriginId
						.getName());
			}
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}
		return responseList;
	}

	private ConsertAccountProvisioningResponse startWorkflow(EsiLcs esiLcs, DatatypeFactory datatypeFactory,
			ConsertVppManagementRequest request, int workflowTypeId, int workflowOriginId, String userCreated) {
		Esi esi = esiLcs.getEsiId();
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow.setUsrCreated(userCreated);
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(workflowTypeId));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
		gatewayMessagingWorkflow.setEsiId(esi);
		gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
		Exception unexpectedException = null;
		try
		{
			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());
		} catch (SchemaDataInvalidException exp)
		{
			unexpectedException = exp;
			exp.printStackTrace();
		}
		gatewayMessagingWorkflowBean.startWorkflow(
				gatewayMessagingWorkflow, unexpectedException);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId
					.getName());
		}
		response.setLcsSerialNumber(esiLcs.getLcsId().getGsSbrSerialNo());
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	private ConsertAccountProvisioningResponse startWorkflow(EsiTstat esiTstat, DatatypeFactory datatypeFactory,
			ConsertVppManagementRequest request, int workflowTypeId, int workflowOriginId, String userCreated) 
	{
		Esi esi = esiTstat.getEsiId();
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow.setUsrCreated(userCreated);
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(workflowTypeId));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
		gatewayMessagingWorkflow.setEsiId(esi);
		gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
		
		Exception unexpectedException = null;
		try
		{
			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());
		} catch (SchemaDataInvalidException exp)
		{
			unexpectedException = exp;
			exp.printStackTrace();
		}
		gatewayMessagingWorkflowBean.startWorkflow(
				gatewayMessagingWorkflow, unexpectedException);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId
					.getName());
		}
		response.setWallplateSerialNumber(esiTstat.getTstatWallPlate().getGsSbrSerialNo());
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	private String getUserName()
	{
		log.debug("returning UNAUTHENTICATED" );
		return "UNAUTHENTICATED";
		//return context.getCallerPrincipal().getName();	
	}

	/**
	 * @param errorObjectDetails
	 * @param accountNumber
	 * @param compoundAccountKey
	 */
	private void addToErrorObjectDetails(
			final List<ConsertErrorById> errorObjectDetails,
			String accountNumber, ConsertCompoundAccountKey compoundAccountKey)
	{
		addToErrorObjectDetails(errorObjectDetails, "accountNumber",
				"compoundAccountKey", accountNumber, compoundAccountKey);
	}

	/**
	 * @param errorObjectDetails
	 * @param accountNumber
	 * @param compoundAccountKey
	 */
	private void addToErrorObjectDetails(
			final List<ConsertErrorById> errorObjectDetails,
			String accountNumberName, String compoundAccountKeyName,
			String accountNumber, ConsertCompoundAccountKey compoundAccountKey)
	{
		if (compoundAccountKey != null)
		{
			addToErrorObjectDetails(errorObjectDetails, compoundAccountKeyName
					+ ".billingAccountNumber",
					compoundAccountKey.getBillingAccountNumber());
			addToErrorObjectDetails(errorObjectDetails, compoundAccountKeyName
					+ ".premiseNumber", compoundAccountKey.getPremiseNumber());
			addToErrorObjectDetails(errorObjectDetails, compoundAccountKeyName
					+ ".meterLocationNumber",
					compoundAccountKey.getMeterLocationNumber());
			addToErrorObjectDetails(errorObjectDetails, compoundAccountKeyName
					+ ".utilityLocation", compoundAccountKey.getUtilityNumber());
		}
		addToErrorObjectDetails(errorObjectDetails, accountNumberName,
				accountNumber);
	}

	private void addToErrorObjectDetails(
			List<ConsertErrorById> errorObjectDetails, String type, String id)
	{
		if (WebServiceUtil.killWhitespace(id) != null)
		{
			ConsertErrorById error = new ConsertErrorById();
			error.setObjectType(type);
			error.setObjectId(id);
			errorObjectDetails.add(error);
		}
	}

	/**
	 * @param errorObjectDetails
	 * @return
	 */
	private String getContext(final List<ConsertErrorById> errorObjectDetails)
	{
		StringBuffer buffer = new StringBuffer();
		final Iterator<ConsertErrorById> iterator = errorObjectDetails
				.iterator();
		if (iterator.hasNext())
		{
			ConsertErrorById detail = iterator.next();
			buffer.append(detail.getObjectType()).append("=")
					.append(detail.getObjectId());
			while (iterator.hasNext())
			{
				buffer.append(", ");
				detail = iterator.next();
				buffer.append(detail.getObjectType()).append("=")
						.append(detail.getObjectId());
			}
		}
		return buffer.toString();
	}

	private String getContext(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey,
			String oldAccountNumber,
			ConsertCompoundAccountKey oldCompoundAccountKey)
	{
		StringBuffer buffer = new StringBuffer();
		if (WebServiceUtil.killWhitespace(accountNumber) != null)
		{
			buffer.append("accountNumber").append("=").append(accountNumber);
		}
		if (compoundAccountKey != null)
		{
			buffer.append("compoundAccountKey").append("=[");
			buffer.append(compoundAccountKey.getBillingAccountNumber()).append(
					", ");
			buffer.append(compoundAccountKey.getPremiseNumber()).append(", ");
			buffer.append(compoundAccountKey.getMeterLocationNumber()).append(
					", ");
			buffer.append(compoundAccountKey.getUtilityNumber()).append("]");
		}
		if (WebServiceUtil.killWhitespace(oldAccountNumber) != null)
		{
			buffer.append("oldAccountNumber").append("=")
					.append(oldAccountNumber);
		}
		if (oldCompoundAccountKey != null)
		{
			buffer.append("oldCompoundAccountKey").append("=[");
			buffer.append(oldCompoundAccountKey.getBillingAccountNumber())
					.append(", ");
			buffer.append(oldCompoundAccountKey.getPremiseNumber())
					.append(", ");
			buffer.append(oldCompoundAccountKey.getMeterLocationNumber())
					.append(", ");
			buffer.append(oldCompoundAccountKey.getUtilityNumber()).append("]");
		}
		return buffer.toString();
	}

	@Override
	public List<ConsertAccountProvisioningResponse> accountMoveOutMoveIn(
			ConsertAccountMeterReMarriage accountMeterReMarriage)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return accountMoveOutMoveIn(accountMeterReMarriage, tenantId);
		
	}
	
	@Override
	public List<ConsertAccountProvisioningResponse> accountMoveOutMoveIn(
			ConsertAccountMeterReMarriage accountMeterReMarriage, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		log.info("[ENTER] List<ConsertAccountProvisioningResponse> ConsertAccountProvisioningImpl.accountMoveOutMoveIn()");
		
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		if (accountMeterReMarriage == null)
		{
			log.info("[ EXIT] ConsertAccountProvisioningImpl.accountMoveOutMoveIn");

			return null;
		}

		final String accountNumber = accountMeterReMarriage.getAccountNumber();
		final String oldAccountNumber = accountMeterReMarriage
				.getOldAccountNumber();
		ConsertCompoundAccountKey compoundAccountKey = accountMeterReMarriage
				.getCompoundAccountKey();
		ConsertCompoundAccountKey oldCompoundAccountKey = accountMeterReMarriage
				.getOldCompoundAccountKey();

		String userCreated = accountMeterReMarriage.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}	

		Exception exception = null;
		ConsertError consertCreateUpdateError = null;
		Esi esi = null;
		try
		{
			esi = consertAccountProvisioning.accountMoveOutMoveInPersist(
					accountNumber, compoundAccountKey, oldAccountNumber,
					oldCompoundAccountKey, userCreated);
		} catch (Exception e1)
		{

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to Account_MoveOut_MoveIn", e1);

			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);
			addToErrorObjectDetails(errorObjectDetails, "oldAccountNumber",
					"oldCompoundAccountKey", oldAccountNumber,
					oldCompoundAccountKey);

			if (abstractOpsCenterException != null)
			{
				// DEV-225: A little hackish, but I wanted to fit the CAK data
				// into the 255 chars for STATUS_TEXT
				abstractOpsCenterException.setContext(getContext(accountNumber,
						compoundAccountKey, oldAccountNumber,
						oldCompoundAccountKey));
			}
			
			// RDRN-728: Changed to reflect behavior of device swap
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);
			
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			
			responseList.add(response);
			
			return responseList;
		}

		boolean isGridStream = false;
		if (esi != null)
		{
			isGridStream = esi.getNetworkDeliveryId() == 2 ? true : false;
		}
		final int workflowTypeId;
		final int workflowOriginId;
		if (isGridStream)
		{
			// gatewayMessagingWorkflow.setGatewayMessagingWorkflowTypeId(esiBeanFacade.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING));
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING;
		} else
		{
			// gatewayMessagingWorkflow.setGatewayMessagingWorkflowTypeId(esiBeanFacade.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING;
		}
		workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ACCOUNT_MOVEOUT_MOVEIN;

		if (isGridStream && exception == null && esi != null)
		{

			final List<EsiTstat> esiTstatList = esiBeanFacade
					.getEsiTstatByEsiId(esi.getEsiId());
			for (EsiTstat esiTstat : esiTstatList)
			{
				TstatWallPlate tstatWallPlate = esiTstat.getTstatWallPlate();
				if (tstatWallPlate != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowTypeId(esiBeanFacade
									.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowOriginId(esiBeanFacade
									.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(esi);
					gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow,
								accountMeterReMarriage.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(
							gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowId());
					response.setWallplateSerialNumber(tstatWallPlate.getGsSbrSerialNo());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId
								.getName());
					}
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}
			final List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(esi
					.getEsiId());
			for (EsiLcs esiLcs : esiLcsList)
			{
				Lcs lcsId = esiLcs.getLcsId();
				if (lcsId != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
	
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowTypeId(esiBeanFacade
									.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowOriginId(esiBeanFacade
									.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(esi);
					gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow,
								accountMeterReMarriage.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(
							gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowId());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId
								.getName());
					}
					response.setLcsSerialNumber(lcsId.getGsSbrSerialNo());
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}
		} else
		{
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);
			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowTypeId(esiBeanFacade
							.getRefGatewayMessagingWorkflowType(workflowTypeId));
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowOriginId(esiBeanFacade
							.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
			gatewayMessagingWorkflow.setEsiId(esi);
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			try
			{
				populateWorkflowWithReply(gatewayMessagingWorkflow,
						accountMeterReMarriage.getReply());
			} catch (SchemaDataInvalidException exp)
			{
				exception = exp;
				exp.printStackTrace();
			}
			gatewayMessagingWorkflowBean.startWorkflow(
					gatewayMessagingWorkflow, exception);
			response.setTrackingId(gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				response.setTrackingType(gatewayMessagingWorkflowOriginId
						.getName());
			}
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}

		log.info("[ EXIT] ConsertAccountProvisioningImpl.accountMoveOutMoveIn");
		
		return responseList;
	}

	/**
	 * @param accountNumber
	 * @param oldAccountNumber
	 * @param user
	 * @return esi
	 * @throws AbstractOpsCenterException
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public Esi accountMoveOutMoveInPersist(final String accountNumber,
			final ConsertCompoundAccountKey compoundAccountKey,
			final String oldAccountNumber,
			final ConsertCompoundAccountKey oldCompoundAccountKey, String user)
			throws Exception
	{

		try
		{
			// TODO - potential optimization is to get the account Id, instead
			// of the entire object graph
			CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
			AccountPartsModel accountParts;
			try
			{
				accountParts = compoundAccountKeyUtility.getAccountParts();
			} catch (Exception e)
			{
				// Compound Account Key Error
				throw new CompoundAccountKeyException("Unexpected Error", e);
			}

			final Account oldAccount;
			if (compoundAccountKey != null
					&& accountParts.isCompoundKeyEnabled())
			{
				List<ExternalAccountXRef> externalAccountXRefList = getExternalAccountXrefList(
						accountParts, oldCompoundAccountKey);
				if (externalAccountXRefList.isEmpty())
				{
					oldAccount = null;
				} else if (externalAccountXRefList.size() > 1)
				{
					Account firstMatch = null;
					for (ExternalAccountXRef externalAccountXRef : externalAccountXRefList)
					{
						Account account = externalAccountXRef.getAccount();
						List<Esi> esiList = esiBeanFacade
								.getEsiByAccountId(account.getAccountId());
						if (esiList != null && !esiList.isEmpty())
						{
							if (firstMatch == null)
							{
								firstMatch = account;
							} else
							{
								throw new CompoundAccountKeyNotUniqueException(
										"More than one account matched the keys in oldCompoundAccountKey");
							}
						}
					}
					oldAccount = firstMatch;
				} else
				{
					ExternalAccountXRef externalAccountXRef = externalAccountXRefList
							.get(0);
					oldAccount = externalAccountXRef.getAccount();
				}
			} else
			{
				// TODO - potential optimization is to get the account Id,
				// instead of the entire object graph
				List<Account> accountByAccountNoList = userAccountBeanFacade
						.getAccountByAccountNumberAndNotDeleted(oldAccountNumber);
				oldAccount = accountByAccountNoList.isEmpty() ? null
						: accountByAccountNoList.get(0);
			}

			if (oldAccount == null)
			{
				throw new AccountNotFoundException(
						"Old Account not found, compoundKeyEnabled="
								+ accountParts.isCompoundKeyEnabled());
			}

			List<Esi> esiList = esiBeanFacade.getEsiByAccountId(oldAccount
					.getAccountId());
			Esi oldEsi = esiList == null || esiList.isEmpty() ? null : esiList
					.get(0);

			if (oldEsi == null)
			{
				throw new EsiNotFoundException(
						DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"Old Account not provisioned " + oldAccountNumber);
			}

			DateTime now = new DateTime();
			log.debug("Now  "+ now);
			// Always returns an account, otherwise it throws an exception
			final Account account = getAccount(accountNumber,
					compoundAccountKey, accountParts);
			List<EsiTstat> oldEsiTstatList = esiBeanFacade
					.getEsiTstatByEsiId(oldEsi.getEsiId());
			List<EsiDc> oldEsiDcList = esiBeanFacade.getEsiDcByEsiId(oldEsi
					.getEsiId());
			List<EsiLcs> oldEsiLcsList = esiBeanFacade.getEsiLcsByEsiId(oldEsi
					.getEsiId());
			List<EsiTstatWallPlate> oldEsiTstatWallPlateList = esiBeanFacade
					.getEsiTstatWallPlateByEsiId(oldEsi.getEsiId());
			List<TstatDcMap> oldTstatDcMapList = esiBeanFacade
					.getTstatDcMapByEsiId(oldEsi.getEsiId());
			
			ProvisioningEsiBean rProvEsiBean = new ProvisioningEsiBean();
			rProvEsiBean.setEsi(oldEsi);
			rProvEsiBean.setEsiDcList(oldEsiDcList);
			rProvEsiBean.setEsiTstatList(oldEsiTstatList);
			rProvEsiBean.setEsiTstatWallPlateList(oldEsiTstatWallPlateList);
			rProvEsiBean.setEsiLcsList(oldEsiLcsList);
			rProvEsiBean.setTstatDcMapList(oldTstatDcMapList);
			rProvEsiBean.setUser(user);
			rProvEsiBean.setNow(now);
			
			Esi esi = reverseEsi(account, rProvEsiBean);
			final Esi e;
			if (esi != null) {
				e = esi;
			} else {
				Object obj = marryMe(account, null, null, oldEsi, true);
				e = (Esi) obj;
				copyDevicesAndProgramDataToNewEsi(e, oldEsi, oldEsiDcList, oldEsiTstatList, oldEsiLcsList,
						oldEsiTstatWallPlateList, user, now);
				if (!oldEsiDcList.isEmpty()) {
					assignDefaultProgramIfNull(e.getAccountId(), oldEsi.getAccountId(), user, now);
				}
			}
			ProvisioningEsiBean provEsiBean = new ProvisioningEsiBean();
			provEsiBean.setEsi(oldEsi);
			provEsiBean.setEsiDcList(oldEsiDcList);
			provEsiBean.setEsiTstatList(oldEsiTstatList);
			provEsiBean.setEsiLcsList(oldEsiLcsList);
			provEsiBean.setEsiTstatWallPlateList(oldEsiTstatWallPlateList);
			provEsiBean.setTstatDcMapList(oldTstatDcMapList);
			provEsiBean.setUser(user);
			provEsiBean.setNow(now);
			
			flagDevicesAndProgramDataAsDeletedOnOldEsi(false, provEsiBean, null, null);
			cacheManager.removeGatewayAndEsiData(oldEsi);
			cacheManager.cacheEsiDeviceData((long) e.getEsiGatewayId()
					.getGatewayMqId(), e.getEsiMqId(), (long) e.getEsiId(), e
					.getNetworkDeliveryId());
			
			// marking soft delete dm config if old account associated with DM
			try
			{
				demandManagerBeanLocal.deleteDmConfig(oldAccount.getAccountId());
			} catch (Exception ex)
			{
				if(!(ex instanceof DemandManagerException))
					throw ex;
				log.info("No DM config found for accountId {}", oldAccount.getAccountId());
			}
			return e;
		} catch (Exception e)
		{
			context.setRollbackOnly();
			throw e;
		}
	}

	/**
	 * This method is new style: The reversal re-uses previous ESI objects by
	 * undeleting them. DEV-272: WSI, MoveOut/MoveIn Reversal: Consumer Portal
	 * Energy Snapshot data does not display after reversal. As of 5/1/ 2014 I
	 * have deleted the method that did the reversal the old KRMT-4671 way.
	 * 
	 * @param account
	 * @param oldEsi
	 * @param oldEsiElectricMeter
	 * @param oldEsiDcList
	 * @param oldEsiTstatList
	 * @param oldEsiLcsList
	 * @param oldEsiTstatWallPlateList
	 * @param oldEsiZigbeeList
	 * @param user
	 * @param now
	 * @return
	 * @throws ProgramNotFoundException
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private Esi reverseEsi(Account account, ProvisioningEsiBean provEsiBean)
			throws ProgramNotFoundException, IllegalAccessException,
			InvocationTargetException, NoSuchMethodException
	{

		// undo flagDevicesAndProgramDataAsDeletedOnOldEsi
		Esi oldEsi = provEsiBean.getEsi();
		List<EsiDc> oldEsiDcList = provEsiBean.getEsiDcList();
		List<EsiTstat> oldEsiTstatList = provEsiBean.getEsiTstatList(); 
		List<EsiLcs> oldEsiLcsList = provEsiBean.getEsiLcsList();
		List<EsiTstatWallPlate> oldEsiTstatWallPlateList = provEsiBean.getEsiTstatWallPlateList();
		List<TstatDcMap> oldTstatDcMapList = provEsiBean.getTstatDcMapList(); 
		String user = provEsiBean.getUser();
		DateTime now = provEsiBean.getNow();
		
		log.debug("Getting esi for account id : " + account.getAccountId());
		List<Esi> e1 = esiBeanFacade.getEsiByAccountId(account.getAccountId());
		Esi e;
		
		if(e1 == null || e1.size() == 0)
		{
			log.debug("No existing esi found for account id :" + account.getAccountId());
			e = esiBeanFacade.getReversalEsiByAccount(account);
		} else
		{
			 e = e1.get(0);
		}
		
		if (e == null)
		{
			return null;
		}
		log.debug("Found Esi "+ e.getEsiId());
		List<EsiDc> esiDcList = esiBeanFacade.getReversalEsiDcByEsi(e);
		List<EsiTstat> esiTstatList = esiBeanFacade.getReversalEsiTstatByEsi(e);
		List<EsiLcs> esiLcsList = esiBeanFacade.getReversalEsiLcsByEsi(e);
		List<EsiTstatWallPlate> esiTstatWallPlateList = esiBeanFacade
				.getReversalEsiTstatWallPlateByEsi(e);
		List<TstatDcMap> tstatDcMapList = esiBeanFacade.getReversalTstatDcMap(e);
		
		final ArrayList<EsiDc> esiDcs = new ArrayList<EsiDc>();
		final ArrayList<EsiTstat> esiTstats = new ArrayList<EsiTstat>();
		// final ArrayList<EsiLcs> esiLcses = new ArrayList<EsiLcs>();

		e.setDeleteFlag(OpsCenterConstants.FALSE);
		EsiGateway eg = e.getEsiGatewayId();
		eg.setDeleteFlag(OpsCenterConstants.FALSE);
		eg.setDateUpdated(now);
		EsiGateway oldEsiGateway = oldEsi.getEsiGatewayId();
		if (oldEsiGateway != null)
		{
			// This section handles gateway swap

			Gateway oldGateway = oldEsiGateway.getGatewayId();
			if (oldGateway != eg.getGatewayId())
			{
				eg.setGatewayId(oldGateway);
			}
		}

		HashMap<Dc, EsiDc> oldEsiDcByDc = new HashMap<Dc, EsiDc>();
		for (EsiDc esiDc : oldEsiDcList)
		{
			oldEsiDcByDc.put(esiDc.getDcId(), esiDc);
		}

		HashMap<Tstat, EsiTstat> oldEsiTstatByTstat = new HashMap<Tstat, EsiTstat>();
		for (EsiTstat esiTstat : oldEsiTstatList)
		{
			oldEsiTstatByTstat.put(esiTstat.getTstatId(), esiTstat);
		}

		HashMap<EsiTstat, TstatDcMap> oldTstatDcMapByEsiTstat = new HashMap<EsiTstat, TstatDcMap>();
		for (TstatDcMap tstatDcMap : oldTstatDcMapList)
		{
			oldTstatDcMapByEsiTstat.put(tstatDcMap.getEsiTstatId(), tstatDcMap);
		}
		
		HashMap<EsiTstat, TstatDcMap> revarsalTstatDcMapByEsiTstat = new HashMap<EsiTstat, TstatDcMap>();
		for (TstatDcMap tstatDcMap : tstatDcMapList)
		{
			revarsalTstatDcMapByEsiTstat.put(tstatDcMap.getEsiTstatId(), tstatDcMap);
		}

		HashMap<Lcs, EsiLcs> oldEsiLcsByLcs = new HashMap<Lcs, EsiLcs>();
		for (EsiLcs esiLcs : oldEsiLcsList)
		{
			oldEsiLcsByLcs.put(esiLcs.getLcsId(), esiLcs);
		}

		HashMap<TstatWallPlate, EsiTstatWallPlate> oldEsiTstatWallPlateByTstatWallPlate = new HashMap<TstatWallPlate, EsiTstatWallPlate>();
		for (EsiTstatWallPlate esiTstatWallPlate : oldEsiTstatWallPlateList)
		{
			oldEsiTstatWallPlateByTstatWallPlate.put(
					esiTstatWallPlate.getTstatWallPlateId(), esiTstatWallPlate);
		}

		

		for (EsiDc esiDc : esiDcList)
		{
			EsiDc oldEsiDc = oldEsiDcByDc.remove(esiDc.getDcId());
			if (oldEsiDc != null)
			{
				esiDc.setDeleteFlag(OpsCenterConstants.FALSE);
				esiDc.setDateUpdated(now);

				Dc dc = esiDc.getDcId();
				dc.setEsiId(e);
				dc.setDateModified(now);
				esiDcs.add(esiDc);
			}
		}

		for (EsiTstat esiTstat : esiTstatList)
		{
			EsiTstat oldEsiTstat = oldEsiTstatByTstat.remove(esiTstat
					.getTstatId());
			if (oldEsiTstat != null)
			{
				esiTstat.setDeleteFlag(OpsCenterConstants.FALSE);
				esiTstat.setDateUpdated(now);

				Tstat tstat = esiTstat.getTstatId();
				tstat.setEsiId(e);
				tstat.setDateModified(now);
				esiTstats.add(esiTstat);

				if (e.getNetworkDeliveryId() == 2)
				{
					TstatWallPlate wallPlate = esiTstat.getTstatWallPlate();
					wallPlate.setEsiId(e);
					wallPlate.setDateModified(now);
				}

				// Reverse the HVAC Group
				/*TstatDcMap oldTstatDcMap = oldTstatDcMapByEsiTstat.remove(oldEsiTstat);
				  oldTstatDcMap.getTstatDcGroupId().setEsiId(e);*/
				TstatDcMap tstatDcMap = revarsalTstatDcMapByEsiTstat.remove(esiTstat);
				tstatDcMap.getTstatDcGroupId().setEsiId(e);
			}
		}

		for (EsiLcs esiLcs : esiLcsList)
		{
			EsiLcs oldEsiLcs = oldEsiLcsByLcs.remove(esiLcs.getLcsId());
			if (oldEsiLcs != null)
			{
				esiLcs.setDeleteFlag(OpsCenterConstants.FALSE);
				esiLcs.setDateUpdated(now);

				Lcs lcs = esiLcs.getLcsId();
				lcs.setEsiId(e);
				lcs.setDateModified(now);
				// esiLcses.add(esiLcs);
			}
		}

		for (EsiTstatWallPlate esiTstatWallPlate : esiTstatWallPlateList)
		{
			EsiTstatWallPlate oldEsiTstatWallPlate = oldEsiTstatWallPlateByTstatWallPlate
					.remove(esiTstatWallPlate.getTstatWallPlateId());
			if (oldEsiTstatWallPlate != null)
			{
				esiTstatWallPlate.setDeleteFlag(OpsCenterConstants.FALSE);
				esiTstatWallPlate.setDateUpdated(now);

				TstatWallPlate tstatWallPlate = esiTstatWallPlate
						.getTstatWallPlateId();
				tstatWallPlate.setEsiId(e);
				tstatWallPlate.setDateModified(now);
			}
		}

		boolean hasDefault = false;
		List<Program> reversalPrograms = programBeanFacade
				.getReversalProgramsByAccountId(e.getAccountId().getAccountId());
		if (!reversalPrograms.isEmpty())
		{
			List<DcTransitionPoint> reversalDcTransitionPoints = programBeanFacade
					.getReversalDcTransitionPointByEsiDcIdsProgramIds(
							reversalPrograms, esiDcs);
			List<TstatTransitionPoint> reversalTstatTransitionPoint = programBeanFacade
					.getReversalTstatTransitionPointByEsiTstatIdsProgramIds(
							reversalPrograms, esiTstats);
			if (!reversalDcTransitionPoints.isEmpty()
					|| !reversalTstatTransitionPoint.isEmpty())
			{
				Set<Program> finalReversalPrograms = new HashSet<Program>();
				for (DcTransitionPoint dcTransitionPoint : reversalDcTransitionPoints)
				{
					finalReversalPrograms.add(dcTransitionPoint.getProgramId());
				}
				for (TstatTransitionPoint tstatTransitionPoint : reversalTstatTransitionPoint)
				{
					finalReversalPrograms.add(tstatTransitionPoint
							.getProgramId());
				}

				List<ProgramScheduleMonthDay> reversalProgramScheduleMonthDays = programBeanFacade
						.getReversalProgramScheduleMonthDayByProgramIds(finalReversalPrograms);
				List<ProgramScheduleRange> reversalProgramScheduleRanges = programBeanFacade
						.getReversalProgramScheduleRangeByProgramIds(finalReversalPrograms);

				// check for default program
				for (Program program : finalReversalPrograms)
				{
					hasDefault = hasDefault || program.isDefault();
					activate(program, user, now);
					log.debug("Reversing program name=" + program.getName());
				}

				for (ProgramScheduleMonthDay programScheduleMonthDay : reversalProgramScheduleMonthDays)
				{
					activate(programScheduleMonthDay, user, now);
				}

				for (ProgramScheduleRange programScheduleRange : reversalProgramScheduleRanges)
				{
					activate(programScheduleRange, user, now);
				}

				for (DcTransitionPoint dcTransitionPoint : reversalDcTransitionPoints)
				{
					activate(dcTransitionPoint, user, now);
				}

				for (TstatTransitionPoint tstatTransitionPoint : reversalTstatTransitionPoint)
				{
					activate(tstatTransitionPoint, user, now);
				}
			}
		}

		Collection<EsiDc> oldEsiDcs = oldEsiDcByDc.values();
		Collection<EsiTstat> oldEsiTstats = oldEsiTstatByTstat.values();
		Collection<EsiLcs> oldEsiLcses = oldEsiLcsByLcs.values();
		Collection<EsiTstatWallPlate> oldEsiTstatWallPlates = oldEsiTstatWallPlateByTstatWallPlate
				.values();
		if (!oldEsiDcs.isEmpty() || !oldEsiTstats.isEmpty()
				|| !oldEsiLcses.isEmpty() || !oldEsiTstatWallPlates.isEmpty())
		{
			copyDevicesAndProgramDataToNewEsi(e, oldEsi, oldEsiDcs,
					oldEsiTstats, oldEsiLcses, oldEsiTstatWallPlates, user, now);
		}

		// If have a dc then need a program (don't have to check tstats b/c
		// tstats currently require a dc)
		if (!hasDefault && (!esiDcs.isEmpty() || !oldEsiDcs.isEmpty()))
		{
			assignDefaultProgramIfNull(e.getAccountId(), oldEsi.getAccountId(),
					user, now);
		}

		userAccountBeanFacade.defaultCeGroups(account);

		return e;
	}

	/**
	 * @param program
	 * @param user
	 * @param now
	 */
	private void activate(Activatable activatable, String user, DateTime now)
	{
		activatable.setActiveFlag(OpsCenterConstants.TRUE);
		activatable.setDeleteFlag(OpsCenterConstants.FALSE);
		activatable.setDateModified(now);
		activatable.setUserModified(user);
	}

	/**
	 * @param gatewayMessagingWorkflow
	 * @param accountMeterReMarriage
	 * @throws SchemaDataInvalidException
	 */
	private void populateWorkflowWithReply(
			GatewayMessagingWorkflow gatewayMessagingWorkflow,
			ConsertReply reply) throws SchemaDataInvalidException
	{
		final String replyAddress;
		final String replyEmail;
		if (reply != null)
		{
			WebServiceUtil.validate(reply, "asyncPublishEndpointUrl", 255,
					false);
			replyAddress = WebServiceUtil.killWhitespace(reply
					.getAsyncPublishEndpointUrl());
			WebServiceUtil.validate(reply, "emailAddress", 60, false);
			replyEmail = WebServiceUtil.killWhitespace(reply.getEmailAddress());
		} else
		{
			replyAddress = null;
			replyEmail = null;
		}
		gatewayMessagingWorkflow.setReplyAddress(replyAddress);
		gatewayMessagingWorkflow.setReplyEmail(replyEmail);
	}

	/**
	 * @param account
	 * @param oldAccount
	 * @param oldAccountNumber
	 * @param userCreated
	 * @param now
	 * @throws ProgramNotFoundException
	 * @throws NoSuchMethodException
	 * @throws InvocationTargetException
	 * @throws IllegalAccessException
	 */
	private void assignDefaultProgramIfNull(Account account,
			Account oldAccount, String userCreated, DateTime now)
			throws ProgramNotFoundException, IllegalAccessException,
			InvocationTargetException, NoSuchMethodException
	{

		Program defaultProgram = programBeanFacade.getDefaultProgram(account
				.getAccountId());
		if (defaultProgram == null)
		{
			Program systemDefaultProgram = null;

			if (oldAccount != null)
			{
				Program oldDefaultProgram = programBeanFacade
						.getDefaultProgram(oldAccount.getAccountId());
				if (oldDefaultProgram != null)
				{
					systemDefaultProgram = programBeanFacade
							.findProgramByProgramId(oldDefaultProgram
									.getSystemDefaultProgramId());
				}
			}

			if (systemDefaultProgram == null)
			{
				List<Account> existingAccounts = userAccountBeanFacade
						.getAccountByAccountNumberAndNotDeleted("Default");
				if (existingAccounts != null && !existingAccounts.isEmpty())
				{
					Account defaultAccount = existingAccounts.get(0);
					// Currently all production utilities only have one default
					// program. If a utility had more than one then it should
					// set the system default id on all the other default
					// programs the point to the true default.
					systemDefaultProgram = programBeanFacade
							.getDefaultProgram(defaultAccount.getAccountId());
					if (systemDefaultProgram != null
							&& systemDefaultProgram.getSystemDefaultProgramId() > 0)
					{
						systemDefaultProgram = programBeanFacade
								.findProgramByProgramId(systemDefaultProgram
										.getSystemDefaultProgramId());
					}
				}
			}

			if (systemDefaultProgram == null)
			{
				throw new ProgramNotFoundException(
						"Unable to find system default program for "
								+ (oldAccount != null ? "old account or " : "")
								+ "default account");
			}

			List<String> targetedProgramFields = getTargetedPropertyNames(Program.class);

			defaultProgram = new Program();
			for (String field : targetedProgramFields)
			{
				if (!"accountId".equals(field))
				{
					final Object o = PropertyUtils.getSimpleProperty(
							systemDefaultProgram, field);
					PropertyUtils.setSimpleProperty(defaultProgram, field, o);
				}
			}
			
			defaultProgram.setSystemDefaultProgramId(systemDefaultProgram
					.getProgramId());
			defaultProgram.setAccountId(account);
			defaultProgram.setDateCreated(now);
			defaultProgram.setDateModified(now);
			defaultProgram.setUserCreated(userCreated);
			defaultProgram.setUserModified(userCreated);

			programBeanFacade.createProgram(defaultProgram);

			List<String> targetedRangeFields = getTargetedPropertyNames(ProgramScheduleRange.class);
			Set<ProgramScheduleRange> programScheduleRangeSet = systemDefaultProgram
					.getProgramScheduleRangeCollection();
			for (ProgramScheduleRange defaultProgramScheduleRange : programScheduleRangeSet)
			{
				ProgramScheduleRange programScheduleRange = new ProgramScheduleRange();
				for (String field : targetedRangeFields)
				{
					if (!"programId".equals(field))
					{
						final Object o = PropertyUtils.getSimpleProperty(
								defaultProgramScheduleRange, field);
						PropertyUtils.setSimpleProperty(programScheduleRange,
								field, o);
					}
				}
				programScheduleRange.setDateCreated(now);
				programScheduleRange.setDateModified(now);
				programScheduleRange.setUserCreated(userCreated);
				programScheduleRange.setUserModified(userCreated);
				programScheduleRange.setProgramId(defaultProgram);
				programBeanFacade
						.createProgramScheduleRange(programScheduleRange);
			}
		}
		
		assignProgramTemplateProgramsIfNecessary(account, OpsCenterConstants.PROVISIONING_USER, now);

	
		
	}

	/**  Validate if we need to copy programs from Program Template
	 *   1) First device is provision for account which assigned ProgramTemplate
	 *   2) Program Template got changed in last 7 days */
	public void assignProgramTemplateProgramsIfNecessary(Account account, String userCreated, DateTime now) 
			throws IllegalAccessException, InvocationTargetException, NoSuchMethodException, ProgramNotFoundException{
		
		if(account.getProgramTemplateId() == null){
			log.debug("No Program Template is assigned to Account : "+ account.getAccountId() +" - " + account.getAccountNumber());
			return;
		}

		//rdrn-703 if at least 1 device is IP, stop here as we will not have any template TP for IP devices
		//so kick out...and go to add TP for default TP
		List <Esi> esiList =esiBeanFacade.getEsiByAccountId(account.getAccountId());
		List <EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(esiList.get(0).getEsiId());
		for (EsiDc dc:esiDcList) {
			if (dc.getDeviceTypeId().getDeviceTypeName()
					.equalsIgnoreCase(OpsCenterConstants.DC_IRRIGATION_PUMP)
					|| dc.getDeviceTypeId().getDeviceTypeName()
							.equalsIgnoreCase(
									OpsCenterConstants.DC_CROP_HEAT)
					|| dc.getDeviceTypeId().getDeviceTypeName()
							.equalsIgnoreCase(
									OpsCenterConstants.DC_GENERATOR)
					|| dc.getDeviceTypeId().getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_HVAC_SWITCH)
					|| dc.getDeviceTypeId().getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_DUAL_HEAT)
					|| dc.getDeviceTypeId().getDeviceTypeName().equalsIgnoreCase(OpsCenterConstants.DC_SINGLE_HEAT))
{
				log.debug("found an IP, go ahead and exit");
				return;
			}
		}

		ProgramTemplate prgmTmpl = account.getProgramTemplateId();

		List<Program> progList = programBeanFacade.getNonDefaultPrograms(account.getAccountId());
		if (progList == null || progList.size() <= 0)
		{
			log.debug("No Programs for this account, apply program template now");
		} else {
			DateTime nowMinusSeven = new DateTime().minusDays(7);
			if(prgmTmpl.getDateModified()!=null && prgmTmpl.getDateModified().isAfter(nowMinusSeven)){
				/* Delete all Non Default Programs if Program Template is updated in last 7 days*/
				UserProgramModel usrPrgModel = new UserProgramModel();
				usrPrgModel.setAccountId(account.getAccountId());
				usrPrgModel.setUserModified(userCreated);
				try{
					userProgramBean.deleteProgramsAndTP(usrPrgModel);
				}catch (Exception e){
					log.error(e.getMessage());
				}
			} else {
				log.debug("No change in Program Template " );
				return;
			}
		}
		
		Set<ProgramTemplateProgram> prgmTempPrgSet = prgmTmpl.getProgramTemplateProgramCollection();
		
		for(ProgramTemplateProgram prgmTempPrg : prgmTempPrgSet)
		{
			Program prgm = new Program();
			prgm.setName(prgmTempPrg.getName());
			prgm.setActiveFlag("1");
			prgm.setDeleteFlag("0");
			prgm.setSchedByRangeFlag(prgmTempPrg.getSchedByRangeFlag());
			prgm.setDefaultFlag("0");
			prgm.setAccountId(account);
			prgm.setDateCreated(now);
			prgm.setDateModified(now);
			prgm.setUserCreated(userCreated);
			prgm.setUserModified(userCreated);
			programBeanFacade.createProgram(prgm);

			/* Copy MonthDay Schedule data */
			List<String> targetedRangeFields = getTargetedPropertyNames(ProgramScheduleMonthDay.class);
			ProgramTemplateScheduleMonthDay prgmTmplSchedMonthDay = prgmTempPrg.getProgramTemplateScheduleMonthDay();
		
			if(prgmTmplSchedMonthDay != null) {
			ProgramScheduleMonthDay prgmSchedMonthDay = new ProgramScheduleMonthDay();
			for (String field : targetedRangeFields)
			{
				if (!"programId".equals(field))
				{
					try{
						final Object o = PropertyUtils.getSimpleProperty(prgmTmplSchedMonthDay, field);
						PropertyUtils.setSimpleProperty(prgmSchedMonthDay, field, o);
					}catch (Exception e){
						//e.printStackTrace();
					}
				}
			}
			prgmSchedMonthDay.setProgramId(prgm);
			prgmSchedMonthDay.setActiveFlag("1");
			prgmSchedMonthDay.setDeleteFlag("0");
			prgmSchedMonthDay.setDateCreated(now);
			prgmSchedMonthDay.setDateModified(now);
			prgmSchedMonthDay.setUserCreated(userCreated);
			prgmSchedMonthDay.setUserModified(userCreated);
			
			programBeanFacade.createProgramScheduleMonthDay(prgmSchedMonthDay);
			}
			
			List<String> targetedScheduleRangeFields = getTargetedPropertyNames(ProgramScheduleRange.class);
			Set<ProgramTemplateScheduleRange> prgmTmplSchedRange = prgmTempPrg.getProgramTemplateScheduleRangeCollection();
			if(prgmTmplSchedRange != null && !prgmTmplSchedRange.isEmpty()) 
			{
			for (ProgramTemplateScheduleRange programTemplateScheduleRange : prgmTmplSchedRange)
			{
				ProgramScheduleRange programScheduleRange = new ProgramScheduleRange();
				for (String field : targetedScheduleRangeFields)
				{
					if (!"programId".equals(field))
					{
						final Object o = PropertyUtils.getSimpleProperty(
								programTemplateScheduleRange, field);
						PropertyUtils.setSimpleProperty(programScheduleRange,
								field, o);
					}
				}
				programScheduleRange.setProgramId(prgm);
				programScheduleRange.setActiveFlag("1");
				programScheduleRange.setDeleteFlag("0");
				programScheduleRange.setDateCreated(now);
				programScheduleRange.setDateModified(now);
				programScheduleRange.setUserCreated(userCreated);
				programScheduleRange.setUserModified(userCreated);
				programBeanFacade
						.createProgramScheduleRange(programScheduleRange);
			}
		}
		}
			
	}
	
	/**
	 * @param oldAccount
	 * @param oldEsi
	 * @param now
	 * @param esiDcList
	 * @param esiTstatList
	 */
	private void flagDevicesAndProgramDataAsDeletedOnOldEsi(boolean flagMasterAsDeleted, ProvisioningEsiBean provEsiBean,
			RemovalCode removalReasonCode ,String removalNetsuiteTicket) 
	{
		
		Esi oldEsi = provEsiBean.getEsi();
 		List<EsiDc> esiDcList = provEsiBean.getEsiDcList();
		List<EsiTstat> esiTstatList = provEsiBean.getEsiTstatList(); 
		List<EsiLcs> esiLcsList = provEsiBean.getEsiLcsList();
		List<EsiTstatWallPlate> esiTstatWallPlateList = provEsiBean.getEsiTstatWallPlateList();
 		List<TstatDcMap> tstatDcMapList = provEsiBean.getTstatDcMapList();
		String user = provEsiBean.getUser(); 
		DateTime now = provEsiBean.getNow(); 
				
		Account oldAccount = oldEsi.getAccountId();
		flagEsiAsDeleted(oldEsi, now, removalReasonCode, removalNetsuiteTicket);

		 
		for (EsiDc esiDc : esiDcList)
		{
			flagAsDeleted(esiDc, flagMasterAsDeleted, now, removalReasonCode,
					removalNetsuiteTicket);
		}

		for (EsiTstat esiTstat : esiTstatList)
		{
			flagAsDeleted(esiTstat, flagMasterAsDeleted, now,
					removalReasonCode, removalNetsuiteTicket);
		}

		for (EsiLcs esiLcs : esiLcsList)
		{
			flagAsDeleted(esiLcs, flagMasterAsDeleted, now, removalReasonCode,
					removalNetsuiteTicket);
		}

		for (EsiTstatWallPlate esiTstatWallplate : esiTstatWallPlateList)
		{
			flagAsDeleted(esiTstatWallplate, flagMasterAsDeleted, now,
					removalReasonCode, removalNetsuiteTicket);
		}

		// This enables the reversal
		for (TstatDcMap tstatDcMap : tstatDcMapList)
		{
			flagAsDeleted(tstatDcMap);
		}

		// KRMT-5109
		programBeanFacade.updateDcTransitionPointDeleteFlagByAccountId(
				oldAccount.getAccountId(), user, now);
		programBeanFacade.updateProgramScheduleMonthDayDeleteFlagByAccountId(
				oldAccount.getAccountId(), user, now);
		programBeanFacade.updateProgramScheduleRangeDeleteFlagByAccountId(
				oldAccount.getAccountId(), user, now);
		programBeanFacade.updateTstatTransitionPointDeleteFlagByAccountId(
				oldAccount.getAccountId(), user, now);
		programBeanFacade.updateProgramDeleteFlagByAccountId(
				oldAccount.getAccountId(), user, now);
	}

	/**
	 * This should be called when all equipment except the gateway has been removed from an ESI
	 * @param oldEsi
	 * @param now
	 * @return
	 */
	private void flagEsiAsDeleted(Esi oldEsi, DateTime now, RemovalCode removalReasonCode,
			String removalNetsuiteTicket)
	{
		oldEsi.setDeleteFlag(OpsCenterConstants.TRUE);
		Account oldAccount = oldEsi.getAccountId();
		oldAccount.setConvertVppFlag(OpsCenterConstants.FALSE);
		cacheManager.removeGatewayAndEsiData(oldEsi);
		final EsiGateway esiGatewayId = oldEsi.getEsiGatewayId();
		esiGatewayId.setDeleteFlag(OpsCenterConstants.TRUE);
		esiGatewayId.setDateUpdated(now);
		
		if (oldEsi.getNetworkDeliveryId() != 2)
		{
			Gateway gateway = esiGatewayId.getGatewayId();
			gateway.setRemovalCodeId(removalReasonCode);
			gateway.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		}
	}

	private void flagAsDeleted(TstatDcMap tstatDcMap)
	{
		tstatDcMap.getTstatDcGroupId().setEsiId(null);
	}

	private void flagAsDeleted(EsiTstatWallPlate esiTstatWallplate,
			boolean flagMasterAsDeleted, DateTime now,
			RemovalCode removalReasonCode, String removalNetsuiteTicket)
	{
		esiTstatWallplate.setDeleteFlag(OpsCenterConstants.TRUE);
		esiTstatWallplate.setDateUpdated(now);

		if (flagMasterAsDeleted)
		{
			TstatWallPlate tstatWallPlate = esiTstatWallplate
					.getTstatWallPlateId();
			tstatWallPlate.setEsiId(null);
			tstatWallPlate.setDateModified(now);
			tstatWallPlate.setRemovalCodeId(removalReasonCode);
			tstatWallPlate.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		}
	}

	private void flagAsDeleted(EsiDc esiDc, boolean flagMasterAsDeleted,
			DateTime now, RemovalCode removalReasonCode,
			String removalNetsuiteTicket)
	{
		esiDc.setDeleteFlag(OpsCenterConstants.TRUE);
		esiDc.setDateUpdated(now);

		if (flagMasterAsDeleted)
		{
			Dc dc = esiDc.getDcId();
			dc.setEsiId(null);
			dc.setDateModified(now);
			if (!"1".equals(dc.getSerialNo()))
			{
				dc.setRemovalCodeId(removalReasonCode);
				dc.setRemovalNetsuiteTicket(removalNetsuiteTicket);
			}
		}
	}

	private void flagAsDeleted(EsiLcs esiLcs, boolean flagMasterAsDeleted,
			DateTime now, RemovalCode removalReasonCode,
			String removalNetsuiteTicket)
	{
		esiLcs.setDeleteFlag(OpsCenterConstants.TRUE);
		esiLcs.setDateUpdated(now);

		if (flagMasterAsDeleted)
		{
			Lcs lcs = esiLcs.getLcsId();
			lcs.setEsiId(null);
			lcs.setDateModified(now);
			lcs.setRemovalCodeId(removalReasonCode);
			lcs.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		}
	}

	private void flagAsDeleted(EsiTstat esiTstat, boolean flagMasterAsDeleted,
			DateTime now, RemovalCode removalReasonCode,
			String removalNetsuiteTicket)
	{
		esiTstat.setDeleteFlag(OpsCenterConstants.TRUE);
		esiTstat.setDateUpdated(now);

		if (flagMasterAsDeleted)
		{
			Tstat tstat = esiTstat.getTstatId();
			tstat.setEsiId(null);
			tstat.setDateModified(now);
			tstat.setRemovalCodeId(removalReasonCode);
			tstat.setRemovalNetsuiteTicket(removalNetsuiteTicket);

			TstatWallPlate wallPlate = esiTstat.getTstatWallPlate();
			if (wallPlate != null)
			{
				wallPlate.setEsiId(null);
				wallPlate.setDateModified(now);
				wallPlate.setRemovalCodeId(removalReasonCode);
				wallPlate.setRemovalNetsuiteTicket(removalNetsuiteTicket);
			}
		}
	}

	/**
	 * @param e
	 * @param oldEsi
	 * @param esiDcList
	 * @param esiTstatList
	 * @param esiLcsList
	 * @param esiTstatWallPlateList
	 * @param esiZigbeeList
	 * @param now
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodExcept
	 * @throws ProgramNotFoundException
	 *             ion
	 */
	private void copyDevicesAndProgramDataToNewEsi(Esi e, Esi oldEsi,
			Collection<EsiDc> esiDcList, Collection<EsiTstat> esiTstatList,
			Collection<EsiLcs> esiLcsList,
			Collection<EsiTstatWallPlate> esiTstatWallPlateList, String user, DateTime now)
			throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException
	{

		// Using PropertyUtils to copy EsiDc, EsiTstat, TstatDcGroup, TstatDcMap
		// from old Esi to new Esi
		// Setting delete flags on all the old stuff esi_gw, esi, esi_em,
		// esi_dc, & esi_tstat
		Map<EsiDc, EsiDc> esiDcMap = new HashMap<EsiDc, EsiDc>();
		Map<EsiTstat, EsiTstat> esiTstatMap = new HashMap<EsiTstat, EsiTstat>();

		List<String> targetedEsiDcFields = getTargetedPropertyNames(EsiDc.class);
		for (EsiDc esiDc : esiDcList)
		{
			EsiDc newEsiDc = new EsiDc();
			for (String field : targetedEsiDcFields)
			{
				if (!"esiId".equals(field))
				{
					final Object o = PropertyUtils.getSimpleProperty(esiDc,
							field);
					PropertyUtils.setSimpleProperty(newEsiDc, field, o);
				}
			}
			Dc dc = newEsiDc.getDcId();
			dc.setEsiId(e);
			dc.setDateModified(now);
			// dc.setDeviceMqId(deviceMqId); //This value is not changing
			// dc.setDeviceTypeId(deviceTypeId) //This value is not changing
			newEsiDc.setActiveFlag(OpsCenterConstants.TRUE);
			newEsiDc.setEsiId(e);
			newEsiDc.setDateCreated(now);
			newEsiDc.setDateUpdated(now);
			esiBeanFacade.createEsiDc(newEsiDc);
			esiDcMap.put(esiDc, newEsiDc);
		}

		List<String> targetedEsiTstatFields = getTargetedPropertyNames(EsiTstat.class);
		for (EsiTstat esiTstat : esiTstatList)
		{
			EsiTstat newEsiTstat = new EsiTstat();
			for (String field : targetedEsiTstatFields)
			{
				if (!"esiId".equals(field))
				{
					final Object o;
					final Object tmp = PropertyUtils.getSimpleProperty(
							esiTstat, field);
					if ("esiDcId".equals(field))
					{
						o = esiDcMap.get(tmp);
					} else
					{
						o = tmp;
					}
					PropertyUtils.setSimpleProperty(newEsiTstat, field, o);
				}
			}
			Tstat tstat = newEsiTstat.getTstatId();
			tstat.setEsiId(e);
			tstat.setDateModified(now);

			TstatWallPlate wallPlate = esiTstat.getTstatWallPlate();
			if (wallPlate != null)
			{
				wallPlate.setEsiId(e);
				wallPlate.setDateModified(now);
			}

			newEsiTstat.setEsiId(e);
			newEsiTstat.setDateCreated(now);
			newEsiTstat.setDateUpdated(now);
			newEsiTstat.setActiveFlag(OpsCenterConstants.TRUE);
			esiBeanFacade.createEsiTstat(newEsiTstat);
			esiTstatMap.put(esiTstat, newEsiTstat);
		}

		List<String> targetedEsiLcsFields = getTargetedPropertyNames(EsiLcs.class);
		for (EsiLcs esiLcs : esiLcsList)
		{
			EsiLcs newEsiLcs = new EsiLcs();
			for (String field : targetedEsiLcsFields)
			{
				if (!"esiLcsId".equals(field))
				{
					final Object o = PropertyUtils.getSimpleProperty(esiLcs,
							field);
					PropertyUtils.setSimpleProperty(newEsiLcs, field, o);
				}
			}

			Lcs lcs = newEsiLcs.getLcsId();
			lcs.setEsiId(e);
			lcs.setDateModified(now);

			newEsiLcs.setEsiId(e);
			newEsiLcs.setDateCreated(now);
			newEsiLcs.setDateUpdated(now);
			esiBeanFacade.createEsiLcs(newEsiLcs);
		}

		final Set<TstatDcGroup> tstatDcGroupCollection = oldEsi
				.getTstatDcGroupCollection();
		List<String> targetedTstatDcGroupFields = getTargetedPropertyNames(TstatDcGroup.class);
		List<String> targetedTstatDcMapFields = getTargetedPropertyNames(TstatDcMap.class);
		for (TstatDcGroup tstatDcGroup : tstatDcGroupCollection)
		{
			final Set<TstatDcMap> tstatDcMapCollection = tstatDcGroup
					.getTstatDcMapCollection();
			if (tstatDcMapCollection != null && !tstatDcMapCollection.isEmpty())
			{
				TstatDcGroup newTstatDcGroup = new TstatDcGroup();
				for (String field : targetedTstatDcGroupFields)
				{
					if (!"esiId".equals(field))
					{
						final Object o = PropertyUtils.getSimpleProperty(
								tstatDcGroup, field);
						PropertyUtils.setSimpleProperty(newTstatDcGroup, field,
								o);
					}
				}
				newTstatDcGroup.setEsiId(e);
				esiBeanFacade.createTstatDcGroup(newTstatDcGroup);

				for (TstatDcMap tstatDcMap : tstatDcMapCollection)
				{
					TstatDcMap newTstatDcMap = new TstatDcMap();
					for (String mapfield : targetedTstatDcMapFields)
					{
						if (!"tstatDcGroupId".equals(mapfield))
						{
							final Object o;
							final Object tmp = PropertyUtils.getSimpleProperty(
									tstatDcMap, mapfield);
							if ("esiDcId".equals(mapfield))
							{
								o = esiDcMap.get(tmp);
							} else if ("esiTstatId".equals(mapfield))
							{
								o = esiTstatMap.get(tmp);
							} else
							{
								o = tmp;
							}
							PropertyUtils.setSimpleProperty(newTstatDcMap,
									mapfield, o);
						}

					}
					if(newTstatDcMap.getEsiDcId()==null || newTstatDcMap.getEsiTstatId()==null){
						continue;
					}
					newTstatDcMap.setTstatDcGroupId(newTstatDcGroup);
					esiBeanFacade.createTstatDcMap(newTstatDcMap);

				}
			}
		}

		List<String> targetedEsiTstatWallPlateFields = getTargetedPropertyNames(EsiTstatWallPlate.class);
		for (EsiTstatWallPlate esiTstatWallPlate : esiTstatWallPlateList)
		{
			EsiTstatWallPlate newEsiTstatWallPlate = new EsiTstatWallPlate();
			for (String field : targetedEsiTstatWallPlateFields)
			{
				if (!"esiTstatWallPlateId".equals(field))
				{
					final Object o = PropertyUtils.getSimpleProperty(
							esiTstatWallPlate, field);
					PropertyUtils.setSimpleProperty(newEsiTstatWallPlate,
							field, o);
				}
			}

			TstatWallPlate tstatWallPlate = newEsiTstatWallPlate
					.getTstatWallPlateId();
			tstatWallPlate.setEsiId(e);
			tstatWallPlate.setDateModified(now);

			newEsiTstatWallPlate.setEsiId(e);
			newEsiTstatWallPlate.setDateCreated(now);
			newEsiTstatWallPlate.setDateUpdated(now);
			esiBeanFacade.createEsiTstatWallPlate(newEsiTstatWallPlate);
		}

		
		// // DEV-272: WSI, MoveOut/MoveIn Reversal: Consumer Portal Energy
		// Snapshot data does not display after reversal. Suggest reversal
		// should re-use previous ESI objects and undelete them.
		// // KRMT-4671 - Don't need the default program for AMI only
		// if (!esiDcList.isEmpty()) {
		//
		// ArrayList<Tstat> tstats = new ArrayList<Tstat>();
		// for (EsiTstat esiTstat : esiTstatList) {
		// tstats.add(esiTstat.getTstatId());
		// }
		// ArrayList<Dc> dcs = new ArrayList<Dc>();
		// for (EsiDc esiDc : esiDcList) {
		// dcs.add(esiDc.getDcId());
		// }
		//
		// // Handling reversal as an undelete now
		// final boolean hasDefault = reversePrograms(e, esiDcMap.values(),
		// esiTstatMap.values(), user, now);
		//
		// if (!hasDefault) {
		// assignDefaultProgramIfNull(e.getAccountId(), oldEsi.getAccountId(),
		// user, now);
		// }
		// }
	}

	/**
	 * @param theClass
	 * @return
	 */
	private List<String> getTargetedPropertyNames(Class<?> theClass)
	{
		return PersistenceUtilities.getTargetedPropertyNames(theClass);
	}

	@Override
	public ConsertAccountProvisioningResponse electricMeterProvision(
			ConsertAccountMeterMarriage accountMeterMarriage)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		if (accountMeterMarriage == null)
		{
			return null;
		}

		final ConsertCompoundAccountKey compoundAccountKey = accountMeterMarriage
				.getCompoundAccountKey();

		final String accountNumber = accountMeterMarriage.getAccountNumber();
		final String electricMeterNumber = accountMeterMarriage
				.getElectricMeterNumber();

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ELECTRICMETER_PROVISION));

		String userCreated = accountMeterMarriage.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		gatewayMessagingWorkflow.setUsrCreated(userCreated);

		Exception exception = null;
		try
		{

			populateWorkflowWithReply(gatewayMessagingWorkflow,
					accountMeterMarriage.getReply());

			Esi e = consertAccountProvisioning.electricMeterProvisionPersist(
					accountNumber, compoundAccountKey, electricMeterNumber);

			gatewayMessagingWorkflow.setEsiId(e);

		} catch (Exception e1)
		{
			exception = e1;

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to ElectricMeter_Provision", e1);

			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();

			ConsertErrorById error2 = new ConsertErrorById();
			error2.setObjectType("electricMeterNumber");
			error2.setObjectId(electricMeterNumber);
			errorObjectDetails.add(error2);

			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);

			response.setError(consertCreateUpdateError);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}
		response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
				: ConsertAccountProvisioningResponseStatus.ERROR);
		// TODO use work manager to start in background
		gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow,
				exception);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));

		return response;
	}


	/**
	 * @param accountNumber
	 * @param electricMeterNumber
	 * @param eg
	 * @param e
	 * @param eem
	 * @throws ElectricMeterNotFoundException
	 * @throws GatewayNotFoundException
	 * @throws EsiElectricMeterAlreadyExistsException
	 * @throws EsiGatewayAlreadyExistsException
	 * @return Either Esi or EsiElectricMeter
	 */
	private Object marryMe(Account account,
			final String standaloneGwSerialNumber,
			final ConsertElectricMeter electricMeter, final Esi oldEsi,
			final Boolean isGridStream) throws AbstractOpsCenterException
	{

		// DEV-1052: Provisioning - Reuse of Accounts - CE Default group is not
		// associated to the account when account is reused.
		userAccountBeanFacade.defaultCeGroups(account);
		// active flag gets set to true after the initial config push
		// final String activeFlag;
		final boolean isProvision;
		if (oldEsi != null)
		{
			// activeFlag = oldEsi.getEsiGatewayId().getActiveFlag();
			isProvision = false;
		} else
		{
			// activeFlag = OpsCenterConstants.FALSE;
			isProvision = true;
		}

		DateTime dateCreated = new DateTime();

		final String electricMeterNumber = electricMeter != null ? WebServiceUtil
				.killWhitespace(electricMeter.getMeterSerialNumber()) : null;
		final String standaloneGatewaySerialNumber = WebServiceUtil
				.killWhitespace(standaloneGwSerialNumber);

		Esi existingEsi = null;
		if (isProvision)
		{
			List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
					.getAccountId());
			existingEsi = esiList == null || esiList.isEmpty() ? null : esiList
					.get(0);
		}
		
		 

		if (isGridStream == null || !isGridStream.booleanValue())
		{
			if (electricMeterNumber != null
					&& standaloneGatewaySerialNumber != null)
			{
				throw new ElectricMeterNotFoundException(
						DefaultResources.ACC_ERR_CODE_ELECTRIC_METER_NOT_FOUND,
						"Illegal argument electricMeterNumber and standaloneGatewaySerialNumber cannot both be populated");
			}
		}  

 		final Gateway gateway;

		if (isGridStream != null && isGridStream.booleanValue())
		{
			gateway = deviceBeanFacade.getVirtualGateway();
		} else
		{
			gateway = deviceBeanFacade
					.getGatewayBySerialNo(standaloneGatewaySerialNumber);
			if (gateway == null
					|| WebServiceUtil
							.killWhitespace(gateway.getMeterSerialNo()) != null)
			{
				throw new GatewayNotFoundException(
						DefaultResources.ACC_ERR_CODE_GATEWAY_NOT_FOUND,
						"Unable to find a gateway for standaloneGatewaySerialNumber",
						standaloneGatewaySerialNumber);
			}
		}

		if (isGridStream == null || !isGridStream)
		{
			List<ProvStatusFlags> provFlagsList = genericFacade
					.getProvStatusFlagsByGwId(gateway.getGatewayId());
			final ProvStatusFlags provStatusFlags = provFlagsList != null
					&& !provFlagsList.isEmpty() ? provFlagsList.get(0) : null;

			if (provStatusFlags == null
					|| !OpsCenterConstants.TRUE.equals(provStatusFlags
							.getActiveNwFlag()))
			{
				throw new GatewayNotFoundException(
						DefaultResources.ACC_ERR_CODE_GATEWAY_NOT_FOUND,
						"Unable to find a standalone/associated gateway that is active on the network.");
			}
		}		

		final EsiGateway eg;
		final Esi e;
 
		if (existingEsi != null)
		{
			// throw new
			// EsiAlreadyExistsException(DefaultResources.ACC_ERR_CODE_ESI_ALREADY_EXISTS,
			// "An esi alreadys exists for account # "+ accountNumber);
			e = existingEsi;
			eg = existingEsi.getEsiGatewayId();
			Object em = null;
			if (em != null)
			{
			} 
			 
		} else
		{
			e = new Esi();
			
			eg = newEsiGateway(gateway, dateCreated);

			esiBeanFacade.createEsiGateway(eg);

			e.setAccountId(account);
			e.setActEnergyConsumed(0);
			e.setActiveFlag(OpsCenterConstants.TRUE);
			e.setBundlingPeriodicReadsFlag(OpsCenterConstants.FALSE);
			e.setDeleteFlag(OpsCenterConstants.FALSE);
			e.setEsiGatewayId(eg);
			e.setEsiMqId(1);
			// e.setLastMqRecdTime(lastMqRecdTime);
			// default 1 == INACTIVE
			ManageMode defaultManageMode = esiBeanFacade
					.getRefManageModeByManageModeId(1);
			e.setManageModeId(defaultManageMode);
			e.setPrevManageModeId(defaultManageMode);
			e.setOutageFlag(OpsCenterConstants.FALSE);
			e.setRoundRobinCount(0);
			e.setSequenceId(0);
			e.setNetworkDeliveryId(gateway.getDeliveryNetworkId());
			esiBeanFacade.createEsi(e);
		}

		return e;
	}

	@Override
	public ConsertAccountProvisioningResponse diagnosticBeginFullForAccount(
			ConsertDiagnosticRequest request)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		String accountNumber = request.getAccountNumber();
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_DIAGNOSTICS));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_DIAGNOSTIC_BEGINFULLFORACCOUNT));

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		gatewayMessagingWorkflow.setUsrCreated(userCreated);

		Exception exception = null;

		try
		{

			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());

			CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
			final AccountPartsModel accountParts;
			try
			{
				accountParts = compoundAccountKeyUtility.getAccountParts();
			} catch (Exception e)
			{
				// Compound Account Key Error
				throw new CompoundAccountKeyException("Unexpected Error", e);
			}
			final Account account = getAccount(accountNumber,
					compoundAccountKey, accountParts);

			List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
					.getAccountId());
			Esi esi = esiList == null || esiList.isEmpty() ? null : esiList
					.get(0);

			if (esi == null)
			{
				throw new EsiNotFoundException(
						DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"Account not provisioned ");
			}

			gatewayMessagingWorkflow.setEsiId(esi);

		} catch (Exception e)
		{
			exception = e;

			AbstractOpsCenterException abstractOpsCenterException = null;
			final String errorCode;
			if (e instanceof ConfigurationException_Exception)
			{
				errorCode = ((ConfigurationException_Exception) e)
						.getFaultInfo().getErrorCode();
			} else if (e instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
			}

			log.error("Failed to Diagnostic_BeginFullForAccount", e);

			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);

			response.setError(consertCreateUpdateError);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}
		response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
				: ConsertAccountProvisioningResponseStatus.ERROR);
		gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow,
				exception);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	@Override
	public ConsertDiagnostic diagnosticFind(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey)
	{
		TenantPropertyUtil.getTenantId(wsctx);

		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
		final AccountPartsModel accountParts;
		try
		{
			accountParts = compoundAccountKeyUtility.getAccountParts();
		} catch (Exception e)
		{
			// Compound Account Key Error
			throw new RuntimeException(e);
		}
		ExternalAccountXRef externalAccountXRef = null;
		final Account account;
		if (compoundAccountKey != null && accountParts.isCompoundKeyEnabled())
		{
			try
			{
				List<ExternalAccountXRef> externalAccountXRefList = getExternalAccountXrefList(
						accountParts, compoundAccountKey);
				if (externalAccountXRefList.isEmpty())
				{
					account = null;
				} else
				{
					externalAccountXRef = externalAccountXRefList.get(0);
					account = externalAccountXRef.getAccount();
				}

			} catch (Exception e)
			{
				throw new RuntimeException(e);
			}
		} else
		{

			List<Account> accountByAccountNoList = userAccountBeanFacade
					.getAccountByAccountNumberAndNotDeleted(accountNumber);

			account = accountByAccountNoList.isEmpty() ? null
					: accountByAccountNoList.get(0);

			if (account != null && accountParts.isCompoundKeyEnabled())
			{ // 2013-03-25 SRR: Fixed NPE when account null
				externalAccountXRef = userAccountBeanFacade
						.findAccountXRefByAccountId(account.getAccountId());
			}
		}

		if (account == null)
		{
			return null;
		}

		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
				.getAccountId());
		Esi esi = esiList == null || esiList.isEmpty() ? null : esiList.get(0);

		if (esi == null)
		{
			return null;
		}

		DiagnosticResponse diagnosticResponse = deviceHealthCheckBeanFacade
				.getLastDiagnosticResponseByGatewayMqIdAndEsiMqId(esi
						.getEsiGatewayId().getGatewayMqId(), esi.getEsiMqId());

		if (diagnosticResponse == null)
		{
			return null;
		}

		ConsertDiagnostic consertDiagnostic = new ConsertDiagnostic();
		if (externalAccountXRef != null)
		{
			compoundAccountKey = new ConsertCompoundAccountKey();
			compoundAccountKey.setBillingAccountNumber(externalAccountXRef
					.getBillingAccountNumber());
			compoundAccountKey.setMeterLocationNumber(externalAccountXRef
					.getMeterLocationNumber());
			compoundAccountKey.setPremiseNumber(externalAccountXRef
					.getPremiseNumber());
			compoundAccountKey.setUtilityNumber(externalAccountXRef
					.getUtilityNumber());
			consertDiagnostic.setCompoundAccountKey(compoundAccountKey);
			consertDiagnostic.setAccountNumber(account.getAccountNumber());
		} else
		{
			consertDiagnostic.setAccountNumber(accountNumber);
		}
		consertDiagnostic.setTrackingId(diagnosticResponse
				.getDiagnosticResponseId());

		consertDiagnostic.setCompletedOn(datatypeFactory
				.newXMLGregorianCalendar(diagnosticResponse
						.getCompletedTimestamp().toGregorianCalendar()));
		consertDiagnostic.setSuccess("255".equals(diagnosticResponse
				.getResultCode())); // 0xFF
									// to
									// decimal
									// to
									// string

		final List<ConsertDiagnosticDevice> diagnosticDeviceList = consertDiagnostic
				.getDiagnosticDevice();

		Map<Integer, DiagnosticResponseDevice> deviceByMqId = new HashMap<Integer, DiagnosticResponseDevice>();
		final Set<DiagnosticResponseDevice> diagnosticResponseDeviceCollection = diagnosticResponse
				.getDiagnosticResponseDeviceCollection();
		for (DiagnosticResponseDevice diagnosticResponseDevice : diagnosticResponseDeviceCollection)
		{
			deviceByMqId.put(diagnosticResponseDevice.getDeviceMqId(),
					diagnosticResponseDevice);
		}

		 
		List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(esi.getEsiId());
		for (EsiDc esiDc : esiDcList)
		{
			// if real
			if (!OpsCenterConstants.TRUE.equals(esiDc.getVirtualFlag()))
			{
				DiagnosticResponseDevice diagnosticResponseDevice = deviceByMqId
						.get(esiDc.getDeviceMqId());
				final String serialNo = esiDc.getDcId().getSerialNo();
				OpsCenterConstants.DeviceType deviceType = OpsCenterConstants.DeviceType
						.fromId(esiDc.getDeviceTypeId().getDeviceTypeId());
				final DiagnosticDeviceType diagnosticDeviceType = DiagnosticDeviceType
						.fromValue(deviceType.getWsiValue());
				addDevice(diagnosticDeviceList, diagnosticResponseDevice,
						serialNo, esiDc.getName(), diagnosticDeviceType);
			}
		}
		List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(esi
				.getEsiId());
		for (EsiTstat esiTstat : esiTstatList)
		{
			DiagnosticResponseDevice diagnosticResponseDevice = deviceByMqId
					.get(esiTstat.getDeviceMqId());
			final String serialNo = esiTstat.getTstatId().getSerialNo();
			addDevice(diagnosticDeviceList, diagnosticResponseDevice, serialNo,
					esiTstat.getName(), DiagnosticDeviceType.THERMOSTAT);
		}

		consertDiagnostic.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return consertDiagnostic;

	}

	/**
	 * @param compoundAccountKey
	 * @return
	 * @throws Exception
	 */
	private List<ExternalAccountXRef> getExternalAccountXrefList(
			AccountPartsModel accountParts,
			ConsertCompoundAccountKey compoundAccountKey)
			throws AbstractOpsCenterException
	{
		String billingAccountNumber = null;
		String premiseNumber = null;
		String meterLocationNumber = null;
		String utilityNumber = null;

		final List<AccountPartDefinitionModel> accountPartDefinitions = accountParts
				.getAccountPartDefinitions();

		if (!accountParts.isCompoundKeyEnabled())
		{
			throw new CompoundAccountKeyNotEnabled(
					"The Compound Account Key Feature is not currently enabled");
		}

		for (AccountPartDefinitionModel accountPartDefinitionModel : accountPartDefinitions)
		{
			if (OpsCenterConstants.COMPOUND_KEY_BILLING_ACCOUNT
					.equals(accountPartDefinitionModel
							.getAccountPartDefinitionId()))
			{
				billingAccountNumber = WebServiceUtil
						.killWhitespace(compoundAccountKey
								.getBillingAccountNumber());
			} else if (OpsCenterConstants.COMPOUND_KEY_PREMISE_NUMBER
					.equals(accountPartDefinitionModel
							.getAccountPartDefinitionId()))
			{
				premiseNumber = WebServiceUtil
						.killWhitespace(compoundAccountKey.getPremiseNumber());
			} else if (OpsCenterConstants.COMPOUND_KEY_METER_LOCATION
					.equals(accountPartDefinitionModel
							.getAccountPartDefinitionId()))
			{
				meterLocationNumber = WebServiceUtil
						.killWhitespace(compoundAccountKey
								.getMeterLocationNumber());
			} else if (OpsCenterConstants.COMPOUND_KEY_UTILITY_NUMBER
					.equals(accountPartDefinitionModel
							.getAccountPartDefinitionId()))
			{
				utilityNumber = WebServiceUtil
						.killWhitespace(compoundAccountKey.getUtilityNumber());
			}
		}

		if (billingAccountNumber == null && premiseNumber == null
				&& meterLocationNumber == null && utilityNumber == null)
		{
			throw new CompoundAccountKeyNotUniqueException(
					"Provide at least one enabled Compound Account Key");
		}

		return userAccountBeanFacade
				.getAccountXRefByNonNullBillingAccountNumberPremiseNumberMeterLocationNumberUtilityNumber(
						billingAccountNumber, premiseNumber,
						meterLocationNumber, utilityNumber);
	}

	/**
	 * @param diagnosticDeviceList
	 * @param diagnosticResponseDevice
	 * @param serialNo
	 */
	private void addDevice(
			final List<ConsertDiagnosticDevice> diagnosticDeviceList,
			DiagnosticResponseDevice diagnosticResponseDevice, String serialNo,
			String name, DiagnosticDeviceType deviceType)
	{
		if (diagnosticResponseDevice != null)
		{
			ConsertDiagnosticDevice consertDiagnosticDevice = new ConsertDiagnosticDevice();
			final int type = diagnosticResponseDevice.getIndicatorTypeId();
			final DiagnosticResultType diagnosticResulType;
			if (type == 1)
			{
				diagnosticResulType = DiagnosticResultType.TEXT;
				consertDiagnosticDevice.setText(diagnosticResponseDevice
						.getIndicatorText());
			} else if (type == 2)
			{
				diagnosticResulType = DiagnosticResultType.LED;
				final Set<DiagnosticResponseDeviceLed> diagnosticResponseDeviceLedCollection = diagnosticResponseDevice
						.getDiagnosticResponseDeviceLedCollection();
				if (diagnosticResponseDeviceLedCollection != null)
				{
					final List<ConsertDiagnosticDeviceLed> ledList = consertDiagnosticDevice
							.getLed();
					for (DiagnosticResponseDeviceLed diagnosticResponseDeviceLed : diagnosticResponseDeviceLedCollection)
					{
						ConsertDiagnosticDeviceLed consertDiagnosticDeviceLed = new ConsertDiagnosticDeviceLed();
						consertDiagnosticDeviceLed
								.setLedNo(diagnosticResponseDeviceLed
										.getLedNo());
						consertDiagnosticDeviceLed
								.setResult(diagnosticResponseDeviceLed
										.getLedColor());
						if (diagnosticResponseDeviceLed.getLedNo() == 2)
						{
							consertDiagnosticDeviceLed
									.setResultType(DiagnosticLedResultType.BLINK_COUNT);
						} else
						{
							consertDiagnosticDeviceLed
									.setResultType(DiagnosticLedResultType.STATE);
						}
						ledList.add(consertDiagnosticDeviceLed);
					}
				}
			} else
			{
				diagnosticResulType = DiagnosticResultType.NONE;
			}
			consertDiagnosticDevice.setName(name);
			consertDiagnosticDevice.setDiagnosticDeviceType(deviceType);
			consertDiagnosticDevice
					.setDiagnosticResultType(diagnosticResulType);
			consertDiagnosticDevice.setHomePlugRssi(diagnosticResponseDevice
					.getHpRssi());
			consertDiagnosticDevice.setSerialNumber(serialNo);
			consertDiagnosticDevice.setZigBeeRssi(diagnosticResponseDevice
					.getZigbeeRssi());
			diagnosticDeviceList.add(consertDiagnosticDevice);
		}
	}

	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioning#electricMeterSwap(com.consert.service.ns.xml.ConsertMeterSwapRequest)
	 */
	@Override
	public ConsertAccountProvisioningResponse electricMeterSwap(
			ConsertMeterSwapRequest request)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		
		String accountNumber = request.getAccountNumber();
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();
		String electricMeterNumber = request.getElectricMeterNumber();
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ELECTRICMETER_SWAP));

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		gatewayMessagingWorkflow.setUsrCreated(userCreated);

		Exception exception = null;

		try
		{

			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());

			Esi esi = consertAccountProvisioning
					.electricMeterGatewaySwapPersist(accountNumber,
							compoundAccountKey, electricMeterNumber, null);

			gatewayMessagingWorkflow.setEsiId(esi);

		} catch (Exception e1)
		{
			exception = e1;

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to ElectricMeter_Swap", e1);

			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();

			ConsertErrorById error2 = new ConsertErrorById();
			error2.setObjectType("electricMeterNumber");
			error2.setObjectId(electricMeterNumber);
			errorObjectDetails.add(error2);

			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);

			response.setError(consertCreateUpdateError);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}
		response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
				: ConsertAccountProvisioningResponseStatus.ERROR);
		gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow,
				exception);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	/**
	 * @param accountNumber
	 * @param electricMeterNumber
	 * @return
	 * @throws ConfigurationException_Exception
	 * @throws AbstractOpsCenterException
	 */
	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public Esi electricMeterGatewaySwapPersist(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey,
			String electricMeterNumber, String standaloneGatewaySerialNumber)
			throws AbstractOpsCenterException, ConfigurationException_Exception
	{
		try
		{
			electricMeterNumber = WebServiceUtil
					.killWhitespace(electricMeterNumber);
			standaloneGatewaySerialNumber = WebServiceUtil
					.killWhitespace(standaloneGatewaySerialNumber);

			if (electricMeterNumber == null
					&& standaloneGatewaySerialNumber == null)
			{
				throw new ElectricMeterNotFoundException(
						DefaultResources.ACC_ERR_CODE_ELECTRIC_METER_NOT_FOUND,
						"Invalid electricMeterNumber or standaloneGatewaySerialNumber");
			}

			if (electricMeterNumber != null
					&& standaloneGatewaySerialNumber != null)
			{
				throw new ElectricMeterNotFoundException(
						DefaultResources.ACC_ERR_CODE_ELECTRIC_METER_NOT_FOUND,
						"Illegal argument electricMeterNumber and standaloneGatewaySerialNumber cannot both be populated");
			}

			

			CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
			final AccountPartsModel accountParts;
			try
			{
				accountParts = compoundAccountKeyUtility.getAccountParts();
			} catch (Exception e)
			{
				// Compound Account Key Error
				throw new CompoundAccountKeyException("Unexpected Error", e);
			}
			final Account account = getAccount(accountNumber,
					compoundAccountKey, accountParts);

			List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
					.getAccountId());
			Esi esi = esiList == null || esiList.isEmpty() ? null : esiList
					.get(0);

			if (esi == null)
			{
				throw new EsiNotFoundException(
						DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
						"Account not provisioned ");
			}

			 
            Gateway gateway = null;
			List<ProvStatusFlags> provFlagsList = genericFacade
					.getProvStatusFlagsByGwId(gateway.getGatewayId());
			final ProvStatusFlags provStatusFlags = provFlagsList != null
					&& !provFlagsList.isEmpty() ? provFlagsList.get(0) : null;

			if (provStatusFlags == null
					|| !OpsCenterConstants.TRUE.equals(provStatusFlags
							.getActiveNwFlag()))
			{
				throw new GatewayNotFoundException(
						DefaultResources.ACC_ERR_CODE_GATEWAY_NOT_FOUND,
						"Unable to find a standalone/associated gateway that is active on the network.");
			}

			List<EsiGateway> esiGwList = esiBeanFacade
					.getEsiGatewayByGatewayId(gateway.getGatewayId());
			if (esiGwList != null && !esiGwList.isEmpty())
			{
				throw new EsiGatewayAlreadyExistsException(
						DefaultResources.ACC_ERR_CODE_ESI_GATEWAY_ALREADY_EXISTS,
						"This electricMeterNumber has an associated gateway that is already associated to an account",
						electricMeterNumber);
			}

			EsiGateway oldEsiGateway = esi.getEsiGatewayId();

			final Gateway oldGateway = oldEsiGateway.getGatewayId();
			String oldSepVersion = oldGateway.getSepVersion();
 
			 
			final DateTime currTime = new DateTime();
			

			// DEV-38 - Try to prevent db and gw from being out-of-sync
			// Swap GW
			// KRMT-4545: Since the happy path is to remove & flash the gw
			// (broker.cfg pointed to GP), then this puts the db in the right
			// state after the flash
			oldGateway.setActiveFlag(OpsCenterConstants.FALSE);
			// oldGateway.setActiveNetworkFlag(OpsCenterConstants.FALSE);

			List<ProvStatusFlags> oldProvFlagsList = genericFacade
					.getProvStatusFlagsByGwId(oldGateway.getGatewayId());
			final ProvStatusFlags oldProvStatusFlags = oldProvFlagsList != null
					&& !oldProvFlagsList.isEmpty() ? oldProvFlagsList.get(0)
					: null;
			// oldProvStatusFlags.setActiveNwFlag(OpsCenterConstants.FALSE);
			// oldProvStatusFlags.setActiveNwTime(currTime);

			if (oldProvStatusFlags == null)
			{
				log.error("oldProvStatusFlags returned null in electricMeterGatewaySwapPersist()");
			}
			else
			{
				oldProvStatusFlags.setConfigAckFlag(OpsCenterConstants.FALSE);
				oldProvStatusFlags.setConfigAckTime(currTime);
			}


			// KRMT-4664
			// oldEsiGateway.setActiveFlag(gateway.getActiveFlag());

			// KRMT-3435
			oldEsiGateway.setDateUpdated(currTime);

			// This apparently gets set when a gateway dies, so reset it.
			oldEsiGateway.setOutageFlag(OpsCenterConstants.FALSE);

			// Calling the exact same code as provisioning portal, but maybe I
			// should just call cache manager directly...
			List<Device> deviceList = new ArrayList<Device>();

			 

			Device device = new Device();
			device.setAction("REPLACE");
			device.setDeviceId(oldEsiGateway.getGatewayMqId());
			device.setDeviceType(OpsCenterConstants.GATEWAY);
			deviceList.add(device);
			
			//DEV-3330: WSI : Getting an error on ElectricMeter_Swap webservice 
			userAccountBeanFacade.flushToGenerateHistoryRecords();

			gatewayConfigurationService.replaceGatewayAndOrElectricMeter(esi,
					deviceList);
			return esi;

		} catch (AbstractOpsCenterException e)
		{
			context.setRollbackOnly();
			throw e;
		}
	}

	/**
	 * @param accountNumber
	 * @param compoundAccountKey
	 * @param accountParts
	 * @return
	 * @throws AbstractOpsCenterException
	 * @throws CompoundAccountKeyNotUniqueException
	 * @throws AccountNotFoundException
	 */
	private Account getAccount(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey,
			final AccountPartsModel accountParts)
			throws AbstractOpsCenterException,
			CompoundAccountKeyNotUniqueException, AccountNotFoundException
	{
		final Account account;
		if (compoundAccountKey != null && compoundAccountKey.getConsertId() != null)
		{
			final int accountId = compoundAccountKey.getConsertId().intValue();
				account = userAccountBeanFacade.findAccountByAccountId(accountId);
			}
		else if (compoundAccountKey != null && accountParts.isCompoundKeyEnabled())
		{
			List<ExternalAccountXRef> externalAccountXRefList = getExternalAccountXrefList(
					accountParts, compoundAccountKey);
			if (externalAccountXRefList.isEmpty())
			{
				account = null;
			} else if (externalAccountXRefList.size() > 1)
			{
				throw new CompoundAccountKeyNotUniqueException(
						"More than one account matched the provided compound key(s)");
			} else
			{
				ExternalAccountXRef externalAccountXRef = externalAccountXRefList
						.get(0);
				account = externalAccountXRef.getAccount();
			}
		} else
		{
			// TODO - potential optimization is to get the account Id, instead
			// of the entire object graph
			List<Account> accountByAccountNoList = userAccountBeanFacade
					.getAccountByAccountNumberAndNotDeleted(accountNumber);
			account = accountByAccountNoList.isEmpty() ? null
					: accountByAccountNoList.get(0);
		}
		if (account == null)
		{
			throw new AccountNotFoundException(
					"Account not found, compoundKeyEnabled="
							+ accountParts.isCompoundKeyEnabled());
		}
		return account;
	}

	@Override
	public ConsertAccountProvisioningResponse electricMeterDeprovision(
			ConsertAccountMeterDivorce request)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		String electricMeterNumber = request.getElectricMeterNumber();
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING_RESET));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ELECTRICMETER_DEPROVISION));

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		gatewayMessagingWorkflow.setUsrCreated(userCreated);

		Exception exception = null;

		try
		{

			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());

			ProvState provState = consertAccountProvisioning
					.vppAccountDeprovisionPersist(request, null,
							userCreated);
			Esi oldEsi = provState.getEsi();

			gatewayMessagingWorkflow.setEsiId(oldEsi);

		} catch (Exception e1)
		{
			exception = e1;

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}

			log.error("Failed to ElectricMeter_Deprovision", e1);

			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			ConsertErrorById error = new ConsertErrorById();
			error.setObjectType("electricMeterNumber");
			error.setObjectId(electricMeterNumber);
			errorObjectDetails.add(error);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
			response.setError(consertCreateUpdateError);
		}
		response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
				: ConsertAccountProvisioningResponseStatus.ERROR);
		gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow,
				exception);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	/**
	 * @param electricMeterNumber
	 * @return
	 * @throws AbstractOpsCenterException
	 */
	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public ProvState vppAccountDeprovisionPersist(ConsertAccountMeterDivorce meterDivorce, 
			ConsertAccountVppDivorce vppDivorce, String user) throws AbstractOpsCenterException
	{
		log.debug("[ENTER] vppAccountDeprovisionPersist");
		try
		{
			ProvStateImpl provState = new ProvStateImpl();
			RemovalCode removalCode = null;
			final Integer removalReasonCode;
			final String electricMeterNumber;
			final String standaloneGatewaySerialNumber;
			final String removalNetsuiteTicket;
			final String lcsSerialNumber;
			final String wallplateSerialNumber;
			long devMacId = 0;
			
			//Require that the object actually have a meter number in case an empty object is passed instead of a null.
			if (meterDivorce != null && null != meterDivorce.getElectricMeterNumber() && !"".equals(meterDivorce.getElectricMeterNumber().trim()))
			{
				electricMeterNumber = WebServiceUtil
						.killWhitespace(meterDivorce.getElectricMeterNumber());
				standaloneGatewaySerialNumber = null;
				removalReasonCode = meterDivorce.getRemovalReasonCode();
				removalNetsuiteTicket =  meterDivorce.getRemovalNetsuiteTicket();
				lcsSerialNumber = null;
				wallplateSerialNumber = null;
			}
			else
			{
				electricMeterNumber = WebServiceUtil
						.killWhitespace(vppDivorce.getElectricMeterNumber());
				standaloneGatewaySerialNumber = WebServiceUtil
						.killWhitespace(vppDivorce.getStandaloneGatewaySerialNumber());
				removalReasonCode = vppDivorce.getRemovalReasonCode();
				removalNetsuiteTicket =  vppDivorce.getRemovalNetsuiteTicket();
				lcsSerialNumber = WebServiceUtil.killWhitespace(vppDivorce.getLcsSerialNumber());
				wallplateSerialNumber = WebServiceUtil.killWhitespace(vppDivorce.getWallplateSerialNumber());
			}
			
			if (removalReasonCode != null)
			{
				removalCode = genericFacade.getRefRemovalCodeById(removalReasonCode);
			}
			
			if (electricMeterNumber == null
					&& standaloneGatewaySerialNumber == null
					&& lcsSerialNumber == null
					&& wallplateSerialNumber == null)
			{
				throw new ElectricMeterNotFoundException(
						DefaultResources.ACC_ERR_CODE_ELECTRIC_METER_NOT_FOUND,
						"Invalid electricMeterNumber / standaloneGatewaySerialNumber / lcsSerialNumber / wallplateSerialNumber");
			}

			if (electricMeterNumber != null
					&& standaloneGatewaySerialNumber != null)
			{
				throw new ElectricMeterNotFoundException(
						DefaultResources.ACC_ERR_CODE_ELECTRIC_METER_NOT_FOUND,
						"Illegal argument electricMeterNumber and standaloneGatewaySerialNumber cannot both be populated");
			}
			
			if (lcsSerialNumber != null
					&& wallplateSerialNumber != null)
			{
				throw new ElectricMeterNotFoundException(
						DefaultResources.ACC_ERR_CODE_ELECTRIC_METER_NOT_FOUND,
						"Illegal argument lcsSerialNumber and wallplateSerialNumber cannot both be populated");
			}
			Gateway gateway;
			{
				DateTime now = new DateTime();

				if (lcsSerialNumber != null)
				{
					final Lcs lcs = deviceBeanFacade
							.getLcsByGsSbrSerialNo(lcsSerialNumber);
					if (lcs == null)
					{
						throw new SchemaDataInvalidException(
								"LCS Seria lNumber "
										+ lcsSerialNumber
										+ " is not recognized");
					}

					EsiLcs esiLcs = esiBeanFacade.getEsiLcsByDeviceMacId(lcs
									.getDeviceMacId());
					
					if (esiLcs == null)
					{
						throw new SchemaDataInvalidException(
								ACC_ERR_CODE_DEPROVISIONABLE_GS_DEVICE_NOT_FOUND,
								"LCS Serial Number "
										+ lcsSerialNumber
										+ " is not associated with any account");
					}
					Esi oldEsi = esiLcs.getEsiId();
					
					Integer lcsRelayId = vppDivorce.getLcsRelayId();
					EsiDc relay = null;
					if (lcsRelayId != null)
					{
						if (lcsRelayId != 1 && lcsRelayId != 2)
						{
							throw new SchemaDataInvalidException(
									"LCS Relay Id must be either 1 or 2");
						}
						List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByDevMacId(lcs
								.getDeviceMacId());
						if (esiDcList != null && !esiDcList.isEmpty()) 
						{
							for (EsiDc esiDc : esiDcList) 
							{
								if (lcsRelayId.toString().equalsIgnoreCase(esiDc.getRelayId()))
								{
									relay = esiDc;
									break;
								}
							}
						}
						if (relay == null)
						{
							throw new SchemaDataInvalidException(
									ACC_ERR_CODE_DEPROVISIONABLE_GS_DEVICE_NOT_FOUND,
									"LCS Serial Number "
											+ lcsSerialNumber
											+ " do not have relay "
											+ lcsRelayId);
						}
						// if the lcs only has the provided relay then delete the entrie lcs
						if (esiDcList.size() == 1) 
						{
							relay = null;
						}
					}
					
					provState.setEsi(esiLcs.getEsiId());
					final boolean flagMasterAsDeleted = true;
					
					if (relay == null)
					{
						provState.addDeprovEsiLcs(esiLcs);
						flagEntireEsiLcsAsDeleted(esiLcs,
								flagMasterAsDeleted, now, removalNetsuiteTicket,
								removalCode);
						cacheManager.clearGSDeviceDCData(lcs.getDeviceMacId());
					}
					else
					{
						provState.addEsiLcs(esiLcs);
						flagAsDeleted(relay, flagMasterAsDeleted, 
								now, removalCode, removalNetsuiteTicket);
						cacheManager.clearGSDeviceDCData(lcs.getDeviceMacId());
						// Clearing then reloading the cache for the LCS, to remove the relay from cache
						cacheManager.cacheGSDeviceDCData(lcs.getDeviceMacId());
					}
					
					devMacId = lcs.getDeviceMacId();
				}
				else
				{
					final TstatWallPlate tstatWallPlate = deviceBeanFacade
							.getTstatWallPlateBySerialNo(wallplateSerialNumber);
					if (tstatWallPlate == null)
					{
						throw new SchemaDataInvalidException(
								ACC_ERR_CODE_DEPROVISIONABLE_GS_DEVICE_NOT_FOUND,
								"Wallplate Serial Number "
										+ wallplateSerialNumber
										+ " is not recognized");
					}
					
					EsiTstatWallPlate esiTstatWallPlate = esiBeanFacade.getEsiTstatWallPlateByDeviceMacId(tstatWallPlate
							.getDeviceMacId());
					
					if (esiTstatWallPlate == null)
					{
						throw new SchemaDataInvalidException(
								ACC_ERR_CODE_DEPROVISIONABLE_GS_DEVICE_NOT_FOUND,
								"Wallplate Serial Number "
										+ wallplateSerialNumber
										+ " is not associated with a wallplate");
					}
					
					EsiTstat esiTstat = esiBeanFacade.getEsiTstatByDeviceMacIdAndEsiId(tstatWallPlate.getDeviceMacId(), esiTstatWallPlate.getEsiId().getEsiId());
					
					if (esiTstat == null)
					{
						throw new SchemaDataInvalidException(
								ACC_ERR_CODE_DEPROVISIONABLE_GS_DEVICE_NOT_FOUND,
								"Wallplate Serial Number "
										+ wallplateSerialNumber
										+ " is not associated with a tstat");
					}
					
					Esi oldEsi = esiTstatWallPlate.getEsiId();
					
					final boolean flagMasterAsDeleted = true;
					
					provState.setEsi(oldEsi);
					provState.addDeprovEsiTstat(esiTstat);
										
					flagEntireEsiTstatWallPlateAsDeleted(
							esiTstatWallPlate, esiTstat, flagMasterAsDeleted,
							now, removalCode, removalNetsuiteTicket);
					
					
					cacheManager.clearGSDeviceTstatData(tstatWallPlate.getDeviceMacId());
					
					devMacId = tstatWallPlate.getDeviceMacId();
				}
			}
			//Clear alets for this device Mac Id
			clearAlertsByDeviceMacId(devMacId);
			log.debug("EXIT vppAccountDeprovisionPersist ");
			return provState;
		} catch (AbstractOpsCenterException e)
		{
			context.setRollbackOnly();
			log.error("Error : " +  e.getMessage());
			throw e;
		}
	}

	private void flagEntireEsiTstatWallPlateAsDeleted(
			EsiTstatWallPlate esiTstatWallPlate, EsiTstat esiTstat,
			final boolean flagMasterAsDeleted, DateTime now)
	{
		flagEntireEsiTstatWallPlateAsDeleted(
				esiTstatWallPlate, esiTstat, flagMasterAsDeleted,
				now, null, null);
	}
	
	private void clearAlertsByDeviceMacId(long devMacId){
		if(devMacId == 0) return;
		DateTime cleardDate =  new DateTime();
		esiBeanFacade.clearEsiAlertByDeviceMacId(devMacId, cleardDate);
	}
	/**
	 * @param oldEsi
	 * @param esiTstatWallPlate
	 * @param esiTstat
	 * @param flagMasterAsDeleted
	 * @param now
	 * @param removalCode
	 * @param removalNetsuiteTicket
	 */
	private void flagEntireEsiTstatWallPlateAsDeleted(
			EsiTstatWallPlate esiTstatWallPlate, EsiTstat esiTstat,
			final boolean flagMasterAsDeleted, DateTime now,
			RemovalCode removalCode, final String removalNetsuiteTicket)
	{
		Esi oldEsi = esiTstatWallPlate.getEsiId();
		
		List<TstatDcMap> tstatDcMapList = esiBeanFacade
				.getTstatDcMapByEsiId(oldEsi.getEsiId());					
		
		
		TstatDcGroup tstatDcGroupId = null;
		for (TstatDcMap tstatDcMap : tstatDcMapList)
		{
			EsiTstat esiTstatId = tstatDcMap.getEsiTstatId();
			if (esiTstatId != null && esiTstatId.equals(esiTstat)) {
				tstatDcGroupId = tstatDcMap.getTstatDcGroupId();
				break;
			}
		}
		
		List<TstatDcMap> tstatDcMapsForGroup = new ArrayList<TstatDcMap>(1);
		if (tstatDcGroupId != null)
		{
			for (TstatDcMap tstatDcMap : tstatDcMapList)
			{
				if (tstatDcGroupId.equals(tstatDcMap.getTstatDcGroupId())) {
					tstatDcMapsForGroup.add(tstatDcMap);								
				}
			}						
		}
		
		// If this is the last tstat in the hvac group then remove the hvac group
		if (tstatDcMapsForGroup.size() == 1)
		{
			TstatDcMap tstatDcMap = tstatDcMapsForGroup.get(0);
			flagAsDeleted(tstatDcMap);
			flagAsDeleted(tstatDcMap.getEsiDcId(), flagMasterAsDeleted, now, removalCode, removalNetsuiteTicket);
		}
		
		flagAsDeleted(esiTstatWallPlate, flagMasterAsDeleted, now, removalCode, removalNetsuiteTicket);
		flagAsDeleted(esiTstat, flagMasterAsDeleted, now, removalCode, removalNetsuiteTicket);
		flagAsDeleted(esiTstat.getEsiDcId(), flagMasterAsDeleted, now, removalCode, removalNetsuiteTicket);
		
		flagGsEsiAsDeletedIfNecessary(removalCode,
				removalNetsuiteTicket, now, oldEsi);
	}

	/**
	 * 
	 * @param esiLcs
	 * @param flagMasterAsDeleted
	 * @param now
	 */
	private void flagEntireEsiLcsAsDeleted(
			EsiLcs esiLcs, final boolean flagMasterAsDeleted, DateTime now)
	{
		flagEntireEsiLcsAsDeleted(esiLcs, flagMasterAsDeleted, now, null, null);
	}
	
	/**
	 * @param oldEsi
	 * @param lcs
	 * @param esiLcs
	 * @param flagMasterAsDeleted
	 * @param now
	 * @param removalNetsuiteTicket
	 * @param removalCode
	 */
	private void flagEntireEsiLcsAsDeleted(
			EsiLcs esiLcs, final boolean flagMasterAsDeleted, DateTime now,
			final String removalNetsuiteTicket, RemovalCode removalCode)
	{
		Esi oldEsi = esiLcs.getEsiId();
		final Lcs lcs = esiLcs.getLcsId();
		
		flagAsDeleted(esiLcs, flagMasterAsDeleted, now, removalCode, removalNetsuiteTicket);
		
		List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByDevMacId(lcs
				.getDeviceMacId());
		
		for (EsiDc esiDc : esiDcList)
		{
			flagAsDeleted(esiDc, flagMasterAsDeleted, now, removalCode, removalNetsuiteTicket);
		}
		
		flagGsEsiAsDeletedIfNecessary(removalCode,
				removalNetsuiteTicket, now, oldEsi);
	}

	/**
	 * @param removalCode
	 * @param removalNetsuiteTicket
	 * @param now
	 * @param oldEsi
	 */
	private void flagGsEsiAsDeletedIfNecessary(RemovalCode removalCode,
			final String removalNetsuiteTicket, DateTime now, Esi oldEsi)
	{
		final List<EsiDc> esiDcByEsiId = esiBeanFacade.getEsiDcByEsiId(oldEsi.getEsiId());
		if (esiDcByEsiId == null || esiDcByEsiId.isEmpty())
		{
			//flagProgramsAndTpAsDeleted(oldEsi, now);
			programBeanFacade.updateProgramDeleteFlagByAccountId(oldEsi.getAccountId().getAccountId(),  OpsCenterConstants.PROVISIONING_USER, now);
			flagEsiAsDeleted(oldEsi, now, removalCode, removalNetsuiteTicket);
		}
			
	}


	
	/**
	 * @param oldEsi
	 * @param oldEsiElectricMeter
	 * @param gateway
	 * @param user
	 * @throws GatewayNotFoundException
	 */

	private void accountDeprovision(Esi oldEsi,
			Object obj, String user,
			RemovalCode removalReasonCode, String removalNetsuiteTicket, ProvisioningEsiBean provEsiBean)
			throws GatewayNotFoundException
	{

		final Gateway gateway = oldEsi.getEsiGatewayId().getGatewayId();
		List<ProvStatusFlags> provFlagsList = null;
		ProvStatusFlags provStatusFlags = null;

		if (oldEsi.getNetworkDeliveryId() != 2)
		{
			provFlagsList = genericFacade.getProvStatusFlagsByGwId(gateway
					.getGatewayId());
			provStatusFlags = provFlagsList != null && !provFlagsList.isEmpty() ? provFlagsList
					.get(0) : null;

			if (provStatusFlags == null
					|| !OpsCenterConstants.TRUE.equals(provStatusFlags
							.getActiveNwFlag()))
			{
				throw new GatewayNotFoundException(
						DefaultResources.ACC_ERR_CODE_GATEWAY_NOT_FOUND,
						"Unable to find a standalone/associated gateway that is active on the network.");
			}
		}

		// // DEV-721: WSI: Inorder to better support GE testing this validation
		// on Deprovision needs to be relaxed
		// // Removing this check b/c it prevents gw's broker.cfg file that is
		// out-of-sync with the db from getting pointed back to GP,
		// // however it increases the risk of workflow timeouts b/c the db
		// believes that the gw is listening to GP & sending a message to
		// utility mq if gw is listening to GP equals timeout
		// if
		// (!OpsCenterConstants.TRUE.equals(provStatusFlags.getConfigAckFlag()))
		// {
		// throw new
		// GatewayNotFoundException(DefaultResources.ACC_ERR_CODE_GATEWAY_NOT_FOUND,
		// "Unable to find a standalone/associated gateway that has been configured as part of provisioning.");
		// }

		DateTime now = new DateTime();
		List<EsiDc> esiDcList = esiBeanFacade
				.getEsiDcByEsiId(oldEsi.getEsiId());
		List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(oldEsi
				.getEsiId());
		List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(oldEsi
				.getEsiId());
		List<EsiTstatWallPlate> esiTstatWallPlateList = esiBeanFacade
				.getEsiTstatWallPlateByEsiId(oldEsi.getEsiId());
		List<TstatDcMap> tstatDcMapList = esiBeanFacade
				.getTstatDcMapByEsiId(oldEsi.getEsiId());
		// clean up db
		//ProvisioningEsiBean provEsiBean = new ProvisioningEsiBean();
		provEsiBean.setEsi(oldEsi);
 		provEsiBean.setEsiDcList(esiDcList);
		provEsiBean.setEsiTstatList(esiTstatList);
		provEsiBean.setEsiLcsList(esiLcsList);
		provEsiBean.setEsiTstatWallPlateList(esiTstatWallPlateList);
		provEsiBean.setTstatDcMapList(tstatDcMapList);
		provEsiBean.setUser(user);
		provEsiBean.setNow(now);
		flagDevicesAndProgramDataAsDeletedOnOldEsi(true, provEsiBean, removalReasonCode, removalNetsuiteTicket);

		// reset gateway flags
		gateway.setActiveFlag(OpsCenterConstants.FALSE);
		// gateway.setActiveNetworkFlag(OpsCenterConstants.FALSE);

		// // DEV-38 - Try to prevent db and gw from being out-of-sync
		// provStatusFlags.setActiveNwFlag(OpsCenterConstants.FALSE);
		// provStatusFlags.setActiveNwTime(now);
		if (oldEsi.getNetworkDeliveryId() != 2 && provStatusFlags != null)
		{
			provStatusFlags.setConfigAckFlag(OpsCenterConstants.FALSE);
			provStatusFlags.setConfigAckTime(now);
		}

		// clean up cache
		cacheManager.removeGatewayAndEsiData(oldEsi);
	}

	@Override
	public ConsertAccountProvisioningResponse vppAccountDeprovision(
			ConsertAccountVppDivorce request)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return vppAccountDeprovision(request, tenantId);
	}
	
	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioning#vppAccountDeprovision(com.consert.service.ns.xml.ConsertAccountVppDivorce)
	 */
	@Override
	public ConsertAccountProvisioningResponse vppAccountDeprovision(
			ConsertAccountVppDivorce request, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		final String electricMeterNumber = request.getElectricMeterNumber();
		final String standaloneGatewaySerialNumber = request
				.getStandaloneGatewaySerialNumber();

		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_DEPROVISION));

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		gatewayMessagingWorkflow.setUsrCreated(userCreated);

		Exception exception = null;
		Esi oldEsi = null;
		ProvState provState = null;
		try
		{
			isDeviceAssociatedWithDM(StringUtils.isNotBlank(request.getWallplateSerialNumber())?request.getWallplateSerialNumber():request.getLcsSerialNumber());
			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());
			
				
			provState = consertAccountProvisioning.vppAccountDeprovisionPersist(new ConsertAccountMeterDivorce(), request, userCreated);
			
			oldEsi = provState.getEsi();

			gatewayMessagingWorkflow.setEsiId(oldEsi);
			

		} catch (Exception e1)
		{
			exception = e1;

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}

			log.error("Failed to VppAccount_Deprovision", e1);

			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			ConsertErrorById error = new ConsertErrorById();
			error.setObjectType("electricMeterNumber");
			error.setObjectId(electricMeterNumber);
			errorObjectDetails.add(error);

			ConsertErrorById error2 = new ConsertErrorById();
			error2.setObjectType("standaloneGatewaySerialNumber");
			error2.setObjectId(standaloneGatewaySerialNumber);
			errorObjectDetails.add(error2);

			response.setError(consertCreateUpdateError);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}
		
		final int workflowTypeId;
		boolean isGridStream = false;
		if (oldEsi != null && oldEsi.getNetworkDeliveryId() == 2)
		{
			isGridStream = true;
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_DEPROVISIONING;
		} else
		{
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING_RESET;
		}
		
		gatewayMessagingWorkflow
		.setGatewayMessagingWorkflowTypeId(esiBeanFacade
				.getRefGatewayMessagingWorkflowType(workflowTypeId));
		
		if (isGridStream && exception == null && oldEsi != null && provState != null)
		{
			Set<EsiTstat> deprovEsiTstatSet = provState.getDeprovEsiTstatSet();
			if (!deprovEsiTstatSet.isEmpty())
			{
				EsiTstat esiTstat = deprovEsiTstatSet.iterator().next();
				gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
				response.setWallplateSerialNumber(esiTstat.getTstatWallPlate().getGsSbrSerialNo());
			}
			Set<EsiLcs> deprovEsiLcsSet = provState.getDeprovEsiLcsSet();
			if (!deprovEsiLcsSet.isEmpty())
			{
				EsiLcs esiLcs = deprovEsiLcsSet.iterator().next();
				gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
				response.setLcsSerialNumber(esiLcs.getLcsId().getGsSbrSerialNo());
			}
			Set<EsiLcs> provEsiLcsSet = provState.getProvEsiLcsSet();
			if (!provEsiLcsSet.isEmpty())
			{
				EsiLcs esiLcs = provEsiLcsSet.iterator().next();
				gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(
								GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING));
				gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
				response.setLcsSerialNumber(esiLcs.getLcsId().getGsSbrSerialNo());
			}
		}
		
		if (Boolean.TRUE.equals(request.isDisableWorkflow()))
		{
			if (exception == null)
			{
				response.setStatus(ConsertAccountProvisioningResponseStatus.SUCCESS);
			}
		}
		else
		{
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow,
					exception);
			response.setTrackingId(gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
			}
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));

		return response;
	}

	private void isDeviceAssociatedWithDM(String deviceMacId) throws DemandManagerException
	{
		// Here we are validating device associated with demand
		// manager or not.
		if (demandManagerBeanLocal.isDeviceAssociatedWithDM(Long.parseLong(deviceMacId, 16)))
		{
			throw new DemandManagerException(DEMAND_MANAGER_DEVICE_ASSOCIATED,
					"Lcs macId " + deviceMacId + " associated with dm.");
		}
	}

	@Override
	public List<ConsertAccountProvisioningResponse> vppAccountProvision(
			ConsertAccountVppMarriage accountVppMarriage)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return vppAccountProvision(accountVppMarriage, tenantId);
	}
	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioning#vppAccountProvision(com.consert.service.ns.xml.ConsertAccountVppMarriage)
	 */
	@Override
	public List<ConsertAccountProvisioningResponse> vppAccountProvision(
			ConsertAccountVppMarriage accountVppMarriage, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		ConsertError consertCreateUpdateError = null;
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		if (accountVppMarriage == null)
		{
			return null;
		}

		final String accountNumber = accountVppMarriage.getAccountNumber();

		final ConsertElectricMeter electricMeter = accountVppMarriage
				.getElectricMeter();
		final String electricMeterNumber = electricMeter != null ? WebServiceUtil
				.killWhitespace(electricMeter.getMeterSerialNumber()) : null;

		final String standaloneGatewaySerialNumber = WebServiceUtil
				.killWhitespace(accountVppMarriage
						.getStandaloneGatewaySerialNumber());

		final int workflowTypeId;
		final int workflowOriginId;
		if (accountVppMarriage.isGridStream() != null
				&& accountVppMarriage.isGridStream())
		{
			// Grid Stream
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING;
		} else
		{
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING;
		}
		workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_PROVISION;
		String userCreated = accountVppMarriage.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}

		Exception exception = null;
		ProvState provState = null;
		try
		{

			provState = consertAccountProvisioning.vppAccountProvisionPersist(
					accountVppMarriage, userCreated);

		} catch (Exception e1)
		{

			exception = e1;

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to VppAccount_Provision", e1);

			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			ConsertCompoundAccountKey compoundAccountKey = accountVppMarriage
					.getCompoundAccountKey();

			if (electricMeterNumber != null)
			{
				ConsertErrorById error2 = new ConsertErrorById();
				error2.setObjectType("electricMeterNumber");
				error2.setObjectId(electricMeterNumber);
				errorObjectDetails.add(error2);
			}

			if (standaloneGatewaySerialNumber != null)
			{
				ConsertErrorById error2 = new ConsertErrorById();
				error2.setObjectType("standaloneGatewaySerialNumber");
				error2.setObjectId(standaloneGatewaySerialNumber);
				errorObjectDetails.add(error2);
			}
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);
			if (abstractOpsCenterException != null)
			{
				Object[] expParams = abstractOpsCenterException
						.getExceptionParams();
				if (expParams != null
						&& accountVppMarriage.isGridStream() != null
						&& accountVppMarriage.isGridStream())
				{
					ConsertErrorById error2 = new ConsertErrorById();
					error2.setObjectType(expParams.length > 0 ? expParams[0]
							.toString() : "");
					error2.setObjectId(expParams.length > 1 ? expParams[1]
							.toString() : "");
					errorObjectDetails.add(error2);
				}
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}
		// TODO use work manager to start in background
		/*
		 * Only return one response element if any errors, Otherwise a) will
		 * need a response per device in case of GS b) one response in case of
		 * VPP
		 */
		
		if (null != accountVppMarriage.isDisableWorkflow() && accountVppMarriage.isDisableWorkflow())
		{
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			if (exception == null)
			{
				response.setStatus(ConsertAccountProvisioningResponseStatus.SUCCESS);
			}
			else
			{
				response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
				response.setError(consertCreateUpdateError);
			}
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
			return responseList;
		}
		
		if (Boolean.TRUE.equals(accountVppMarriage.isGridStream())
				&& exception == null && provState != null)
		{			
			Esi esi = provState.getEsi();
			final Set<EsiTstat> esiTstatList = provState.getProvEsiTstatSet();
			for (EsiTstat esiTstat : esiTstatList)
			{
				ConsertAccountProvisioningResponse response = startWorkflow(accountVppMarriage.getReply(), esi, esiTstat, datatypeFactory, workflowTypeId,
							workflowOriginId, userCreated);
					responseList.add(response);
			}
			final Set<EsiLcs> esiLcsList = provState.getProvEsiLcsSet();
			for (EsiLcs esiLcs : esiLcsList)
			{
				ConsertAccountProvisioningResponse response = startWorkflow(
						accountVppMarriage.getReply(), esi, esiLcs, datatypeFactory,
						workflowTypeId, workflowOriginId, userCreated);
				responseList.add(response);
			}
		} else
		{
			Esi esi = (provState == null) ? null : provState.getEsi();
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);

			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowTypeId(esiBeanFacade
							.getRefGatewayMessagingWorkflowType(workflowTypeId));
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowOriginId(esiBeanFacade
							.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
			gatewayMessagingWorkflow.setEsiId(esi);
			try
			{
				populateWorkflowWithReply(gatewayMessagingWorkflow,
						accountVppMarriage.getReply());
			} catch (SchemaDataInvalidException exp)
			{
				exception = exp;
				exp.printStackTrace();
			}
			
			// For 3pt devices we do not want to start workflow if account
			// provisioning has failed.
			if (!isThirdPartyDevice(accountVppMarriage))
			{
				gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow, exception);
				
				response.setTrackingId(gatewayMessagingWorkflow
						.getGatewayMessagingWorkflowId());
				final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
						.getGatewayMessagingWorkflowOriginId();
				if (gatewayMessagingWorkflowOriginId != null)
				{
					response.setTrackingType(gatewayMessagingWorkflowOriginId
							.getName());
				}
			}
			
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}

		return responseList;
	}

	/**
	 * Checking if the device is third party based on the vendor column of
	 * tstat_make_model. this will be required when we do not have the device
	 * type available.
	 * 
	 * @param accountVppMarriage
	 * @return
	 */
	private boolean isThirdPartyDevice(ConsertAccountVppMarriage accountVppMarriage)
	{
		if (accountVppMarriage.getHvacTstatDevices().size() > 0)
		{
			try
			{
				String tstatSerialNumber = accountVppMarriage.getHvacTstatDevices().get(0).getThermostats().get(0).getTstatSerialNumber();
				Tstat tstat = deviceBeanFacade.getTstatBySerialNo(tstatSerialNumber);
				if (tstat != null && tstat.getTstatMakeModelId().getVendorId() != null
						&& tstat.getTstatMakeModelId().getVendorId().getVendorId() == OpsCenterConstants.VENDOR_ID_HONEYWELL)
					return true;
			} catch (Exception e)
			{
				// ignore
			}
		}
		return false;
	}


	private ConsertAccountProvisioningResponse startWorkflow(
			ConsertReply reply, Esi esi,
			EsiTstat esiTstat, DatatypeFactory datatypeFactory,
			final int workflowTypeId, final int workflowOriginId,
			String userCreated)
	{
		return startWorkflow(reply, esi, esiTstat, null,
				datatypeFactory, workflowTypeId, workflowOriginId, userCreated);
	}
	
	private ConsertAccountProvisioningResponse startWorkflow(
			ConsertReply reply, Esi esi,
			EsiLcs esiLcs, DatatypeFactory datatypeFactory,
			final int workflowTypeId, final int workflowOriginId,
			String userCreated)
	{
		return startWorkflow(reply, esi, null, esiLcs,
				datatypeFactory, workflowTypeId, workflowOriginId, userCreated);
	}
	/**
	 * @param accountVppMarriage
	 * @param esi
	 * @param esiTstat
	 * @param datatypeFactory
	 * @param workflowTypeId
	 * @param workflowOriginId
	 * @param userCreated
	 * @return
	 */
	private ConsertAccountProvisioningResponse startWorkflow(
			ConsertReply reply, Esi esi,
			EsiTstat esiTstat, EsiLcs esiLcs, DatatypeFactory datatypeFactory,
			final int workflowTypeId, final int workflowOriginId,
			String userCreated)
	{
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);		

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow.setUsrCreated(userCreated);
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(workflowTypeId));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
		gatewayMessagingWorkflow.setEsiId(esi);
		gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
		gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
		Exception exp = null;
		try
		{
			populateWorkflowWithReply(gatewayMessagingWorkflow,
					reply);
		} catch (SchemaDataInvalidException sdie)
		{
			exp = sdie;
			exp.printStackTrace();
		}
		
		
		gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow, exp);
		
		Set<GatewayMessagingWorkflowStep> steps = gatewayMessagingWorkflow.getGatewayMessagingWorkflowStepCollection();
		if (CollectionUtils.isNotEmpty(steps) && esiTstat != null
				&& OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT == esiTstat.getEsiDcId().getDeviceTypeId().getDeviceTypeId())
		{
			GatewayMessagingWorkflowStep step = steps.iterator().next();
			if (new Integer(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_STATUS_OK).equals(step.getStatusCode()))
				response.setStatus(ConsertAccountProvisioningResponseStatus.SUCCESS);
			else
			{
				ConsertError consertError = new ConsertError();
				consertError.setErrorMessage(step.getStatusText());
				response.setError(consertError);
				response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
			}
		}
		
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId
					.getName());
		}
		
		if (esiTstat != null)
		{
			response.setWallplateSerialNumber(esiTstat.getTstatWallPlate().getGsSbrSerialNo());
		}
		else if (esiLcs != null)
		{
			response.setLcsSerialNumber(esiLcs.getLcsId().getGsSbrSerialNo());
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	/**
	 * @param accountNumber
	 * @param standaloneGatewaySerialNumber
	 * @param accountVppMarriage
	 * @param electricMeter
	 * @return
	 * @throws AbstractOpsCenterException
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public ProvState vppAccountProvisionPersist(
			ConsertAccountVppMarriage accountVppMarriage, String userCreated)
			throws Exception
	{
		ProvStateImpl provState = new ProvStateImpl();
		try
		{
			final String accountNumber = accountVppMarriage.getAccountNumber();
			final ConsertCompoundAccountKey compoundAccountKey = accountVppMarriage
					.getCompoundAccountKey();
			final ConsertElectricMeter electricMeter = accountVppMarriage
					.getElectricMeter();

			final String standaloneGatewaySerialNumber = WebServiceUtil
					.killWhitespace(accountVppMarriage
							.getStandaloneGatewaySerialNumber());

			CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
			final AccountPartsModel accountParts;
			try
			{
				accountParts = compoundAccountKeyUtility.getAccountParts();
			} catch (Exception e)
			{
				// Compound Account Key Error
				throw new CompoundAccountKeyException("Unexpected Error", e);
			}

			final DateTime now = new DateTime();

			// Always returns an account, otherwise it throws an exception
			final Account account = getAccount(accountNumber,
					compoundAccountKey, accountParts);
			// Handle VPP

			//Validate if ProgramTemplate for this account is not deleted if programTemplateId is not null
			validateProgramTemplate(account);
			final Object obj = marryMe(account, standaloneGatewaySerialNumber,
					electricMeter, null, accountVppMarriage.isGridStream());
			final Esi e;
			 
			e = (Esi) obj;
			
			 
			provState.setEsi(e);
			final boolean acceptsProgram = persistVppDevices(
					accountVppMarriage, provState, null, now);
				
			if (acceptsProgram)
			{
				// VPP
				assignDefaultProgramIfNull(e.getAccountId(), null, userCreated, now);
				provState = validateToRunWorkflowForEveryDevice(e, provState);
			}
						
			log.info("before refreshGatewayAndEsiData ");
			cacheManager.printGwDcCache();
			cacheManager.refreshGatewayAndEsiData(e);
			log.info("after refreshGatewayAndEsiData ");
			cacheManager.printGwDcCache();
			log.info("before return ");
			return provState;
		} catch (Exception e)
		{
			log.error("Got error ", e);
			context.setRollbackOnly();
			throw e;
		}
	}
	
	private ProvStateImpl validateToRunWorkflowForEveryDevice(Esi esi, ProvStateImpl provState){
		
		Account account = esi.getAccountId();
		log.debug("[ENTER] validateToRunWorkflowForEveryDevice");
		if(account.getProgramTemplateId() == null){
			log.debug("No Program Template is assigned to Account : "+ account.getAccountId() +" - " + account.getAccountNumber());
			return provState;
		}

		ProgramTemplate prgmTmpl = account.getProgramTemplateId();
		DateTime nowMinusSeven = new DateTime().minusDays(7);
		if(prgmTmpl.getDateModified() !=null && prgmTmpl.getDateModified().isAfter(nowMinusSeven)){
			boolean isThirdParty = isThirdPartyDeviceAvailableInProvState(provState);			
			provState = new ProvStateImpl();
			provState.setEsi(esi);
			List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(esi.getEsiId());
			List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(esi.getEsiId());
			
			log.debug("No of Esi Tstat " + esiTstatList.size());
			log.debug("No of Esi Lcs " + esiLcsList.size());
			for(EsiTstat esiTstat : esiTstatList){
				//we must any existing third party device from running workflow since they do not support program templates.
				//but we must let the workflow run for the current 3pt device that is being provisioned. 
				if(isExistingOrNewThirdPartyDevice(isThirdParty, esiTstat))
					provState.addEsiTstat(esiTstat);
			}
			
			for(EsiLcs esiLcs : esiLcsList){
				provState.addEsiLcs(esiLcs);
			}
		}
		
		return provState;
	}

	/**
	 * 
	 * @param isThirdParty
	 * @param esiTstat
	 * @return
	 */
	private boolean isExistingOrNewThirdPartyDevice(boolean isThirdParty, EsiTstat esiTstat)
	{
		int deviceTypeId = esiTstat.getEsiDcId().getDeviceTypeId().getDeviceTypeId();
		return isThirdParty || deviceTypeId != OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT;
	}

	/**
	 * Checking if provState have third party device.
	 * 
	 * @param provState
	 * @return
	 */
	private boolean isThirdPartyDeviceAvailableInProvState(ProvStateImpl provState)
	{
		if (provState.getProvEsiTstatSet().size() > 0)
		{
			// Since there will be only one third party device in the provState
			// object so picking the first one.
			if (provState.getProvEsiTstatSet().iterator().next().getEsiDcId() != null)
			{
				int deviceTypeId = provState.getProvEsiTstatSet().iterator().next().getEsiDcId().getDeviceTypeId().getDeviceTypeId();
				return deviceTypeId == OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT;
			}
		}
		return false;
	}

	/**
	 * @param accountVppMarriage
	 * @param provState - This method has a side effect that this object will be populated with EsiTstat & EsiLcs Sets
	 * @param eem
	 * @param now
	 * @return boolean - acceptsProgram 
	 * @throws SchemaDataInvalidException
	 * @throws SepVersionMismatchException
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private boolean persistVppDevices(
			ConsertAccountVppMarriage accountVppMarriage, final ProvStateImpl provState,
			Object obj, final DateTime now)
			throws SchemaDataInvalidException, SepVersionMismatchException,
			IllegalAccessException, InvocationTargetException,
			NoSuchMethodException
	{
		Esi e = provState.getEsi();
		boolean acceptsProgram = false;
		int deviceMqId = 1;

		final Map<Integer, EsiDc> esiDcByDcId = new HashMap<Integer, EsiDc>();
		final List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(e
				.getEsiId());
		for (EsiDc esiDc : esiDcList)
		{
			if (e.getNetworkDeliveryId() == 2
					&& esiDc.getDeviceTypeId() != null
					&& DC_NAME_BMM.equals(esiDc.getDeviceTypeId()
							.getDeviceTypeName()))
			{
				continue;
			}
			deviceMqId = Math.max(deviceMqId, esiDc.getDeviceMqId());
			esiDcByDcId.put(esiDc.getDcId().getDcId(), esiDc);
		}

		final Map<Integer, EsiTstat> esiTstatByTstatId = new HashMap<Integer, EsiTstat>();
		final List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(e
				.getEsiId());
		for (EsiTstat esiTstat : esiTstatList)
		{
			deviceMqId = Math.max(deviceMqId, esiTstat.getDeviceMqId());
			esiTstatByTstatId.put(esiTstat.getTstatId().getTstatId(), esiTstat);
		}

		final Map<Integer, TstatDcGroup> tstatDcGroupByHvacEsiDcId = new HashMap<Integer, TstatDcGroup>();
		final Map<Integer, TstatDcMap> tstatDcMapByEsiTstatId = new HashMap<Integer, TstatDcMap>();
		List<TstatDcMap> tstatDcMapList = esiBeanFacade.getTstatDcMapByEsiId(e
				.getEsiId());
		for (TstatDcMap tstatDcMap : tstatDcMapList)
		{
			tstatDcGroupByHvacEsiDcId.put(tstatDcMap.getEsiDcId().getEsiDcId(),
					tstatDcMap.getTstatDcGroupId());
			tstatDcMapByEsiTstatId.put(tstatDcMap.getEsiTstatId()
					.getEsiTstatId(), tstatDcMap);
		}

		final Map<Long, EsiTstatWallPlate> esitstatWallPlateByWallplateMacId = new HashMap<Long, EsiTstatWallPlate>();
		final List<EsiTstatWallPlate> esiTstatWallPlateList = esiBeanFacade
				.getEsiTstatWallPlateByEsiId(e.getEsiId());
		for (EsiTstatWallPlate esiTstatWallPlate : esiTstatWallPlateList)
		{
			// deviceMqId = Math.max(deviceMqId, wallPlate.getDeviceMqId());
			esitstatWallPlateByWallplateMacId.put(esiTstatWallPlate
					.getTstatWallPlateId().getDeviceMacId(), esiTstatWallPlate);
		}

		final Map<Long, EsiLcs> esiLcsByLcsId = new HashMap<Long, EsiLcs>();
		final List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(e
				.getEsiId());
		for (EsiLcs esiLcs : esiLcsList)
		{
			// deviceMqId = Math.max(deviceMqId, esiLcs.getDeviceMqId());
			esiLcsByLcsId.put(esiLcs.getLcsId().getDeviceMacId(), esiLcs);
		}
		// Move to max + 1
		deviceMqId++;

		// Get references
		DcMakeModel fakeDcMakeModel = deviceBeanFacade
				.getRefDcMakeModelByDcMakeModelId(1);
		ManageMode defaultManageMode = esiBeanFacade
				.getRefManageModeByManageModeId(1);
		Utility utility = genericFacade.getRefUtilityByUtilityId(1);
		DeviceType bmmDeviceType = deviceBeanFacade
				.getRefDeviceTypeByDeviceTypeId(OpsCenterConstants.DEVICE_TYPE_ID_BMM);

		final Gateway gateway = e.getEsiGatewayId().getGatewayId();
		String sepVersion = gateway.getSepVersion();

		// Handle Binaries
		List<String> targetedEsiDcFields = getTargetedPropertyNames(EsiDc.class);
		final List<ConsertVppBinaryChain> binaryDevices = accountVppMarriage
				.getBinaryDevices();
		int j = 0;
		for (ConsertVppBinaryChain consertVppBinaryChain : binaryDevices)
		{

			WebServiceUtil.validate(consertVppBinaryChain, "binaryDeviceName",
					50, false);
			String name = WebServiceUtil.killWhitespace(consertVppBinaryChain
					.getBinaryDeviceName());
			final ConsertVppBinaryDeviceController binaryDeviceController = consertVppBinaryChain
					.getBinaryDeviceController();
			WebServiceUtil.validate(binaryDeviceController,
					"consertSerialNumber", 20, true);
			final String consertSerialNumber = WebServiceUtil
					.killWhitespace(binaryDeviceController
							.getConsertSerialNumber());
			WebServiceUtil.validate(binaryDeviceController,
					"physicalLocationInstalled", 46, false);
			final String physicalLocationInstalled = WebServiceUtil
					.killWhitespace(binaryDeviceController
							.getPhysicalLocationInstalled());
			WebServiceUtil.validate(binaryDeviceController, "comments",
					1048576, false);
			final String comments = WebServiceUtil
					.killWhitespace(binaryDeviceController.getComments());

			final ConsertVppBinaryPhysicalDevice binaryPhysicalDevice = consertVppBinaryChain
					.getBinaryPhysicalDevice();
			final ConsertVppBinaryDeviceType binaryDeviceType = binaryPhysicalDevice
					.getBinaryDeviceType();
			if (binaryDeviceType == null)
			{
				throw new SchemaDataInvalidException(
						"Data validation error: binaryDevices[" + j
								+ "].binaryDeviceType is not valid");
			}
			WebServiceUtil.validate(binaryPhysicalDevice, "comments", 1048576,
					false);
			final String mdComments = WebServiceUtil
					.killWhitespace(binaryPhysicalDevice.getComments());
			WebServiceUtil.validate(binaryPhysicalDevice, "manufacturer", 255,
					false);
			final String manufacturer = WebServiceUtil
					.killWhitespace(binaryPhysicalDevice.getManufacturer());
			final BigDecimal measuredAmpacity = binaryPhysicalDevice
					.getMeasuredAmps();
			final BigDecimal volts = binaryPhysicalDevice.getVolts();
			WebServiceUtil.validate(binaryPhysicalDevice, "model", 255, false);
			final String model = WebServiceUtil
					.killWhitespace(binaryPhysicalDevice.getModel());
			final BigDecimal watts = binaryPhysicalDevice.getWatts();
			final BigDecimal amperage = binaryPhysicalDevice.getAmps();
			final BigDecimal minimumCircuitAmps = binaryPhysicalDevice
					.getMinimumCircuitAmps();
			final BigDecimal maxBreakerAmps = binaryPhysicalDevice
					.getMaxBreakerAmps();
			final BigDecimal ratedLoadAmps = binaryPhysicalDevice
					.getRatedLoadAmps();
			final String physicalLocation = binaryPhysicalDevice
					.getPhysicalLocation();
			final Integer yearOfManufacture = binaryPhysicalDevice
					.getYearOfManufacture();
			final Boolean energyStar = binaryPhysicalDevice.isEnergyStar();

			OpsCenterConstants.DeviceType type = OpsCenterConstants.DeviceType
					.fromWsiValue(binaryDeviceType.value());
			final int deviceTypeId = type.getId();

			Dc dc = deviceBeanFacade.getDcBySerialNo(consertSerialNumber);
			if (dc == null)
			{
				throw new SchemaDataInvalidException(
						"Data validation error: consertSerialNumber is not recognized, "
								+ consertSerialNumber);
			}

			final Esi dcEsi = dc.getEsiId();
			final EsiDc esiDc;
			if (dcEsi != null)
			{
				if (dcEsi != e)
				{
					throw new SchemaDataInvalidException(
							"Data validation error: consertSerialNumber is already associated to accountNumber = "
									+ dcEsi.getAccountId().getAccountNumber()
									+ ", consertSerialNumber = "
									+ consertSerialNumber);
				}
				EsiDc tempEsiDc = esiDcByDcId.remove(dc.getDcId());
				if (tempEsiDc != null)
				{
					esiDc = tempEsiDc;
				} else
				{
					esiDc = esiBeanFacade.getEsiDcByDcId(dc.getDcId());
				}
			} else
			{
				esiDc = null;
			}

			// Verify relay and SEP
			if (!OpsCenterConstants.TRUE.equals(dc.getDcMakeModelId()
					.getDcRelayFlag()))
			{
				throw new SchemaDataInvalidException(
						"Data validation error:  The binary device controller should have a relay for consertSerialNumber = "
								+ consertSerialNumber);
			}

			String newSepVersion = dc.getSepVersion();
			// this handles null != 1.1, 1.1 != null, && 1.1 != 1.2
			if (sepVersion != newSepVersion
					&& (sepVersion == null || !sepVersion
							.equalsIgnoreCase(newSepVersion)))
			{
				throw new SepVersionMismatchException(
						"Expected the binatry to have a SEP version = "
								+ sepVersion + " for consertSerialNumber = "
								+ consertSerialNumber);
			}

			if (name == null)
			{
				if (physicalLocation != null)
				{
					name = physicalLocation;
				} else
				{
					name = consertSerialNumber;
				}
				name = type + ": " + name;
			}
			dc.setName(name);
			dc.setBinarySystemName(physicalLocationInstalled);

			dc.setComments(comments);

			dc.setDateModified(now);
			if (esiDc == null)
			{
				dc.setDeviceMqId(deviceMqId++);
			}
			dc.setDeviceTypeId(deviceBeanFacade
					.getRefDeviceTypeByDeviceTypeId(deviceTypeId));
			dc.setEsiId(e);
			dc.setActiveFlag(OpsCenterConstants.TRUE);
			dc.setSerialNo(consertSerialNumber);
			dc.setMdMeasuredAmps(measuredAmpacity != null ? measuredAmpacity
					.doubleValue() : 0);
			dc.setMdVolts(volts != null ? volts.doubleValue() : 0);
			dc.setMdMake(manufacturer);
			dc.setMdModel(model);
			dc.setMdEnergyStarFlag(Boolean.TRUE.equals(energyStar) ? "1" : "0");
			dc.setAhEnergyStarFlag("0");
			dc.setMdComments(mdComments);
			dc.setMdWatts(watts != null ? watts.doubleValue() : 0);
			dc.setMdAmps(amperage != null ? amperage.doubleValue() : 0);
			dc.setMdMca(minimumCircuitAmps != null ? minimumCircuitAmps
					.doubleValue() : 0);
			dc.setMdYear(yearOfManufacture != null ? yearOfManufacture
					.intValue() : 0);
			dc.setMdMaxAmpBreaker(maxBreakerAmps != null ? maxBreakerAmps
					.doubleValue() : 0);
			dc.setMdRatedLoadAmps(ratedLoadAmps != null ? ratedLoadAmps
					.doubleValue() : 0);

			createEsiDc(esiDc, dc, targetedEsiDcFields, now);
			j++;

			acceptsProgram = true;
		}

		final List<ConsertVppHvacChain> hvacTstatDevices = accountVppMarriage
				.getHvacTstatDevices();
		List<String> targetedEsiTstatFields = getTargetedPropertyNames(EsiTstat.class);
		List<String> targetedEsiTstatWallPlateFields = getTargetedPropertyNames(EsiTstatWallPlate.class);

		int i = 0;
		for (ConsertVppHvacChain consertVppHvacChain : hvacTstatDevices)
		{
			i++;
			// Verify esi null or matches account's, relay and SEP
			WebServiceUtil.validate(consertVppHvacChain, "hvacLocationName",
					50, false);
			final String hvacLocationName = WebServiceUtil
					.killWhitespace(consertVppHvacChain.getHvacLocationName());

			final ConsertVppHvacDeviceController hvacDeviceController = consertVppHvacChain
					.getHvacDeviceController();
			ConsertVppHvacRemotelyMeasuredDevice hvacRemotelyMeasuredDevice = consertVppHvacChain
					.getHvacRemotelyMeasuredDevice();

			// There either needs to be at least one DC and one tstat... OR
			// there needs to be a tstat and have the system be a relay measured
			// system.
			final List<ConsertVppThermostat> thermostats = consertVppHvacChain
					.getThermostats();
			if (thermostats.isEmpty())
			{
				throw new SchemaDataInvalidException(
						"At least one thermostat is required");
			}

			if (hvacRemotelyMeasuredDevice == null
					&& hvacDeviceController == null)
			{
				throw new SchemaDataInvalidException(
						"Remote Measurement required");
			}

			if (hvacRemotelyMeasuredDevice != null
					&& hvacDeviceController != null)
			{
				throw new SchemaDataInvalidException(
						"Remote Measurement and Device Controller cannot both exist");
			}

			// Finding all the EsiTstats for this HVAC group (as defined by the
			// web service)
			List<EsiTstat> hvacGroupEsiTstatList = new ArrayList<EsiTstat>(
					thermostats.size());
			Map<String, Tstat> tstatBySerialNo = new HashMap<String, Tstat>();
			String tstatSerialNo = null;
			for (ConsertVppThermostat consertVppThermostat : thermostats)
			{
				try
				{
					WebServiceUtil.validate(consertVppThermostat,
							"tstatSerialNumber", 20, false);
					tstatSerialNo = consertVppThermostat.getTstatSerialNumber();

					Tstat tstat = deviceBeanFacade
							.getTstatBySerialNo(tstatSerialNo);
					if (tstat == null)
					{
						throw new SchemaDataInvalidException(
								"Thermostat serial number "
										+ tstatSerialNo
										+ " is not recognized.");
					}
					tstatBySerialNo.put(tstatSerialNo, tstat);

					final Esi tstatEsi = tstat.getEsiId();
					final EsiTstat esiTstat;
					if (tstatEsi != null)
					{
						
						if (tstatEsi != e)
						{
							// DEV-3287: Move 1 device from one account to another
							final boolean allowAccountSwap = Boolean.TRUE.equals(accountVppMarriage.isAllowAccountSwapForGridStream()) && Boolean.TRUE.equals(accountVppMarriage.isGridStream());
							if (allowAccountSwap)
							{
								EsiTstat accountSwapEsiTstat = esiBeanFacade.getEsiTstatByTstatId(tstat);
								String newTwpSn = consertVppThermostat.getWallplateSerialNumber();
								String oldTwpSn = (accountSwapEsiTstat == null || accountSwapEsiTstat.getTstatWallPlate() == null)
										? null : accountSwapEsiTstat.getTstatWallPlate().getGsSbrSerialNo();
								if (oldTwpSn == null || !oldTwpSn.equalsIgnoreCase(newTwpSn))
								{
									throw new SchemaDataInvalidException(
											"Account swap failed: New Serial Number - "
													+ newTwpSn
													+ ", Previous Serial Number - "
													+ oldTwpSn);
								}
								
								if (accountSwapEsiTstat != null)
								{
									final long deviceMacId = accountSwapEsiTstat.getTstatWallPlate().getDeviceMacId();
									EsiTstatWallPlate accountSwapEsiTstatWallPlate = esiBeanFacade.getEsiTstatWallPlateByDeviceMacId(deviceMacId);
									
									//Remove EsiTstatWallPlate from Old Account
									flagEntireEsiTstatWallPlateAsDeleted(accountSwapEsiTstatWallPlate, accountSwapEsiTstat, true, now);
									
									cacheManager.clearGSDeviceTstatData(deviceMacId);
								}
								// Not sure if this flush is needed, but it was here when my test case was successful, so I will leave it 
								userAccountBeanFacade.flushToGenerateHistoryRecords();
							}
							else
							{								
								log.info("Serial Number already associated to accountNumber " + tstatEsi.getAccountId().getAccountNumber()
										+ ". Thermostat Serial Number: " + tstatSerialNo);
								throw new SchemaDataInvalidException("This device is already associated to another account");
							}
						}
						// calling get now, b/c later will call remove
						EsiTstat tempEsiTstat = esiTstatByTstatId.get(tstat
								.getTstatId());
						if (tempEsiTstat != null)
						{
							esiTstat = tempEsiTstat;
						} else
						{
							esiTstat = esiBeanFacade
									.getEsiTstatByTstatId(tstat);
							if (esiTstat != null)
							{
								esiTstatByTstatId.put(tstat.getTstatId(),
										esiTstat);
							}
						}
					} else
					{
						esiTstat = null;
					}
					if (esiTstat != null)
					{
						hvacGroupEsiTstatList.add(esiTstat);
					}
				} catch (SchemaDataInvalidException exp)
				{
					exp.setExceptionParams(new Object[] { "tstatSerialNumber",
							tstatSerialNo });
					throw exp;
				}
			}

			final Dc hvacDc;
			final EsiDc esiDc;
			// If we are using relay measurement there is no *real* DC, so
			// create a fake one
			// and store all the relay measurements in it. Otherwise add the
			// actual DC to the group.

			final ConsertVppHvacPhysicalDevice hvacPhysicalDevice = consertVppHvacChain
					.getHvacPhysicalDevice();

			if (hvacRemotelyMeasuredDevice != null)
			{

				// If the webservice's inputed EsiTstats exactly match an
				// existing HVAC Group, then populate derivedHvacDc
				Dc derivedHvacDc = null;
				if (!hvacGroupEsiTstatList.isEmpty())
				{
					EsiTstat esiTstat = hvacGroupEsiTstatList.iterator().next();

					Set<TstatDcMap> tstatDcMapCollection = esiTstat
							.getTstatDcMapCollection();
					if (tstatDcMapCollection != null
							&& !tstatDcMapCollection.isEmpty())
					{
						TstatDcMap tstatDcMap = tstatDcMapCollection.iterator()
								.next();

						List<EsiTstat> esiTstatForGroup = new ArrayList<EsiTstat>();
						Set<TstatDcMap> tstatDcMapCollection2 = tstatDcMap
								.getTstatDcGroupId().getTstatDcMapCollection();
						for (TstatDcMap tstatDcMap2 : tstatDcMapCollection2)
						{
							esiTstatForGroup.add(tstatDcMap2.getEsiTstatId());
						}

						if (esiTstatForGroup.equals(hvacGroupEsiTstatList))
						{
							derivedHvacDc = tstatDcMap.getEsiDcId().getDcId();
						}
					}
				}
				if (derivedHvacDc != null)
				{
					hvacDc = derivedHvacDc;
					EsiDc tempEsiDc = esiDcByDcId.remove(hvacDc.getDcId());
					if (tempEsiDc != null)
					{
						esiDc = tempEsiDc;
					} else
					{
						esiDc = esiBeanFacade.getEsiDcByDcId(hvacDc.getDcId());
					}
				} else
				{
					esiDc = null;
					hvacDc = new Dc();
				}
				
				hvacDc.setDcMakeModelId(fakeDcMakeModel);
				if (ConsertElectricHvacType.THIRD_PARTY_THERMOSTAT.equals(hvacPhysicalDevice.getHvacType()))
				{
					hvacDc.setDeviceTypeId(deviceBeanFacade.getRefDeviceTypeByDeviceTypeId(OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT));
					hvacDc.setName(OpsCenterConstants.THIRD_PARTY_TSTAT);
				}
				else
				{
					hvacDc.setDeviceTypeId(bmmDeviceType);
					hvacDc.setName(DC_NAME_BMM);
				}
					
				hvacDc.setBinarySystemName("Fake DC System");
				hvacDc.setPowerStatusFlag(OpsCenterConstants.TRUE);
				hvacDc.setActiveFlag(OpsCenterConstants.TRUE);
				hvacDc.setHoldFlag(OpsCenterConstants.TRUE);
				hvacDc.setDeleteFlag(OpsCenterConstants.FALSE);
				hvacDc.setActEnergyConsumed(9);
				hvacDc.setManageModeId(defaultManageMode); // 1
				hvacDc.setPrevManageModeId(defaultManageMode); // 1
				hvacDc.setVirtualFlag(OpsCenterConstants.TRUE);
				hvacDc.setEsiId(e);
				hvacDc.setAssetNo("x");
 				hvacDc.setMdMca(1);
				hvacDc.setMdMake("Fake");
				hvacDc.setMdEnergyStarFlag(OpsCenterConstants.FALSE);
				hvacDc.setAhEnergyStarFlag(OpsCenterConstants.FALSE);
				hvacDc.setMdKw(1);
				hvacDc.setMdMeasuredAmps(1);
				hvacDc.setMdModel("1");
				hvacDc.setMdVolts(1);
				hvacDc.setFwVersion("1.0");
				hvacDc.setSerialNo("1");
				hvacDc.setPurchasedBy("Purchaser");
				hvacDc.setUtilityId(utility);

				ConsertRelay yRelay = hvacRemotelyMeasuredDevice.getYHeatCool();
				ConsertRelay y2Relay = hvacRemotelyMeasuredDevice
						.getY2SecondStageCool();
				ConsertRelay gRelay = hvacRemotelyMeasuredDevice.getGFan();
				ConsertRelay wRelay = hvacRemotelyMeasuredDevice.getWHeat();
				ConsertRelay w2Relay = hvacRemotelyMeasuredDevice
						.getW2AuxHeat();
				ConsertRelay w3Relay = hvacRemotelyMeasuredDevice
						.getW3ThirdStageHeat();

				if (yRelay == null && hvacDc.getDeviceTypeId().getDeviceTypeId() != OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT)
				{
					throw new SchemaDataInvalidException("y_HeatCool is required for this device type");
				}

				final double gAmps = getMeasuredAmps(gRelay);
				hvacDc.setMdGMeasuredAmps(gAmps);
				hvacDc.setMdGVoltage(getVolts(gRelay));
				hvacDc.setMdYMeasuredAmps(getMeasuredAmps(yRelay));
				hvacDc.setMdYVoltage(getVolts(yRelay));
				hvacDc.setMdY2MeasuredAmps(getMeasuredAmps(y2Relay));
				hvacDc.setMdY2Voltage(getVolts(y2Relay));

				// Since G and (W,W2,&W3) are off the same breaker, must
				// subtract out the fans amps
				hvacDc.setMdWMeasuredAmps(Math.max(getMeasuredAmps(wRelay)
						- gAmps, 0));
				hvacDc.setMdWVoltage(getVolts(wRelay));
				hvacDc.setMdW2MeasuredAmps(Math.max(getMeasuredAmps(w2Relay)
						- gAmps, 0));
				hvacDc.setMdW2Voltage(getVolts(w2Relay));
				hvacDc.setMdW3MeasuredAmps(Math.max(getMeasuredAmps(w3Relay)
						- gAmps, 0));
				hvacDc.setMdW3Voltage(getVolts(w3Relay));

				WebServiceUtil.validate(hvacRemotelyMeasuredDevice, "comments",
						1048576, false);
				final String comments = hvacRemotelyMeasuredDevice
						.getComments();
				hvacDc.setComments(comments);

			} else
			{
				if (hvacDeviceController == null)
				{
					log.error("hvacDeviceController returned null for persistVppDevices()");
					return false;
				}

				WebServiceUtil.validate(hvacDeviceController,
						"consertSerialNumber", 20, true);
				final String consertSerialNumber = hvacDeviceController
						.getConsertSerialNumber();

				hvacDc = deviceBeanFacade.getDcBySerialNo(consertSerialNumber);
				if (hvacDc == null)
				{
					throw new SchemaDataInvalidException(
							"Serial Number "
									+ consertSerialNumber
									+  " is not recognized.");
				}
				final Esi hvacDcEsi = hvacDc.getEsiId();
				if (hvacDcEsi != null)
				{
					if (hvacDcEsi != e)
					{
						throw new SchemaDataInvalidException(
								"Serial Number "
										+ hvacDcEsi.getAccountId()
												.getAccountNumber()
										+ " is already associated to Account Number "
										+ consertSerialNumber);
					}
					EsiDc tempEsiDc = esiDcByDcId.remove(hvacDc.getDcId());
					if (tempEsiDc != null)
					{
						esiDc = tempEsiDc;
					} else
					{
						esiDc = esiBeanFacade.getEsiDcByDcId(hvacDc.getDcId());
					}
				} else
				{
					esiDc = null;
				}

				WebServiceUtil.validate(hvacDeviceController,
						"physicalLocationInstalled", 46, false);
				final String physicalLocationInstalled = hvacDeviceController
						.getPhysicalLocationInstalled();

				String newSepVersion = hvacDc.getSepVersion();
				// this handles null != 1.1, 1.1 != null, && 1.1 != 1.2
				if (sepVersion != newSepVersion
						&& (sepVersion == null || !sepVersion
								.equalsIgnoreCase(newSepVersion)))
				{
					throw new SepVersionMismatchException(
							"Expected the hvac dc to have a SEP version = "
									+ sepVersion
									+ " for consertSerialNumber = "
									+ consertSerialNumber);
				}

				if (OpsCenterConstants.TRUE.equals(hvacDc.getDcMakeModelId()
						.getDcRelayFlag()))
				{
					throw new SchemaDataInvalidException(
							"The hvac controller should not have a relay for Serial Number "
									+ consertSerialNumber);
				}

				WebServiceUtil.validate(hvacDeviceController, "comments",
						1048576, false);
				final String comments = hvacDeviceController.getComments();
				hvacDc.setName(consertSerialNumber);
				hvacDc.setBinarySystemName(physicalLocationInstalled);
				hvacDc.setComments(comments);
			}

			if (hvacPhysicalDevice == null)
			{
				throw new SchemaDataInvalidException(
						"Physical Device information is required");
			}

			WebServiceUtil.validate(hvacPhysicalDevice, "comments", 1048576,
					false);
			final String mdComments = hvacPhysicalDevice.getComments();
			final ConsertElectricHvacType hvacType = hvacPhysicalDevice
					.getHvacType();
			if (hvacType == null)
			{
				throw new SchemaDataInvalidException(
						"HVAC Type is required and either missing or not valid.");
			}

			WebServiceUtil.validate(hvacPhysicalDevice, "manufacturer", 255,
					false);
			final String manufacturer = hvacPhysicalDevice.getManufacturer();
			final BigDecimal amperage = hvacPhysicalDevice.getAmps();
			final BigDecimal measuredAmps = hvacPhysicalDevice
					.getMeasuredAmps();
			final BigDecimal voltage = hvacPhysicalDevice.getVolts();
			final BigDecimal watts = hvacPhysicalDevice.getWatts();
			final BigDecimal minimumCircuitAmps = hvacPhysicalDevice
					.getMinimumCircuitAmps();
			final BigDecimal maxBreakerAmps = hvacPhysicalDevice
					.getMaxBreakerAmps();
			final BigDecimal ratedLoadAmps = hvacPhysicalDevice
					.getRatedLoadAmps();

			WebServiceUtil.validate(hvacPhysicalDevice, "model", 255, false);
			final String model = hvacPhysicalDevice.getModel();

			WebServiceUtil.validate(hvacPhysicalDevice, "physicalLocation", 50,
					true);
			final String physicalLocation = hvacPhysicalDevice
					.getPhysicalLocation();			

			final Integer yearOfManufacture = hvacPhysicalDevice
					.getYearOfManufacture();
			final Boolean energyStar = hvacPhysicalDevice.isEnergyStar();

			hvacDc.setActiveFlag(OpsCenterConstants.TRUE);
			hvacDc.setEsiId(e);
			if (esiDc == null)
			{
				hvacDc.setDeviceMqId(deviceMqId++);
			}

			if (!DC_NAME_BMM.equals(hvacDc.getName())
					&& physicalLocation != null)
			{
				hvacDc.setName(physicalLocation);
			}

			hvacDc.setMdMake(manufacturer);
			hvacDc.setMdModel(model);
			hvacDc.setMdEnergyStarFlag(Boolean.TRUE.equals(energyStar) ? "1"
					: "0");
			hvacDc.setMdYear(yearOfManufacture != null ? yearOfManufacture : 0);

			hvacDc.setMdComments(mdComments);
			hvacDc.setMdAmps(amperage != null ? amperage.doubleValue() : 0);
			hvacDc.setMdVolts(voltage != null ? voltage.doubleValue() : 0);
			hvacDc.setMdMeasuredAmps(measuredAmps != null ? measuredAmps
					.doubleValue() : 0);
			hvacDc.setMdWatts(watts != null ? watts.doubleValue() : 0);
			hvacDc.setMdMca(minimumCircuitAmps != null ? minimumCircuitAmps
					.doubleValue() : 0);
			hvacDc.setMdMaxAmpBreaker(maxBreakerAmps != null ? maxBreakerAmps
					.doubleValue() : 0);
			hvacDc.setMdRatedLoadAmps(ratedLoadAmps != null ? ratedLoadAmps
					.doubleValue() : 0);

			hvacDc.setAhEnergyStarFlag(OpsCenterConstants.FALSE);

			// hvacDc.setAhMake(airHandlerManufacturer);
			// hvacDc.setAhModel(airHandlerModel);
			// hvacDc.setAhEnergyStarFlag(Boolean.TRUE.equals(airHandlerEnergyStar)
			// ? "1" : "0");
			// hvacDc.setAhYear(airHandlerYearOfManufacture != null ?
			// airHandlerYearOfManufacture : 0);
			// hvacDc.setAhVolts(airHandlerMeasuredVolts != null ?
			// airHandlerMeasuredVolts.doubleValue() : 0);
			// hvacDc.setAhMeasuredAmps(airHandlerMeasuredAmpacityOfCompressor
			// != null ? airHandlerMeasuredAmpacityOfCompressor.doubleValue() :
			// 0);
			// hvacDc.setAhAmps(airHandlerMeasuredAmpacityOfFanOnly != null ?
			// airHandlerMeasuredAmpacityOfFanOnly.doubleValue() : 0);
			// //hvacDc.setAhMca();
			// //hvacDc.setAhKw();
			// //hvacDc.setAhWatts();

			deviceBeanFacade.createDc(hvacDc);

			TstatDcGroup tstatDcGroup = null;
			if (esiDc != null)
			{
				// 1 to 1 with hvacEsiDc
				tstatDcGroup = tstatDcGroupByHvacEsiDcId.remove(esiDc
						.getEsiDcId());
			}
			if (tstatDcGroup == null)
			{
				tstatDcGroup = new TstatDcGroup();
			}
			
			EsiDc hvacEsiDc = createEsiDc(esiDc, hvacDc, targetedEsiDcFields,
					now);

			final int hvacTypeId;
			switch (hvacType)
			{
			case ALL:
				hvacTypeId = OpsCenterConstants.HVAC_TYPE_ID_HEATPUMP_ELECTRIC;
				break;
			case AUXILIARY_GAS:
				hvacTypeId = OpsCenterConstants.HVAC_TYPE_ID_HEATPUMP_GAS;
				break;
			case GAS_HEAT:
				hvacTypeId = OpsCenterConstants.HVAC_TYPE_ID_NORMAL_GAS;
				break;
			case NORMAL:
				hvacTypeId = OpsCenterConstants.HVAC_TYPE_ID_NORMAL_ELECTRIC;
				break;
			case THIRD_PARTY_THERMOSTAT:
				hvacTypeId = OpsCenterConstants.HVAC_TYPE_ID_THIRD_PARTY;
				break;
			default:
				throw new SchemaDataInvalidException(
						"Data validation error: hvacType is not valid, required = true");
			}

			if (hvacLocationName != null)
			{
				tstatDcGroup.setName(hvacLocationName);
			} else
			{
				tstatDcGroup.setName("HVAC " + i);
			}
			HvacType type = esiBeanFacade.findHvacTypeByHvacTypeId(hvacTypeId);
			tstatDcGroup.setHvacTypeId(type);
			tstatDcGroup.setEsiId(e);

			esiBeanFacade.createTstatDcGroup(tstatDcGroup);
			DeviceType fakeDeviceType = deviceBeanFacade
					.getRefDeviceTypeByDeviceTypeId(0);
			String tstatSerialNumber = null;
			for (ConsertVppThermostat consertVppThermostat : thermostats)
			{
				try
				{
					WebServiceUtil.validate(consertVppThermostat,
							"tstatLocationName", 50, false);
					final String tstatLocationName = consertVppThermostat
							.getTstatLocationName();

					// The validation check is above
					tstatSerialNumber = consertVppThermostat
							.getTstatSerialNumber();

					WebServiceUtil.validate(consertVppThermostat,
							"wallplateSerialNumber", 50, false);
					final String wallplateSerialNumber = consertVppThermostat
							.getWallplateSerialNumber();

					WebServiceUtil.validate(consertVppThermostat, "comments",
							1048576, false);
					final String commentsTstat = consertVppThermostat
							.getComments();

					Tstat tstat = deviceBeanFacade
							.getTstatBySerialNo(tstatSerialNumber);
					if (tstat == null)
					{
						throw new SchemaDataInvalidException(
								"Thermostat Serial Number "
										+ tstatSerialNumber
										+ " is not recognized");
					}
					
					if(hvacTypeId==5 && tstat.getEsiId()!=null && esiBeanFacade.isWiFiTstatAlreadyProvisioned(tstat.getEsiId().getEsiId(), tstat))
						throw new SchemaDataInvalidException(
								"Device " + tstatSerialNumber + " already provisioned with account " + accountVppMarriage.getAccountNumber());
					
					// If RMM, then validate that the relays are good
					if (hvacRemotelyMeasuredDevice != null)
					{
						final TstatMakeModel tstatMakeModel = tstat
								.getTstatMakeModelId();
						
						// validate tstat make model
						if (hvacTypeId==5 &&!tstatMakeModel.getModel().equalsIgnoreCase(model))
							throw new SchemaDataInvalidException("Thermostat Serial Number" + tstatSerialNumber + " Invalid Hvac Model: " + model);

						if (yearOfManufacture != null && tstatMakeModel.getYear() != yearOfManufacture.intValue())
							throw new SchemaDataInvalidException("Thermostat Serial Number" + tstatSerialNumber + " Invalid Hvac Manufacturing year: " + yearOfManufacture);

						if(hvacTypeId!=5){
							/*
							 * As of this moment the 3.5 WSI code only supports
							 * classic VPP provision. I did add W3 relay support and
							 * the ability to set 4 hvac types instead of only 3.
							 * Additionally I have added really strict hvac type and
							 * tstat make model validation. This means that if the
							 * intersection between those 2 does not expects a relay
							 * value then the code expects the relay to not be
							 * passed or amps & volts to be 0.
							 * 
							 * In addition Y and G are always required meaning amps
							 * & volts > 0. Plus W is required if the hvacType=All
							 * (aka Heatpump Electric) unless the tstat model is
							 * CT30E or CT80RevA, then W2 required
							 */

							if (OpsCenterConstants.TRUE.equals(type.getMdGFlag())
									&& WebServiceUtil.killWhitespace(tstatMakeModel
											.getMdGLabel()) != null)
							{
								if (hvacDc.getMdGMeasuredAmps() <= 0
										|| hvacDc.getMdGVoltage() <= 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, a valid g relay is expected for Thermostat "
													+ tstatSerialNumber);
								}
							} else
							{
								if (hvacDc.getMdGMeasuredAmps() > 0
										|| hvacDc.getMdGVoltage() > 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, the g relay is not expected for Thermostat "
													+ tstatSerialNumber);
								}
							}
							if (OpsCenterConstants.TRUE.equals(type.getMdYFlag())
									&& WebServiceUtil.killWhitespace(tstatMakeModel
											.getMdYLabel()) != null)
							{
								if (hvacDc.getMdYMeasuredAmps() <= 0
										|| hvacDc.getMdYVoltage() <= 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, a valid y relay is expected for Thermostat "
													+ tstatSerialNumber);
								}
							} else
							{
								if (hvacDc.getMdYMeasuredAmps() > 0
										|| hvacDc.getMdYVoltage() > 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, the y relay is not expected for Thermostat "
													+ tstatSerialNumber);
								}
							}
							if (OpsCenterConstants.TRUE.equals(type.getMdY2Flag())
									&& WebServiceUtil.killWhitespace(tstatMakeModel
											.getMdY2Label()) != null)
							{
								// y2 not required
								// if (hvacDc.getMdY2MeasuredAmps() <= 0 ||
								// hvacDc.getMdY2Voltage() <= 0) throw new
								// SchemaDataInvalidException("Data validation error: Based on hvac type and tstat model, a valid y2 relay is expected, tstatSerialNumber="+tstatSerialNumber);
							} else
							{
								if (hvacDc.getMdY2MeasuredAmps() > 0
										|| hvacDc.getMdY2Voltage() > 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, the y2 relay is not expected for Thermostat "
													+ tstatSerialNumber);
								}
							}
							boolean wRequired = false;
							if (OpsCenterConstants.TRUE.equals(type.getMdWFlag())
									&& WebServiceUtil.killWhitespace(tstatMakeModel
											.getMdWLabel()) != null)
							{
								wRequired = true;
								if (hvacDc.getMdWMeasuredAmps() <= 0
										|| hvacDc.getMdWVoltage() <= 0)
								{
									throw new SchemaDataInvalidException(
											"Data validation error: Based on hvac type and thermostat model, a valid w relay is expected and w relay Amps should be greater than g relay Amps for Thermostat "
													+ tstatSerialNumber);
								}
							} else
							{
								if (hvacDc.getMdWMeasuredAmps() > 0
										|| hvacDc.getMdWVoltage() > 0)
								{
									throw new SchemaDataInvalidException(
											"Data validation error: Based on hvac type and thermostat model, the w relay is not expected for Thermostat "
													+ tstatSerialNumber);
								}
							}
							if (OpsCenterConstants.TRUE.equals(type.getMdW2Flag())
									&& WebServiceUtil.killWhitespace(tstatMakeModel
											.getMdW2Label()) != null)
							{
								// W2 is required only if W is not required
								if (!wRequired)
								{
									if (hvacDc.getMdW2MeasuredAmps() <= 0
											|| hvacDc.getMdW2Voltage() <= 0)
									{
										throw new SchemaDataInvalidException(
												"Data validation error: Based on hvac type and thermostat model, a valid w2 relay is expected and w2 relay Amps should be greater than g relay Amps for Thermostat "
														+ tstatSerialNumber);
									}
								}
							} else
							{
								if (hvacDc.getMdW2MeasuredAmps() > 0
										|| hvacDc.getMdW2Voltage() > 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, the w2 relay is not expected for Thermostat "
													+ tstatSerialNumber);
								}
							}
							if (OpsCenterConstants.TRUE.equals(type.getMdW3Flag())
									&& WebServiceUtil.killWhitespace(tstatMakeModel
											.getMdW3Label()) != null)
							{
								// w3 not required
								// if (hvacDc.getMdW3MeasuredAmps() <= 0 ||
								// hvacDc.getMdW3Voltage() <= 0) throw new
								// SchemaDataInvalidException("Data validation error: Based on hvac type and tstat model, a valid w3 relay is expected, tstatSerialNumber="+tstatSerialNumber);
							} else
							{
								if (hvacDc.getMdW3MeasuredAmps() > 0
										|| hvacDc.getMdW3Voltage() > 0)
								{
									throw new SchemaDataInvalidException(
											"Based on hvac type and thermostat model, the w3 relay is not expected for Thermostat "
													+ tstatSerialNumber);
								}
							}
						}
						}

					TstatWallPlate tstatWallPlate = null;
					if (Boolean.TRUE.equals(accountVppMarriage.isGridStream()))
					{

						tstatWallPlate = deviceBeanFacade
								.getTstatWallPlateBySerialNo(wallplateSerialNumber);

						if (tstatWallPlate == null)
						{
							throw new SchemaDataInvalidException(
									"Wallplate Serial Number "
											+ wallplateSerialNumber
											+ " is not recognized");
						}

						final Esi tstatWallPlateEsi = tstatWallPlate.getEsiId();
						final EsiTstatWallPlate esiTstatWallPlate;
						if (tstatWallPlateEsi != null)
						{
							if (tstatWallPlateEsi != e)
							{
								throw new SchemaDataInvalidException(
										"Wallplate Serial Number is already in use on account "
												+ tstatWallPlateEsi
														.getAccountId()
														.getAccountNumber());
							}
							
							esiTstatWallPlate = esitstatWallPlateByWallplateMacId
									.remove(tstatWallPlate.getDeviceMacId());
							
							EsiTstat tmpEsiTstat = esiTstatByTstatId.get(tstat.getTstatId());
							EsiTstat wallPlateEsiTstat = esiBeanFacade.getEsiTstatByDeviceMacId(tstatWallPlate.getDeviceMacId());
							if(wallPlateEsiTstat != tmpEsiTstat){
								throw new SchemaDataInvalidException(
										"Wallplate Serial Number is already in use on account "
												+ tstatWallPlateEsi
														.getAccountId()
														.getAccountNumber());
							}
							
						} else
						{
							esiTstatWallPlate = null;
						}

						tstatWallPlate.setEsiId(e);
						tstatWallPlate.setDateModified(now);
						@SuppressWarnings("unused")
						EsiTstatWallPlate myEsiTstatWallPlate = createEsiTstatWallPlate(
								esiTstatWallPlate, tstatWallPlate,
								targetedEsiTstatWallPlateFields, now);

					}

					final Esi tstatEsi = tstat.getEsiId();
					final EsiTstat esiTstat;
					if (tstatEsi != null)
					{
						esiTstat = esiTstatByTstatId.remove(tstat.getTstatId());
					} else
					{
						esiTstat = null;
					}

					final String tstatName;
					if (tstatLocationName != null)
					{
						tstatName = tstatLocationName;
					} else
					{
						tstatName = tstatSerialNumber;
					}

					tstat.setActiveFlag(OpsCenterConstants.TRUE);
					tstat.setName(tstatName);
					tstat.setComments(commentsTstat);
					tstat.setEsiId(e);
					tstat.setHvac(hvacDc);
					if (esiTstat == null)
					{
						tstat.setDeviceMqId(deviceMqId++);
					}
					tstat.setDateModified(now);

					EsiDc tstatEsiDc = esiTstat != null ? esiTstat.getEsiDcId()
							: null;

					final Dc fakeDc;
					EsiDc fakeEsiDc = null;
					if (hvacTypeId != OpsCenterConstants.HVAC_TYPE_ID_THIRD_PARTY)
					{
						if (tstatEsiDc == null)
						{
							fakeDc = new Dc();
							fakeDc.setDeployedTimestamp(now);
							fakeDc.setDeviceTypeId(fakeDeviceType); // 0
							fakeDc.setDcMakeModelId(fakeDcMakeModel); // 1
							fakeDc.setDeviceMqId(deviceMqId++);
							fakeDc.setBinarySystemName("Fake DC System");
							fakeDc.setPowerStatusFlag(OpsCenterConstants.TRUE);
							fakeDc.setActiveFlag(OpsCenterConstants.TRUE);
							fakeDc.setHoldFlag(OpsCenterConstants.TRUE);
							fakeDc.setDeleteFlag(OpsCenterConstants.FALSE);
							fakeDc.setActEnergyConsumed(9);
							fakeDc.setManageModeId(defaultManageMode); // 1
							fakeDc.setPrevManageModeId(defaultManageMode); // 1
							fakeDc.setVirtualFlag(OpsCenterConstants.TRUE);
							fakeDc.setEsiId(e);
							fakeDc.setAssetNo("x");
 							fakeDc.setMdMca(1);
							fakeDc.setMdMake("Fake");
							fakeDc.setMdEnergyStarFlag("0");
							fakeDc.setAhEnergyStarFlag("0");
							fakeDc.setMdKw(1);
							fakeDc.setMdMeasuredAmps(1);
							fakeDc.setMdModel("1");
							fakeDc.setMdVolts(1);
							fakeDc.setFwVersion("1.0");
							fakeDc.setSerialNo("1");
							fakeDc.setPurchasedBy("Purchaser");
							fakeDc.setUtilityId(utility); // 1
						}
						else
						{
							fakeDc = tstatEsiDc.getDcId();
							esiDcByDcId.remove(fakeDc.getDcId());
						}
						fakeDc.setName(tstat.getName());
						fakeDc.setComments(hvacPhysicalDevice.getComments());
						fakeDc.setDateModified(now);
						if (tstatEsiDc == null)
						{
							deviceBeanFacade.createDc(fakeDc);
						}

						tstat.setHvac(fakeDc);
						fakeEsiDc = createEsiDc(tstatEsiDc, fakeDc, targetedEsiDcFields, now);
					}
					
					String usrname=accountVppMarriage.getUserName();
					if(usrname==null)
					{
						usrname="UNAUTHENTICATED";
					}
					EsiTstat myEsiTstat = createEsiTstat(esiTstat, tstat, fakeEsiDc == null ? hvacEsiDc : fakeEsiDc, targetedEsiTstatFields, now, usrname);

					TstatDcMap tstatDcMap = tstatDcMapByEsiTstatId
							.remove(myEsiTstat.getEsiTstatId());
					if (tstatDcMap == null)
					{
						tstatDcMap = new TstatDcMap();
					}

					if (accountVppMarriage.isGridStream() != null
							&& accountVppMarriage.isGridStream())
					{
						myEsiTstat.setTstatWallPlate(tstatWallPlate);
					}

					tstatDcMap.setTstatDcGroupId(tstatDcGroup);
					tstatDcMap.setEsiDcId(hvacEsiDc);
					tstatDcMap.setEsiTstatId(myEsiTstat);
					esiBeanFacade.createTstatDcMap(tstatDcMap);
					
					provState.addEsiTstat(myEsiTstat);
					
				} catch (SchemaDataInvalidException excep)
				{
					excep.setExceptionParams(new Object[] {
							"tstatSerialNumber", tstatSerialNumber });
					throw excep;
				} 
			}
			acceptsProgram = true;
		}

		 

		/*
		 * Handling LCS Devices lcsDevices (consertVppLcsChain 0/unbounded) 
		 *  - consertSerialNumber (String) LCS.GS_SBR_SERIAL_NO 
		 *  - relays (consertVppRelayChain 0/unbounded) 
		 *  - - relay (consertVppRelay 1/1) -
		 *  - - - id (int - must be 1 or 2) ESI_DC.RELAY_ID 
		 *  - - - relayName (String 50) ESI_DC.NAME & DC.NAME 
		 *  - - - comments (String 1048576) ESI_DC.COMMENTS & DC.COMMENTS 
		 *  - - - remotelyMeasured (boolean - if true consertVppBinaryPhysicalDevice.volts & consertVppBinaryPhysicalDevice.amps must be > 0 DC.LCS_RMM_FLAG 
		 *  - - - voltsScalar (decimal - null defaults to 1) DC.SCALAR_AMPS 
		 *  - - - ampsScalar (decimal - null defaults to 1) DC.SCALAR_VOLTS 
		 *  - - - remoteMeterRead (boolean - if true provide Meter lanAddress_
		 *  - - - lanAddress (String - meter lan address)
		 *  - - - rmrCtFactor (int - must be between 0 - 255)
		 *  - - relayPhysicalDevice (consertVppBinaryPhysicalDevice) 1/1 Hierarchy ESI_LCS (only one non-deleted entry per LCS) LCS ESI_DC (Each for a
		 * 			realy) DC (Each for a realy)
		 */

		final List<ConsertVppLcsChain> lcsDevicesList = accountVppMarriage
				.getLcsDevices();
		final List<String> targetedEsiLcsFields = getTargetedPropertyNames(EsiLcs.class);
		String lcsSerialNumber = null;

		try
		{
			for (ConsertVppLcsChain lcsDevice : lcsDevicesList)
			{

				WebServiceUtil.validate(lcsDevice, "consertSerialNumber", 50,
						true);
				lcsSerialNumber = WebServiceUtil.killWhitespace(lcsDevice
						.getConsertSerialNumber());
				log.info("Found LCS Devices : " + lcsSerialNumber);
				final Lcs lcs = deviceBeanFacade
						.getLcsByGsSbrSerialNo(lcsSerialNumber);
				if (lcs == null)
				{
					throw new SchemaDataInvalidException(
							"LCS Serial Number "
									+ lcsSerialNumber
									+ " is not recognized");
				}

				final Esi lcsEsi = lcs.getEsiId();
				EsiLcs esiLcs;
				if (lcsEsi != null)
				{
					if (lcsEsi != e)
					{
						// DEV-3287: Move 1 device from one account to another
						final boolean allowAccountSwap = Boolean.TRUE.equals(accountVppMarriage.isAllowAccountSwapForGridStream()) && Boolean.TRUE.equals(accountVppMarriage.isGridStream());
						if (allowAccountSwap)
						{							
							EsiLcs accountSwapEsiLcs = esiBeanFacade.getEsiLcsByDeviceMacId(lcs.getDeviceMacId());
							// Remove device from old account
							flagEntireEsiLcsAsDeleted(accountSwapEsiLcs, false, now);
							
							cacheManager.clearGSDeviceDCData(lcs.getDeviceMacId());
						}
						else
						{
							throw new SchemaDataInvalidException(
									"This LCS Device Serial Number ("
											+ lcsSerialNumber
											+ ") is already associated to accountNumber "
											+ lcsEsi.getAccountId()
													.getAccountNumber());
						}
					}
					EsiLcs tempEsiLcs = esiLcsByLcsId.remove(lcs
							.getDeviceMacId());
					if (tempEsiLcs != null)
					{
						esiLcs = tempEsiLcs;
					} else
					{
						esiLcs = esiBeanFacade.getEsiLcsByDeviceMacId(lcs
								.getDeviceMacId());
					}
				} else
				{
					esiLcs = null;
				}

				// Relays
				List<ConsertVppRelayChain> relaysList = lcsDevice.getRelays();
				for (ConsertVppRelayChain relays : relaysList)
				{

					ConsertVppRelay relay = relays.getRelay();
					ConsertVppBinaryPhysicalDevice binaryPhysicalDevice = relays
							.getRelayPhysicalDevice();

					if (relay == null)
					{
						throw new SchemaDataInvalidException(
								"At least one relay is required for LCS Serial Number "
										+ lcsSerialNumber);
					}
					if (binaryPhysicalDevice == null)
					{
						throw new SchemaDataInvalidException(
								"Binary Device for is required for LCS Serial Number "
										+ lcsSerialNumber);
					}

					// Relay
					Integer relayId = relay.getId();
					
					if (relayId != 1 && relayId != 2 && relayId != 3 && relayId != 4)
					{
						throw new SchemaDataInvalidException(
								"Relay Id must be either 1 or 2 or 3 or 4 for LCS Serial Number "
										+ lcsSerialNumber);
					}

					DcMakeModel lcsMakeModel = lcs.getDcMakeModelId();
					fakeDcMakeModel = lcsMakeModel==null?fakeDcMakeModel:lcsMakeModel;
					if (lcsMakeModel != null
								&& ((relayId == 1 && lcsMakeModel.getRelay1Amps() == null)
								|| (relayId == 2 && lcsMakeModel.getRelay2Amps() == null)
								|| (relayId == 3 && lcsMakeModel.getRelay3Amps() == null) 
								|| (relayId == 4 && lcsMakeModel.getRelay4Amps() == null)))
					{
						throw new SchemaDataInvalidException(
								"This make model does not support Relay "
										+ relayId + " for " + lcsSerialNumber);
					}

					WebServiceUtil.validate(relay, "relayName", 50, false);
					String relayName = WebServiceUtil.killWhitespace(relay
							.getRelayName());

					WebServiceUtil.validate(relay, "comments", 1048576, false); 
					String comments = WebServiceUtil.killWhitespace(relay
							.getComments());

					Boolean isRemotelyMeasured = relay.isRemotelyMeasured() == null ? false
							: relay.isRemotelyMeasured();
					final BigDecimal voltsScalar = relay.getVoltsScalar();
					final BigDecimal ampsScalar = relay.getAmpsScalar();
					
					// binaryDevice
					final ConsertVppBinaryDeviceType binaryDeviceType = binaryPhysicalDevice
							.getBinaryDeviceType();
					if (binaryDeviceType == null)
					{
						throw new SchemaDataInvalidException(
								"Binary Device Type is not valid for LCS Serial Number "
										+ lcsSerialNumber);
					}

					final BigDecimal binaryDeviceVolts = binaryPhysicalDevice
							.getVolts();
					final BigDecimal binaryDeviceWatts = binaryPhysicalDevice
							.getWatts();
					final BigDecimal binaryDeviceAmperage = binaryPhysicalDevice
							.getAmps();

					WebServiceUtil.validate(binaryPhysicalDevice, "model", 255,
							false);
					final String binaryDeviceModel = WebServiceUtil
							.killWhitespace(binaryPhysicalDevice.getModel());
					final BigDecimal binaryDeviceMeasuredAmpacity = binaryPhysicalDevice
							.getMeasuredAmps();
					final BigDecimal binaryDeviceMinimumCircuitAmps = binaryPhysicalDevice
							.getMinimumCircuitAmps();
					final String binaryDevicePhysicalLocation = binaryPhysicalDevice
							.getPhysicalLocation();
					final Integer binaryDeviceYearOfManufacture = binaryPhysicalDevice
							.getYearOfManufacture();
					final Boolean binaryDeviceEnergyStar = binaryPhysicalDevice
							.isEnergyStar();
					final BigDecimal maxBreakerAmps = binaryPhysicalDevice
							.getMaxBreakerAmps();
					final BigDecimal ratedLoadAmps = binaryPhysicalDevice
							.getRatedLoadAmps();

					OpsCenterConstants.DeviceType type = OpsCenterConstants.DeviceType
							.fromWsiValue(binaryDeviceType.value());
					final int deviceTypeId = type.getId();

					if (isRemotelyMeasured)
					{
						if (binaryDeviceVolts == null
								|| binaryDeviceVolts.doubleValue() <= 0)
						{
							throw new SchemaDataInvalidException(
									"Volts must be greater than 0 for LCS Serial Number "
											+ lcsSerialNumber);
						}
						if (binaryDeviceMeasuredAmpacity == null
								|| binaryDeviceMeasuredAmpacity.doubleValue() <= 0)
						{
							throw new SchemaDataInvalidException(
									"Measured Amps must be greater than 0 for LCS Serial Number "
											+ lcsSerialNumber);
						}
					}

					// Get ESIDc for deviceMacId & Relay
					log.info("Relay Id : " + relayId);
					log.info("Relay Name : " + relayName);
					log.info("Relay Comments : " + comments);
					final List<EsiDc> lcsEsiDcList = esiBeanFacade
							.getEsiDcByDevMacIdAndRelay(lcs.getDeviceMacId(),
									relayId.toString());
					EsiDc lcsEsiDc = lcsEsiDcList == null
							|| lcsEsiDcList.isEmpty() ? null : lcsEsiDcList
							.get(0);
					
					/* RMR (Remote Meter Read)*/
					Boolean isRemoteMeterRead = relay.isRemoteMeterRead() == null ? false : relay.isRemoteMeterRead();
					// LanAddress
					WebServiceUtil.validate(relay, "lanAddress", 100, false);
					String lanAddress = WebServiceUtil.killWhitespace(relay.getLanAddress());
					
					Integer rmrCtFactor = relay.getRmrCtFactor() == null ? 1 : relay.getRmrCtFactor();

					if(null!=lanAddress && !"".equals(lanAddress)){
						try{
							Long.parseLong(lanAddress, 16);
						}catch (NumberFormatException nfe){
							throw new SchemaDataInvalidException("Lan Address is not valid");
						}
						List<EsiDc> esiDcLanList = esiBeanFacade.getEsiDcByLanAddress(lanAddress);
						for(EsiDc esiDcLan : esiDcLanList){
							if(null == lcsEsiDc || esiDcLan.getEsiDcId()!=lcsEsiDc.getEsiDcId()){
								throw new SchemaDataInvalidException("Lan Address is already in use " + lanAddress);
							}
						}
					}
					
					final Dc fakeDc;
					if (lcsEsiDc == null)
					{
						fakeDc = new Dc();
						fakeDc.setDeployedTimestamp(now);
						fakeDc.setDeviceTypeId(deviceBeanFacade
								.getRefDeviceTypeByDeviceTypeId(deviceTypeId));
						fakeDc.setDcMakeModelId(fakeDcMakeModel); // 1
						fakeDc.setDeviceMqId(deviceMqId++);
						fakeDc.setBinarySystemName("Fake DC System");
						fakeDc.setPowerStatusFlag(OpsCenterConstants.TRUE);
						fakeDc.setActiveFlag(OpsCenterConstants.TRUE);
						fakeDc.setHoldFlag(OpsCenterConstants.TRUE);
						fakeDc.setDeleteFlag(OpsCenterConstants.FALSE);
						fakeDc.setActEnergyConsumed(9);
						fakeDc.setManageModeId(defaultManageMode); // 1
						fakeDc.setPrevManageModeId(defaultManageMode); // 1
						fakeDc.setVirtualFlag(OpsCenterConstants.FALSE);
						fakeDc.setEsiId(e);
						fakeDc.setAssetNo("x");
 						fakeDc.setMdMake("Fake");
						fakeDc.setMdEnergyStarFlag("1");
						fakeDc.setAhEnergyStarFlag("1");
						fakeDc.setMdKw(1);
						fakeDc.setFwVersion("1.0");
						fakeDc.setSerialNo("1");
						fakeDc.setPurchasedBy("Purchaser");
						fakeDc.setUtilityId(utility); // 1
					} else
					{
						fakeDc = lcsEsiDc.getDcId();
						esiDcByDcId.remove(fakeDc.getDcId());
					}


					if (binaryDevicePhysicalLocation != null)
					{
						relayName = binaryDevicePhysicalLocation;
					} else
					{
						relayName = lcsSerialNumber;
						relayName = type.getValue() + ": " + relayName;
					}
						
				
					fakeDc.setName(relayName);
					if (null == comments)
					{
						comments = binaryPhysicalDevice.getComments();
					}
					fakeDc.setComments(comments);
					fakeDc.setLcsRmmFlag(isRemotelyMeasured ? OpsCenterConstants.TRUE
							: OpsCenterConstants.FALSE);
					fakeDc.setScalarVolts(voltsScalar != null ? voltsScalar
							.doubleValue() : 1);
					fakeDc.setScalarAmps(ampsScalar != null ? ampsScalar
							.doubleValue() : 1);
					fakeDc.setMdVolts(binaryDeviceVolts != null ? binaryDeviceVolts
							.doubleValue() : 0);
					fakeDc.setMdAmps(binaryDeviceAmperage != null ? binaryDeviceAmperage
							.doubleValue() : 0);
					fakeDc.setMdWatts(binaryDeviceWatts != null ? binaryDeviceWatts
							.doubleValue() : 0);
					fakeDc.setMdModel(binaryDeviceModel != null ? binaryDeviceModel
							: fakeDcMakeModel.getModel());
					fakeDc.setMdMeasuredAmps(binaryDeviceMeasuredAmpacity != null ? binaryDeviceMeasuredAmpacity
							.doubleValue() : 1);
					fakeDc.setMdMca(binaryDeviceMinimumCircuitAmps != null ? binaryDeviceMinimumCircuitAmps
							.doubleValue() : 0);
					fakeDc.setMdYear(binaryDeviceYearOfManufacture != null ? binaryDeviceYearOfManufacture
							.intValue() : 0);
					fakeDc.setMdMaxAmpBreaker(maxBreakerAmps != null ? maxBreakerAmps
							.doubleValue() : 0);
					fakeDc.setMdRatedLoadAmps(ratedLoadAmps != null ? ratedLoadAmps
							.doubleValue() : 0);
					fakeDc.setRmrFlag(isRemoteMeterRead ? OpsCenterConstants.TRUE 	: OpsCenterConstants.FALSE);
					fakeDc.setLanAddress(lanAddress);
					fakeDc.setRmrCtFactor(rmrCtFactor);
					String energyStarFlag = "1";
					if (binaryDeviceEnergyStar != null)
					{
						energyStarFlag = Boolean.TRUE
								.equals(binaryDeviceEnergyStar) ? "1" : "0";
					}
					fakeDc.setMdEnergyStarFlag(energyStarFlag);
					fakeDc.setEsiId(e);
					fakeDc.setDateModified(now);

					if (lcsEsiDc == null)
					{
						deviceBeanFacade.createDc(fakeDc);
					}

					EsiDc fakeEsiDc = createEsiDc(lcsEsiDc, fakeDc,
							targetedEsiDcFields, now);
					fakeEsiDc.setRelayId(relayId.toString());
					fakeEsiDc.setDeviceMacId(lcs.getDeviceMacId());
					fakeEsiDc.setEsiId(e);

				}
				String usrname=accountVppMarriage.getUserName();
				if(usrname==null)
				{
					usrname="UNAUTHENTICATED";
				}
				log.info("username in persistVppDevices : "+usrname);
				esiLcs = createEsiLcs(esiLcs, lcs, targetedEsiLcsFields, now,usrname);
				esiLcs.setEsiId(e);
				esiLcs.setLcsId(lcs);
				lcs.setEsiId(e);
				
				provState.addEsiLcs(esiLcs);
				
				acceptsProgram = true;
			}
		} catch (SchemaDataInvalidException exp)
		{
			exp.setExceptionParams(new Object[] { "lcsSerialNumber",
					lcsSerialNumber });
			throw exp;
		}

		
		//
		
//		if (!esiDcByDcId.isEmpty())
//		{
//			Collection<EsiDc> esiDcsToDelete = esiDcByDcId.values();
//			StringBuffer serialNo = new StringBuffer("");
//			for (EsiDc esiDc : esiDcsToDelete)
//			{
//				if (esiDc.getRelayId() != null)
//				{ // LCS
//					serialNo.append(", ");
//					serialNo.append(" (Relay Id) " + esiDc.getRelayId());
//				} else
//				{
//					Dc dc = esiDc.getDcId();
//					if (dc != null)
//					{
//						serialNo.append(", ");
//						serialNo.append(dc.getSerialNo());
//					}
//				}
//			}
//			throw new SchemaDataInvalidException(
//					"Data error: Existing Devices can not be de provision, Serial Numbers are =  "
//							+ serialNo.toString().substring(2));
//		}
//
//		if (!esiTstatByTstatId.isEmpty())
//		{
//			Collection<EsiTstat> esiTstatsToDelete = esiTstatByTstatId.values();
//			StringBuffer serialNo = new StringBuffer("");
//			for (EsiTstat esiTstat : esiTstatsToDelete)
//			{
//				Tstat tstat = esiTstat.getTstatId();
//				if (tstat != null)
//				{
//					serialNo.append(", ");
//					serialNo.append(tstat.getSerialNo());
//				}
//			}
//			throw new SchemaDataInvalidException(
//					"Data error: Existing Tstat can not be de provision, Serial Numbers are = "
//							+ serialNo.toString().substring(2));
//		}
//
//		if (!esiZigbeeByZigbeeId.isEmpty())
//		{
//			Collection<EsiZigbee> esiZigbeesToDelete = esiZigbeeByZigbeeId
//					.values();
//			StringBuffer serialNo = new StringBuffer("");
//			for (EsiZigbee esiZigbee : esiZigbeesToDelete)
//			{
//				Zigbee zigbee = esiZigbee.getZigbeeId();
//				if (zigbee != null)
//				{
//					serialNo.append(", ");
//					serialNo.append(zigbee.getSerialNo());
//				}
//			}
//			throw new SchemaDataInvalidException(
//					"Data error: Existing Zigbee can not be de provision, Serial Numbers are = "
//							+ serialNo.toString().substring(2));
//		}
//
//		if (!tstatDcMapByEsiTstatId.isEmpty())
//		{
//			Collection<TstatDcMap> tstatDcMapsToDelete = tstatDcMapByEsiTstatId
//					.values();
//			StringBuffer serialNo = new StringBuffer("");
//			for (TstatDcMap tstatDcMap : tstatDcMapsToDelete)
//			{
//				Tstat tstat = tstatDcMap.getEsiTstatId().getTstatId();
//				if (tstat != null)
//				{
//					serialNo.append(", ");
//					tstat.getSerialNo();
//				}
//			}
//			throw new SchemaDataInvalidException(
//					"Data error: Existing TstatDc can not be de provision, Serial Numbers are = "
//							+ serialNo.toString().substring(2));
//		}
//
//		if (!tstatDcGroupByHvacEsiDcId.isEmpty()
//				&& e.getNetworkDeliveryId() != 2)
//		{
//			throw new SchemaDataInvalidException(
//					"Data error: Existing Devices can not be de provision ");
//		}
//
//		if (!esitstatWallPlateByWallplateMacId.isEmpty())
//		{
//			Collection<EsiTstatWallPlate> esiTstatWallplateToDelete = esitstatWallPlateByWallplateMacId
//					.values();
//			StringBuffer serialNo = new StringBuffer("");
//			for (EsiTstatWallPlate esiTstatWallPlate : esiTstatWallplateToDelete)
//			{
//				TstatWallPlate tstatWallPlate = esiTstatWallPlate
//						.getTstatWallPlateId();
//				if (tstatWallPlate != null)
//				{
//					serialNo.append(", ");
//					serialNo.append(tstatWallPlate.getGsSbrSerialNo());
//				}
//			}
//			throw new SchemaDataInvalidException(
//					"Data error: Existing TstatWallplate devices can not be de provision, Serial Numbers are = "
//							+ serialNo.toString().substring(2));
//		}
//
//		if (!esiLcsByLcsId.isEmpty())
//		{
//			Collection<EsiLcs> esiLcsToDelete = esiLcsByLcsId.values();
//			StringBuffer serialNo = new StringBuffer("");
//			for (EsiLcs esiLcs : esiLcsToDelete)
//			{
//				Lcs lcs = esiLcs.getLcsId();
//				if (lcs != null)
//				{
//					serialNo.append(", ");
//					serialNo.append(lcs.getGsSbrSerialNo());
//				}
//			}
//			throw new SchemaDataInvalidException(
//					"Data error: Existing Lcs can not be de provision, Serial Numbers are =  "
//							+ serialNo.toString().substring(2));
//		}
		return acceptsProgram;
	}

	private final double getMeasuredAmps(ConsertRelay relay)
	{
		final double measuredAmps = relay != null ? decimalToDouble(relay
				.getMeasuredAmps()) : 0d;
		return measuredAmps < 0 ? 0d : measuredAmps;
	}

	private final double getVolts(ConsertRelay relay)
	{
		final double volts = relay != null ? decimalToDouble(relay.getVolts())
				: 0d;
		return volts < 0 ? 0d : volts;
	}

	/**
	 * @param gRelay
	 * @return
	 */
	private final double decimalToDouble(BigDecimal decimal)
	{
		return decimal != null ? decimal.doubleValue() : 0d;
	}

	/**
	 * @param dc
	 * @param targetedEsiDcFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private EsiDc createEsiDc(EsiDc inEsiDc, Dc dc,
			List<String> targetedEsiDcFields, DateTime now)
			throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException
	{
		final EsiDc esiDc = inEsiDc == null ? new EsiDc() : inEsiDc;
		for (String field : targetedEsiDcFields)
		{
			if (!"dcId".equals(field))
			{
				Object o = null;
				boolean valid = true;
				try
				{
					o = PropertyUtils.getSimpleProperty(dc, field);
				} catch (Exception e)
				{
					// Don't care if the source does not have field
					valid = false;
				}
				if (valid)
				{
					PropertyUtils.setSimpleProperty(esiDc, field, o);
				}
			}
		}
		esiDc.setDcId(dc);
		if (inEsiDc == null)
		{
			esiDc.setDateCreated(now);
			esiBeanFacade.createEsiDc(esiDc);
		} else
		{
			esiDc.setDateUpdated(now);
		}
		return esiDc;
	}

	/**
	 * @param tstat
	 * @param targetedTstatDcFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private EsiTstat createEsiTstat(EsiTstat inEsiTstat, Tstat tstat,
			EsiDc fakeEsiDc, List<String> targetedEsiTstatFields, DateTime now, String usrname)
			throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException
	{
		final EsiTstat esiTstat = inEsiTstat == null ? new EsiTstat()
				: inEsiTstat;
		for (String field : targetedEsiTstatFields)
		{
			if (!"tstatId".equals(field))
			{
				Object o = null;
				boolean valid = true;
				try
				{
					o = PropertyUtils.getSimpleProperty(tstat, field);
				} catch (Exception e)
				{
					// Don't care if the source does not have field
					valid = false;
				}
				if (valid)
				{
					PropertyUtils.setSimpleProperty(esiTstat, field, o);
				}
			}
		}
		if (inEsiTstat == null)
		{
			esiTstat.setTstatId(tstat);
			esiTstat.setEsiDcId(fakeEsiDc);
			esiTstat.setDateCreated(now);
			esiTstat.setUsrCreated(usrname);
			log.debug("Tstat created by user "+usrname);
			esiBeanFacade.createEsiTstat(esiTstat);
		} else
		{
			esiTstat.setDateUpdated(now);
		}
		return esiTstat;
	}

	/**
	 * @param lcs
	 * @param targetedLcsDcFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private EsiLcs createEsiLcs(EsiLcs inEsiLcs, Lcs lcs,
			List<String> targetedEsiLcsFields, DateTime now, String usrname)
			throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException
	{
		log.info("Inside createEsiLcs");
		final EsiLcs esiLcs = inEsiLcs == null ? new EsiLcs() : inEsiLcs;
		for (String field : targetedEsiLcsFields)
		{
			if (!"lcsId".equals(field) && !"deviceMacId".equals(field))
			{
				Object o = null;
				boolean valid = true;
				try
				{
					o = PropertyUtils.getSimpleProperty(lcs, field);
				} catch (Exception e)
				{
					// Don't care if the source does not have field
					valid = false;
				}
				if (valid)
				{
					PropertyUtils.setSimpleProperty(esiLcs, field, o);
				}
			}
		}
		if (inEsiLcs == null)
		{
			esiLcs.setLcsId(lcs);
			esiLcs.setDateCreated(now);
			esiLcs.setUsrCreated(usrname);
			log.debug("LCS created by user "+usrname);
			esiBeanFacade.createEsiLcs(esiLcs);
		} else
		{
			log.info("Inside else to update");
			esiLcs.setDateUpdated(now);
		}
		return esiLcs;
	}

 
	/**
	 * @param zigbee
	 * @param targetedEsiZigbeeFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private EsiTstatWallPlate createEsiTstatWallPlate(
			EsiTstatWallPlate inEsiTstatWallPlate,
			TstatWallPlate tstatWallPlate,
			List<String> targetedEsiTstatWallPlateFields, DateTime now)
			throws IllegalAccessException, InvocationTargetException,
			NoSuchMethodException
	{
		final EsiTstatWallPlate esiTstatWallPlate = inEsiTstatWallPlate == null ? new EsiTstatWallPlate()
				: inEsiTstatWallPlate;
		for (String field : targetedEsiTstatWallPlateFields)
		{
			if (!"tstatWallPlateId".equals(field))
			{
				Object o = null;
				boolean valid = true;
				try
				{
					o = PropertyUtils.getSimpleProperty(tstatWallPlate, field);
				} catch (Exception e)
				{
					// Don't care if the source does not have field
					valid = false;
				}
				if (valid)
				{
					PropertyUtils
							.setSimpleProperty(esiTstatWallPlate, field, o);
				}
			}
		}
		if (inEsiTstatWallPlate == null)
		{
			esiTstatWallPlate.setTstatWallPlateId(tstatWallPlate);
			esiTstatWallPlate.setDateCreated(now);
			esiBeanFacade.createEsiTstatWallPlate(esiTstatWallPlate);
		} else
		{
			esiTstatWallPlate.setDateUpdated(now);
		}
		return esiTstatWallPlate;
	}

	@Override
	public ConsertAccountProvisioningResponse vppAccountSwap(
			ConsertAccountVppSwapRequest request)
	{
		TenantPropertyUtil.getTenantId(wsctx);

		String accountNumber = request.getAccountNumber();
		String electricMeterNumber = request.getElectricMeterNumber();
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();
		final String standaloneGatewaySerialNumber = request
				.getStandaloneGatewaySerialNumber();

		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowTypeId(esiBeanFacade
						.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
		gatewayMessagingWorkflow
				.setGatewayMessagingWorkflowOriginId(esiBeanFacade
						.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_SWAP));

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		gatewayMessagingWorkflow.setUsrCreated(userCreated);

		Exception exception = null;

		try
		{

			populateWorkflowWithReply(gatewayMessagingWorkflow,
					request.getReply());

			Esi esi = consertAccountProvisioning
					.electricMeterGatewaySwapPersist(accountNumber,
							compoundAccountKey, electricMeterNumber,
							standaloneGatewaySerialNumber);

			gatewayMessagingWorkflow.setEsiId(esi);

		} catch (Exception e1)
		{
			exception = e1;

			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to VppAccount_Swap", e1);

			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();

			if (electricMeterNumber != null)
			{
				ConsertErrorById error2 = new ConsertErrorById();
				error2.setObjectType("electricMeterNumber");
				error2.setObjectId(electricMeterNumber);
				errorObjectDetails.add(error2);
			}

			if (standaloneGatewaySerialNumber != null)
			{
				ConsertErrorById error2 = new ConsertErrorById();
				error2.setObjectType("standaloneGatewaySerialNumber");
				error2.setObjectId(standaloneGatewaySerialNumber);
				errorObjectDetails.add(error2);
			}

			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);

			response.setError(consertCreateUpdateError);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}
		response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
				: ConsertAccountProvisioningResponseStatus.ERROR);
		gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow,
				exception);
		response.setTrackingId(gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowId());
		final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
				.getGatewayMessagingWorkflowOriginId();
		if (gatewayMessagingWorkflowOriginId != null)
		{
			response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
		}
		response.setResponseTime(datatypeFactory
				.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	@Override
	public List<ConsertAccountProvisioningResponse> accountDeprovisionSimple(
			ConsertAccountDeprovisionSimpleRequest request)
	{
		TenantPropertyUtil.getTenantId(wsctx);
		
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		String accountNumber = request.getAccountNumber();
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();
		ConsertError consertCreateUpdateError = null;
		DatatypeFactory datatypeFactory = null;
		Exception exception = null;
		Esi oldEsi = null;
		ProvisioningEsiBean provState = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}
		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}		
		try
		{
			RemovalCode removalCode = null;
			if (request.getRemovalReasonCode() != null)
			{
				removalCode = genericFacade.getRefRemovalCodeById(request
						.getRemovalReasonCode());
			}

			provState = consertAccountProvisioning.accountDeprovisionPersist(
					accountNumber, compoundAccountKey, userCreated,
					removalCode, request.getRemovalNetsuiteTicket());

			// gatewayMessagingWorkflow.setEsiId(oldEsi);
		} catch (Exception e)
		{
			exception = e;

			AbstractOpsCenterException abstractOpsCenterException = null;
			final String errorCode;
			if (e instanceof ConfigurationException_Exception)
			{
				errorCode = ((ConfigurationException_Exception) e)
						.getFaultInfo().getErrorCode();
			} else if (e instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
			}

			log.error("Failed to Account_DeprovisionSimple", e);

			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);

			if (abstractOpsCenterException != null)
			{
				abstractOpsCenterException
						.setContext(getContext(errorObjectDetails));
			}
		}

		boolean isGridStream = false;
		int workflowTypeId;
		int workflowOriginId;

		oldEsi = provState.getEsi();
		
		if (oldEsi != null && oldEsi.getNetworkDeliveryId() == 2)
		{
			isGridStream = true;
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_DEPROVISIONING;
		} else
		{
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING_RESET;
		}
		workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ACCOUNT_DEPROVISIONSIMPLE;

		if (isGridStream && exception == null && oldEsi != null)
		{
			/*List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(oldEsi.getEsiId());
			List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(oldEsi.getEsiId());*/
			List<EsiTstat> esiTstatList = provState.getEsiTstatList();
			List<EsiLcs> esiLcsList = provState.getEsiLcsList();

			log.debug("Deprovision Workflow start for Tstats "+ esiTstatList.size() + " Lcs " + esiLcsList.size()  );
			
			for (EsiTstat esiTstat : esiTstatList)
			{
				TstatWallPlate tstatWallPlate = esiTstat.getTstatWallPlate();
				if (tstatWallPlate != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
	
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowTypeId(esiBeanFacade
									.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowOriginId(esiBeanFacade
									.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(oldEsi);
					gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow,
								request.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(
							gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowId());				
					response.setWallplateSerialNumber(tstatWallPlate.getGsSbrSerialNo());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId
								.getName());
					}
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}

			for (EsiLcs esiLcs : esiLcsList)
			{
				Lcs lcsId = esiLcs.getLcsId();
				if (lcsId != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
	
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowTypeId(esiBeanFacade
									.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowOriginId(esiBeanFacade
									.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(oldEsi);
					gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow,
								request.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(
							gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowId());
					
					response.setLcsSerialNumber(lcsId.getGsSbrSerialNo());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId
								.getName());
					}
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}
		} else
		{
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);
			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowTypeId(esiBeanFacade
							.getRefGatewayMessagingWorkflowType(workflowTypeId));
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowOriginId(esiBeanFacade
							.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
			gatewayMessagingWorkflow.setEsiId(oldEsi);
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			try
			{
				populateWorkflowWithReply(gatewayMessagingWorkflow,
						request.getReply());
			} catch (SchemaDataInvalidException exp)
			{
				exception = exp;
				exp.printStackTrace();
			}
			gatewayMessagingWorkflowBean.startWorkflow(
					gatewayMessagingWorkflow, exception);
			response.setTrackingId(gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				response.setTrackingType(gatewayMessagingWorkflowOriginId
						.getName());
			}
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}
		return responseList;

	}

	@Override
	public List<ConsertAccountProvisioningResponse> accountReprovisionSimple(
			ConsertAccountReprovisionSimpleRequest request)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return accountReprovisionSimple(request, tenantId);
	}
	
	/**
	 * 
	 */
	@Override
	public List<ConsertAccountProvisioningResponse> accountReprovisionSimple(
			ConsertAccountReprovisionSimpleRequest request, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		ConsertError consertCreateUpdateError = null;
		DatatypeFactory datatypeFactory = null;

		String accountNumber = request.getAccountNumber();
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();

		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}

		Exception exception = null;
		Esi oldEsi = null;
		try
		{

			oldEsi = consertAccountProvisioning.accountReprovisionPersist(
					accountNumber, compoundAccountKey, userCreated);
		} catch (Exception e)
		{
			exception = e;

			final AbstractOpsCenterException abstractOpsCenterException;
			final String errorCode;
			if (e instanceof ConfigurationException_Exception)
			{
				errorCode = ((ConfigurationException_Exception) e)
						.getFaultInfo().getErrorCode();
				abstractOpsCenterException = null;
			} else if (e instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}

			log.error("Failed to Account_ReprovisionSimple", e);

			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);
		}

		boolean isGridStream = false;
		int workflowTypeId;
		int workflowOriginId;

		if (oldEsi != null && oldEsi.getNetworkDeliveryId() == 2)
		{
			isGridStream = true;
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING;
		} else
		{
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING;
		}
		workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ACCOUNT_REPROVISIONSIMPLE;

		if (isGridStream && exception == null && oldEsi != null)
		{

			final List<EsiTstat> esiTstatList = esiBeanFacade
					.getEsiTstatByEsiId(oldEsi.getEsiId());
			for (EsiTstat esiTstat : esiTstatList)
			{
				TstatWallPlate tstatWallPlate = esiTstat.getTstatWallPlate();
				if (tstatWallPlate != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowTypeId(esiBeanFacade
									.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowOriginId(esiBeanFacade
									.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(oldEsi);
					gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow,
								request.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(
							gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowId());
					response.setWallplateSerialNumber(tstatWallPlate.getGsSbrSerialNo());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId
								.getName());
					}
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}
			final List<EsiLcs> esiLcsList = esiBeanFacade
					.getEsiLcsByEsiId(oldEsi.getEsiId());
			for (EsiLcs esiLcs : esiLcsList)
			{
				Lcs lcsId = esiLcs.getLcsId();
				if (lcsId != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
	
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowTypeId(esiBeanFacade
									.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow
							.setGatewayMessagingWorkflowOriginId(esiBeanFacade
									.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(oldEsi);
					gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow,
								request.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(
							gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowId());
					response.setLcsSerialNumber(lcsId.getGsSbrSerialNo());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
							.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId
								.getName());
					}
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}
		} else
		{
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);
			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowTypeId(esiBeanFacade
							.getRefGatewayMessagingWorkflowType(workflowTypeId));
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowOriginId(esiBeanFacade
							.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
			gatewayMessagingWorkflow.setEsiId(oldEsi);
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			try
			{
				populateWorkflowWithReply(gatewayMessagingWorkflow,
						request.getReply());
			} catch (SchemaDataInvalidException exp)
			{
				exception = exp;
				exp.printStackTrace();
			}
			gatewayMessagingWorkflowBean.startWorkflow(
					gatewayMessagingWorkflow, exception);
			response.setTrackingId(gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				response.setTrackingType(gatewayMessagingWorkflowOriginId
						.getName());
			}
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}
		return responseList;
	}

	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioningLocal#accountDeprovisionPersist(java.lang.String,
	 *      com.consert.service.ns.xml.ConsertCompoundAccountKey,
	 *      java.lang.String)
	 */
	@Override
	public ProvisioningEsiBean accountDeprovisionPersist(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey, String user,
			RemovalCode removalReasonCode, String removalNetsuiteTicket)
			throws AbstractOpsCenterException
	{
		CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();

		AccountPartsModel accountParts;
		try
		{
			accountParts = compoundAccountKeyUtility.getAccountParts();
		} catch (Exception e)
		{
			// Compound Account Key Error
			throw new CompoundAccountKeyException("Unexpected Error", e);
		}
		Account oldAccount = getAccount(accountNumber, compoundAccountKey,
				accountParts);
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(oldAccount
				.getAccountId());
		Esi oldEsi = esiList == null || esiList.isEmpty() ? null : esiList
				.get(0);
		if (oldEsi == null)
		{
			throw new EsiNotFoundException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"Account not provisioned ");
		}
		 

		ProvisioningEsiBean provEsiBean = new ProvisioningEsiBean();
		
		accountDeprovision(oldEsi, null, user,
				removalReasonCode, removalNetsuiteTicket, provEsiBean);
		return provEsiBean;
	}

	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioningLocal#accountReprovisionPersist(java.lang.String,
	 *      com.consert.service.ns.xml.ConsertCompoundAccountKey,
	 *      java.lang.String)
	 */
	@Override
	public Esi accountReprovisionPersist(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey, String userCreated)
			throws Exception
	{

		CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
		final AccountPartsModel accountParts;
		try
		{
			accountParts = compoundAccountKeyUtility.getAccountParts();
		} catch (Exception e)
		{
			// Compound Account Key Error
			throw new CompoundAccountKeyException("Unexpected Error", e);
		}

		final DateTime now = new DateTime();

		// Always returns an account, otherwise it throws an exception
		final Account account = getAccount(accountNumber, compoundAccountKey,
				accountParts);
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
				.getAccountId());
		final Esi e = esiList == null || esiList.isEmpty() ? null : esiList
				.get(0);
		if (e == null)
		{
			throw new EsiNotFoundException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"Cannot retry provision b/c the account is not associated to a meter/gateway");
		}
		List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(e.getEsiId());
		final boolean vpp = esiDcList != null && !esiDcList.isEmpty();

		if (vpp)
		{
			assignDefaultProgramIfNull(e.getAccountId(), null, userCreated, now);
		}
		
		// KRMT-6666 & DEV-1052: Provisioning - Reuse of Accounts - CE Default group is not
		// associated to the account when account is reused.
		userAccountBeanFacade.defaultCeGroups(account);
		
		cacheManager.refreshGatewayAndEsiData(e);
		return e;
	}

	@Override
	public List<ConsertAccountDeprovisionReason> deprovisionReasonList()
	{
		TenantPropertyUtil.getTenantId(wsctx);
		
		List<ConsertAccountDeprovisionReason> reasonList = new ArrayList<ConsertAccountDeprovisionReason>();

		List<RemovalCode> removalCodeList = genericFacade.getRemovalCodes();
		for (RemovalCode removalCode : removalCodeList)
		{
			ConsertAccountDeprovisionReason reason = new ConsertAccountDeprovisionReason();
			reason.setReasonCode(removalCode.getRemovalCodeId());
			reason.setReasonValue(removalCode.getRemovalCodeName());
			log.info("removalCodeName : " + removalCode.getRemovalCodeName());
			reasonList.add(reason);
		}

		return reasonList;
	}
	
	@Override
	public List<ConsertAccountProvisioningResponse> deviceSwap(
			ConsertDeviceSwapRequest request)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return deviceSwap(request, tenantId);
	}

	@Override
	public List<ConsertAccountProvisioningResponse> deviceSwap(
			ConsertDeviceSwapRequest request, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		ConsertError consertCreateUpdateError = null;
		DatatypeFactory datatypeFactory = null;

		String accountNumber = request.getAccountNumber();
		ConsertCompoundAccountKey compoundAccountKey = request
				.getCompoundAccountKey();

		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}
		
		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}

		Exception exception = null;
		ProvState swapState = null;
		try
		{

			swapState = consertAccountProvisioning.deviceSwapPersist(request, userCreated);
			//After DB saves, attempt to move deprovisioned equipment back to inventory in CC
			consertAccountProvisioning.deprovSwapPersist(swapState);
		} catch (Exception e)
		{
			exception = e;

			final AbstractOpsCenterException abstractOpsCenterException;
			final String errorCode;
			if (e instanceof ConfigurationException_Exception)
			{
				errorCode = ((ConfigurationException_Exception) e)
						.getFaultInfo().getErrorCode();
				abstractOpsCenterException = null;
			} else if (e instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}

			log.error("Failed to Account_ReprovisionSimple", e);

			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError
					.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber,
					compoundAccountKey);
			
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
			response.setError(consertCreateUpdateError);
			
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
			return responseList;
		}

		boolean isGridStream = false;
		int workflowTypeId;
		int workflowOriginId;
		Esi esi = swapState != null ? swapState.getEsi() : null;
		if (esi != null && esi.getNetworkDeliveryId() == 2)
		{
			isGridStream = true;
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING;
		} else
		{
			workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING;
		}
		workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_DEVICE_SWAP;

		if (isGridStream && exception == null && esi != null && swapState != null)
		{
			final Set<EsiTstat> esiTstatSet = swapState.getProvEsiTstatSet();
			final Set<EsiLcs> esiLcsSet = swapState.getProvEsiLcsSet();

			for (EsiTstat esiTstat : esiTstatSet)
			{
				ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
				if (!Boolean.TRUE.equals(request.isDisableWorkflow()))
				{
				response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
				GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
				gatewayMessagingWorkflow
						.setGatewayMessagingWorkflowTypeId(esiBeanFacade
								.getRefGatewayMessagingWorkflowType(workflowTypeId));
				gatewayMessagingWorkflow
						.setGatewayMessagingWorkflowOriginId(esiBeanFacade
								.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
				gatewayMessagingWorkflow.setEsiId(esi);
				gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
				gatewayMessagingWorkflow.setUsrCreated(userCreated);
				try
				{
					populateWorkflowWithReply(gatewayMessagingWorkflow,
							request.getReply());
				} catch (SchemaDataInvalidException exp)
				{
					exception = exp;
					exp.printStackTrace();
				}
				gatewayMessagingWorkflowBean.startWorkflow(
						gatewayMessagingWorkflow, exception);
				response.setTrackingId(gatewayMessagingWorkflow
						.getGatewayMessagingWorkflowId());
				final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
						.getGatewayMessagingWorkflowOriginId();
				if (gatewayMessagingWorkflowOriginId != null)
				{
					response.setTrackingType(gatewayMessagingWorkflowOriginId
							.getName());
				}
				}
				else
				{
					response.setStatus(ConsertAccountProvisioningResponseStatus.SUCCESS);
				}
				response.setWallplateSerialNumber(esiTstat.getTstatWallPlate().getGsSbrSerialNo());
				response.setResponseTime(datatypeFactory
						.newXMLGregorianCalendar(new GregorianCalendar()));
				responseList.add(response);
			}
			for (EsiLcs esiLcs : esiLcsSet)
			{
				ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
				if (!Boolean.TRUE.equals(request.isDisableWorkflow()))
				{
				response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);

				GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
				gatewayMessagingWorkflow.setUsrCreated(userCreated);
				gatewayMessagingWorkflow
						.setGatewayMessagingWorkflowTypeId(esiBeanFacade
								.getRefGatewayMessagingWorkflowType(workflowTypeId));
				gatewayMessagingWorkflow
						.setGatewayMessagingWorkflowOriginId(esiBeanFacade
								.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
				gatewayMessagingWorkflow.setEsiId(esi);
				gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
				try
				{
					populateWorkflowWithReply(gatewayMessagingWorkflow,
							request.getReply());
				} catch (SchemaDataInvalidException exp)
				{
					exception = exp;
					exp.printStackTrace();
				}
				gatewayMessagingWorkflowBean.startWorkflow(
						gatewayMessagingWorkflow, exception);
				response.setTrackingId(gatewayMessagingWorkflow
						.getGatewayMessagingWorkflowId());
				final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
						.getGatewayMessagingWorkflowOriginId();
				if (gatewayMessagingWorkflowOriginId != null)
				{
					response.setTrackingType(gatewayMessagingWorkflowOriginId
							.getName());
				}
				}
				else
				{
					response.setStatus(ConsertAccountProvisioningResponseStatus.SUCCESS);
				}
				response.setLcsSerialNumber(esiLcs.getLcsId().getGsSbrSerialNo());
				response.setResponseTime(datatypeFactory
						.newXMLGregorianCalendar(new GregorianCalendar()));
				responseList.add(response);
			}
		} else
		{
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			response.setError(consertCreateUpdateError);
			if (!Boolean.TRUE.equals(request.isDisableWorkflow()))
			{	
			response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY
					: ConsertAccountProvisioningResponseStatus.ERROR);
			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowTypeId(esiBeanFacade
							.getRefGatewayMessagingWorkflowType(workflowTypeId));
			gatewayMessagingWorkflow
					.setGatewayMessagingWorkflowOriginId(esiBeanFacade
							.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
			gatewayMessagingWorkflow.setEsiId(esi);
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			try
			{
				populateWorkflowWithReply(gatewayMessagingWorkflow,
						request.getReply());
			} catch (SchemaDataInvalidException exp)
			{
				exception = exp;
				exp.printStackTrace();
			}
			gatewayMessagingWorkflowBean.startWorkflow(
					gatewayMessagingWorkflow, exception);
			response.setTrackingId(gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
					.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				response.setTrackingType(gatewayMessagingWorkflowOriginId
						.getName());
			}
			}
			else
			{
				response.setStatus(exception == null ? ConsertAccountProvisioningResponseStatus.SUCCESS
						: ConsertAccountProvisioningResponseStatus.ERROR);
			}
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}
		return responseList;
	}

	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public void deprovSwapPersist(ProvState provState)
	{		
		gsProvisionableRemove(provState.getSwappedTstatWallPlateSet());
		gsProvisionableRemove(provState.getSwappedLcsSet());
	}

	private void gsProvisionableRemove(
			Collection<? extends GsProvisionable> collection)
	{
		for (GsProvisionable twp : collection)
		{
			try {
				ccMultispeakBean.gsMeterRemove(twp);
			} catch (Exception e) {
				log.error("Unable to move back to inventory, deviceMacId: "+twp.getDeviceMacId(), e);
			}
		}
	}
	
	
	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public ProvState deviceSwapPersist(ConsertDeviceSwapRequest request, String userCreated)
			throws Exception
	{

		ProvStateImpl swapState = new ProvStateImpl();
		
		RemovalCode removalCode = null;
		if (request.getRemovalReasonCode() != null)
		{
			removalCode = genericFacade.getRefRemovalCodeById(request
					.getRemovalReasonCode());
		}
		
		String removalNetsuiteTicket = request.getRemovalNetsuiteTicket();
		
		CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
		final AccountPartsModel accountParts;
		try
		{
			accountParts = compoundAccountKeyUtility.getAccountParts();
		} catch (Exception e)
		{
			// Compound Account Key Error
			throw new CompoundAccountKeyException("Unexpected Error", e);
		}

		final DateTime now = new DateTime();

		// Always returns an account, otherwise it throws an exception
		final Account account = getAccount(request.getAccountNumber(), request.getCompoundAccountKey(),
				accountParts);
		List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account
				.getAccountId());
		final Esi e = esiList == null || esiList.isEmpty() ? null : esiList
				.get(0);
		if (e == null)
		{
			throw new EsiNotFoundException(
					DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND,
					"Cannot retry provision b/c the account is not associated to a meter/gateway");
		}
		
		List<ConsertDeviceSwap> lcsList = request.getLcs();
		if (lcsList != null && !lcsList.isEmpty()) {
			Map<String, EsiLcs> esiDcBySerialNo = new HashMap<String, EsiLcs>();
			final List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(e.getEsiId());
			for (EsiLcs esiLcs : esiLcsList)
			{				
				String serialNo = esiLcs.getLcsId().getGsSbrSerialNo();
				if (serialNo != null) esiDcBySerialNo.put(serialNo.toUpperCase(), esiLcs);
			}
			
			for (ConsertDeviceSwap consertDeviceSwap : lcsList)
			{
				swapLcs(swapState, consertDeviceSwap, e, esiDcBySerialNo, removalCode,
						removalNetsuiteTicket, now);
			}

		}
		
		
		List<ConsertDeviceSwap> thermostatList = request.getThermostat();
		if (thermostatList != null && !thermostatList.isEmpty()) {
			Map<String, EsiTstat> esiTstatBySerialNo = new HashMap<String, EsiTstat>();
			final List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(e.getEsiId());
			for (EsiTstat esiTstat : esiTstatList)
			{				
				String serialNo = esiTstat.getTstatId().getSerialNo();
				if (serialNo != null) esiTstatBySerialNo.put(serialNo.toUpperCase(), esiTstat);
			}
			
			for (ConsertDeviceSwap consertDeviceSwap : thermostatList)
			{
				swapState.addEsiTstat(swapTstat(consertDeviceSwap, e, esiTstatBySerialNo,
						removalCode, removalNetsuiteTicket, now));
			}

		}
		
		List<ConsertDeviceSwap> wallplateList = request.getWallplate();
		if (wallplateList != null && !wallplateList.isEmpty()) {
			Map<String, EsiTstatWallPlate> esiTstatWallPlateBySerialNo = new HashMap<String, EsiTstatWallPlate>();
			final List<EsiTstatWallPlate> esiTstatWallPlateList = esiBeanFacade.getEsiTstatWallPlateByEsiId(e.getEsiId());
			for (EsiTstatWallPlate esiTstatWallPlate : esiTstatWallPlateList)
			{				
				String serialNo = esiTstatWallPlate.getTstatWallPlateId().getGsSbrSerialNo();
				if (serialNo != null) esiTstatWallPlateBySerialNo.put(serialNo.toUpperCase(), esiTstatWallPlate);
			}
			
			for (ConsertDeviceSwap consertDeviceSwap : wallplateList)
			{
				swapWallplate(swapState, consertDeviceSwap, e,
						esiTstatWallPlateBySerialNo, removalCode,
						removalNetsuiteTicket, now);
			}

		}
				
		List<ConsertDeviceSwap> binaryList = request.getBinary();
		List<ConsertDeviceSwap> hvacList = request.getHvac();
		if ((binaryList != null && !binaryList.isEmpty())
				|| (hvacList != null && !hvacList.isEmpty())) {
			Map<String, EsiDc> esiDcBySerialNo = new HashMap<String, EsiDc>();
			final List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(e.getEsiId());
			for (EsiDc esiDc : esiDcList)
			{				
				String serialNo = esiDc.getDcId().getSerialNo();
				if (serialNo != null) esiDcBySerialNo.put(serialNo.toUpperCase(), esiDc);
			}

			if (binaryList != null)
			{
				for (ConsertDeviceSwap consertDeviceSwap : binaryList)
				{
					swapDc(consertDeviceSwap, e, esiDcBySerialNo, removalCode,
							removalNetsuiteTicket, now);
	
				}
			}
			
			if (hvacList != null)
			{
				for (ConsertDeviceSwap consertDeviceSwap : hvacList)
				{
					swapDc(consertDeviceSwap, e, esiDcBySerialNo, removalCode,
							removalNetsuiteTicket, now);
	
				}
			}
		}	
		
		cacheManager.refreshGatewayAndEsiData(e);
		swapState.setEsi(e);
		return swapState;
	}

	/**
	 * @param consertDeviceSwap
	 * @param e
	 * @param esiTstatWallPlateBySerialNo
	 * @param removalCode
	 * @param removalNetsuiteTicket
	 * @param now
	 * @throws Exception 
	 */
	private EsiTstat swapWallplate(ProvStateImpl swapState, ConsertDeviceSwap consertDeviceSwap,
			final Esi e,
			Map<String, EsiTstatWallPlate> esiTstatWallPlateBySerialNo,
			RemovalCode removalCode, String removalNetsuiteTicket,
			final DateTime now) throws Exception
	{
		final String consertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getConsertSerialNumber());
		TstatWallPlate tstatWallPlate = deviceBeanFacade.getTstatWallPlateBySerialNo(consertSerialNumber);
		if (tstatWallPlate == null)
		{
			throw new SchemaDataInvalidException(
					"Serial Number "
							+ consertSerialNumber
							+ "is not recognized");
		}
		
		final Esi tstatWallPlateEsi = tstatWallPlate.getEsiId();
		if (tstatWallPlateEsi != null)
		{
			throw new SchemaDataInvalidException(
					"Serial Number "
							+ consertSerialNumber
							+ " is already associated to accountNumber "
							+ tstatWallPlateEsi.getAccountId().getAccountNumber());
		}
		
		String oldConsertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getOldConsertSerialNumber());
		
		if (oldConsertSerialNumber != null) oldConsertSerialNumber = oldConsertSerialNumber.toUpperCase();
		
		EsiTstatWallPlate esiTstatWallPlate = esiTstatWallPlateBySerialNo.get(oldConsertSerialNumber);
		if (esiTstatWallPlate == null)
		{
			throw new SchemaDataInvalidException(
					"Old Serial Number "
							+ oldConsertSerialNumber
							+ "is not recognized");
		}
		
		demandManagerBeanLocal.swapDevice(esiTstatWallPlate.getDeviceMacId(), tstatWallPlate.getDeviceMacId(), OpsCenterConstants.DEMAND_MANAGER_RELAY_1_ID);
		
		TstatWallPlate origTstatWallPlate = esiTstatWallPlate.getTstatWallPlateId();
						
		origTstatWallPlate.setRemovalCodeId(removalCode);
		origTstatWallPlate.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		origTstatWallPlate.setEsiId(null);
		origTstatWallPlate.setDateModified(now);

		esiTstatWallPlate.setTstatWallPlateId(tstatWallPlate);
				    
		tstatWallPlate.setEsiId(e);
		tstatWallPlate.setDateModified(now);

		esiTstatWallPlate.setDateUpdated(now);
				
		
		//Special Cases
		// Note that there should only be one tstat per wallplate
		EsiTstat esiTstat = esiBeanFacade.getEsiTstatByDeviceMacId(origTstatWallPlate.getDeviceMacId());
		if (esiTstat != null)
		{
			swapState.addSwappedTstatWallPlate(origTstatWallPlate);
			esiTstat.setTstatWallPlate(tstatWallPlate);
			esiTstat.setDateUpdated(now);
			// reset esiTstat.manage_mode, so that the tstat_wall_plate can get provisioned
			esiTstat.setPrevManageModeId(esiTstat.getManageModeId());
			esiTstat.setManageModeId(null);
			swapState.addEsiTstat(esiTstat);
			return esiTstat;
		}
		
		return null;
	}

	/**
	 * @param consertDeviceSwap
	 * @param e
	 * @param esiTstatBySerialNo
	 * @param removalCode
	 * @param removalNetsuiteTicket
	 * @param now
	 * @throws SchemaDataInvalidException
	 * @throws DemandManagerException 
	 */
	private EsiTstat swapTstat(ConsertDeviceSwap consertDeviceSwap, final Esi e,
			Map<String, EsiTstat> esiTstatBySerialNo, RemovalCode removalCode,
			String removalNetsuiteTicket, final DateTime now)
			throws SchemaDataInvalidException, DemandManagerException
	{
		final String consertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getConsertSerialNumber());
		Tstat tstat = deviceBeanFacade.getTstatBySerialNo(consertSerialNumber);
		if (tstat == null)
		{
			throw new SchemaDataInvalidException(
					"Serial Number "
							+ consertSerialNumber
							+ " is not recognized");
		}
		
		final Esi tstatEsi = tstat.getEsiId();
		if (tstatEsi != null)
		{
			throw new SchemaDataInvalidException(
					"Serial Number "
							+ consertSerialNumber
							+ "is already associated to accountNumber"
							+ tstatEsi.getAccountId().getAccountNumber());
		}
		
		String oldConsertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getOldConsertSerialNumber());
		
		if (oldConsertSerialNumber != null) oldConsertSerialNumber = oldConsertSerialNumber.toUpperCase();
		
		EsiTstat esiTstat = esiTstatBySerialNo.get(oldConsertSerialNumber);
		if (esiTstat == null)
		{
			throw new SchemaDataInvalidException(
					"Old Serial Number "
							+ oldConsertSerialNumber
							+ " is not recognized");
		}
		
		Tstat origTstat = esiTstat.getTstatId();
						
		// TODO verify relays using tstat make model?
						
		origTstat.setRemovalCodeId(removalCode);
		origTstat.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		origTstat.setEsiId(null);
		origTstat.setDateModified(now);

		esiTstat.setTstatId(tstat);
				    
		tstat.setEsiId(e);
		tstat.setDateModified(now);
		tstat.setDeviceMqId(esiTstat.getDeviceMqId());


		esiTstat.setDateUpdated(now);
		
		//Special Cases
		tstat.setHvac(origTstat.getHvac());
		origTstat.setHvac(origTstat.getHvac());

		// SRR 2014-01-29: DEV-563: The GsProvisionig Scheduled task looks for this nil to do meterExchange
		esiTstat.setPrevManageModeId(esiTstat.getManageModeId());
		esiTstat.setManageModeId(null);
		
		return esiTstat;
	}

	/**
	 * @param consertDeviceSwap
	 * @param e
	 * @param esiLcsBySerialNo
	 * @param removalCode
	 * @param removalNetsuiteTicket
	 * @param now
	 * @throws Exception 
	 */
	private EsiLcs swapLcs(ProvStateImpl swapState, ConsertDeviceSwap consertDeviceSwap, final Esi e,
			Map<String, EsiLcs> esiLcsBySerialNo, RemovalCode removalCode,
			String removalNetsuiteTicket, final DateTime now)
			throws Exception
	{
		final String consertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getConsertSerialNumber());
		Lcs lcs = deviceBeanFacade.getLcsByGsSbrSerialNo(consertSerialNumber);
		if (lcs == null)
		{
			throw new SchemaDataInvalidException(
					"Serial Number "
							+ consertSerialNumber
							+ " is not recognized");
		}
		
		final Esi lcsEsi = lcs.getEsiId();
		if (lcsEsi != null)
		{
			throw new SchemaDataInvalidException(
					"Serial Number "
							+ consertSerialNumber
							+ " is already associated to accountNumber "
							+ lcsEsi.getAccountId().getAccountNumber());
		}
		
		String oldConsertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getOldConsertSerialNumber());
		
		if (oldConsertSerialNumber != null) oldConsertSerialNumber = oldConsertSerialNumber.toUpperCase();
		
		EsiLcs esiLcs = esiLcsBySerialNo.get(oldConsertSerialNumber);
		if (esiLcs == null)
		{
			throw new SchemaDataInvalidException(
					"Old Serial Number "
							+ oldConsertSerialNumber
							+ " is not recognized");
		}

		demandManagerBeanLocal.swapDevice(esiLcs.getDeviceMacId(), lcs.getDeviceMacId(), OpsCenterConstants.DEMAND_MANAGER_RELAY_1_ID);
		
		
		Lcs origLcs = esiLcs.getLcsId();
						
		// TODO verify relay amps for lcs using dc make model?
						
		origLcs.setRemovalCodeId(removalCode);
		origLcs.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		origLcs.setEsiId(null);
		origLcs.setDateModified(now);

		esiLcs.setLcsId(lcs);
				    
		lcs.setEsiId(e);
		lcs.setDateModified(now);

		esiLcs.setDateUpdated(now);
		
		//Special Cases
		esiLcs.setProvState(lcs.getProvState());
		esiLcs.setPrevManageModeId(esiLcs.getManageModeId());
		esiLcs.setManageModeId(null);
		
		//TODO: ESI_DC should point to ESI_LCS, but since it does not, syncing device_mac_id
		List<EsiDc> relays = esiBeanFacade.getEsiDcByDevMacId(origLcs.getDeviceMacId());
		for (EsiDc relay : relays)
		{
			relay.setDateUpdated(now);
			relay.setDeviceMacId(lcs.getDeviceMacId());
		}
		
		swapState.addEsiLcs(esiLcs);
		swapState.addSwappedLcs(origLcs);
		return esiLcs;
	}

	/**
	 * @param consertDeviceSwap
	 * @param e
	 * @param esiDcBySerialNo
	 * @param removalCode
	 * @param removalNetsuiteTicket
	 * @param now
	 * @throws SchemaDataInvalidException
	 * @throws SepVersionMismatchException
	 */
	private void swapDc(ConsertDeviceSwap consertDeviceSwap, final Esi e,
			Map<String, EsiDc> esiDcBySerialNo, RemovalCode removalCode,
			String removalNetsuiteTicket, final DateTime now)
			throws SchemaDataInvalidException, SepVersionMismatchException
	{
		final String consertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getConsertSerialNumber());
		Dc dc = deviceBeanFacade.getDcBySerialNo(consertSerialNumber);
		if (dc == null)
		{
			throw new SchemaDataInvalidException(
					"Data validation error: consertSerialNumber is not recognized, "
							+ consertSerialNumber);
		}
		
		final Esi dcEsi = dc.getEsiId();
		if (dcEsi != null)
		{
			throw new SchemaDataInvalidException(
					"Data validation error: consertSerialNumber is already associated to accountNumber = "
							+ dcEsi.getAccountId().getAccountNumber()
							+ ", consertSerialNumber = "
							+ consertSerialNumber);
		}
		
		String oldConsertSerialNumber = WebServiceUtil
				.killWhitespace(consertDeviceSwap.getOldConsertSerialNumber());
		
		if ( oldConsertSerialNumber != null ) oldConsertSerialNumber = oldConsertSerialNumber.toUpperCase();
		EsiDc esiDc = esiDcBySerialNo.get(oldConsertSerialNumber);
		if (esiDc == null)
		{
			throw new SchemaDataInvalidException(
					"Data validation error: oldConsertSerialNumber is not recognized, "
							+ oldConsertSerialNumber);
		}
		
		Dc origDc = esiDc.getDcId();
						
		// Verify relay and SEP
		if (OpsCenterConstants.TRUE.equals(origDc.getDcMakeModelId().getDcRelayFlag()) !=
				OpsCenterConstants.TRUE.equals(dc.getDcMakeModelId().getDcRelayFlag())
		)
		{
			throw new SchemaDataInvalidException(
					"Data validation error:  The device controller should have a relay="
							+(OpsCenterConstants.TRUE.equals(origDc.getDcMakeModelId().getDcRelayFlag()))
							+" for consertSerialNumber = "
							+ consertSerialNumber);
		}				
		
		String sepVersion = origDc.getSepVersion();
		String newSepVersion = dc.getSepVersion();
		// this handles null != 1.1, 1.1 != null, && 1.1 != 1.2
		if (sepVersion != newSepVersion
				&& (sepVersion == null || !sepVersion
						.equalsIgnoreCase(newSepVersion)))
		{
			throw new SepVersionMismatchException(
					"Expected the binatry to have a SEP version = "
							+ sepVersion + " for consertSerialNumber = "
							+ consertSerialNumber);
		}
						
		origDc.setRemovalCodeId(removalCode);
		origDc.setRemovalNetsuiteTicket(removalNetsuiteTicket);
		origDc.setEsiId(null);
		origDc.setDateModified(now);

		esiDc.setDcId(dc);
				    
		dc.setEsiId(e);
		dc.setDeviceMqId(esiDc.getDeviceMqId());
		dc.setDeviceTypeId(esiDc.getDeviceTypeId());
		dc.setDateModified(now);
		// Provui sets the virtual flag, however WSI only swaps hardware with a serial number
		// KRMT-3514
		esiDc.setVirtualFlag(dc.getVirtualFlag());
		// KRMT-3728
		esiDc.setDateUpdated(now);
	}

	/**
	 * VppAccount_Migration enables a Utility partner to provision a Consert VPP (Virtual Power Plant) system using a Standalone Gateway (SAG) /with the devices from an existing
	 * Electric Meter/Under-the-glass Gateway (UG) account.  The primary usecase would be that a Utility has decided to no longer use the Consert AMI solution but still would
	 * like to use the Consert DR solution.
	 * 
	 * This migration requires the "old" account's compound key & electric meter and the "new" account's compound key and standalone gateway
	 * 
	 */
	@Override
	public List<ConsertAccountProvisioningResponse> vppAccountMigration(ConsertAccountVppMigration request) {
		
		TenantPropertyUtil.getTenantId(wsctx);
		
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		DatatypeFactory datatypeFactory = null;
		try {
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e) {
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}	
		
		if (request == null) return null;

		final ConsertCompoundAccountKey oldAccount = request.getOldCompoundAccountKey();
		final String electricMeterNumber = WebServiceUtil.killWhitespace(request.getElectricMeterNumber());
		final ConsertCompoundAccountKey newAccount = request.getCompoundAccountKey();
		final String standaloneGatewaySerialNumber = WebServiceUtil.killWhitespace(request.getStandaloneGatewaySerialNumber());

		String userCreated = request.getUserName();
		if((userCreated==null))
		{
			userCreated=getUserName();
		}
		
		Exception exception = null;
		Esi oldEsi = null;
		Esi newEsi = null;
	
		try {
			Esi[] esiArray = consertAccountProvisioning.vppAccountMigrationPersist(oldAccount, electricMeterNumber, newAccount, standaloneGatewaySerialNumber);
			oldEsi = esiArray[0];
			newEsi = esiArray[1];
		} catch (Exception e1) {
			
			exception = e1;
			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException) {
				abstractOpsCenterException = (AbstractOpsCenterException)e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else {
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to VppAccount_Provision", e1);
			
			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());
			
			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, oldAccount.getBillingAccountNumber(), oldAccount);
			addToErrorObjectDetails(errorObjectDetails, "oldAccountNumber", "oldCompoundAccountKey", oldAccount.getBillingAccountNumber(), oldAccount);
			
			if (abstractOpsCenterException != null) {
				abstractOpsCenterException.setContext(getContext(errorObjectDetails));
			}
		}
		
		/* Step 14: Kick off 2 "PROVISIONING" workflows, one for the oldEsi and one for the newEsi */
		
		if(exception !=null){
			ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
			GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
			gatewayMessagingWorkflow.setGatewayMessagingWorkflowTypeId(esiBeanFacade.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
			gatewayMessagingWorkflow.setGatewayMessagingWorkflowOriginId(esiBeanFacade.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_MIGRATION));
			gatewayMessagingWorkflow.setEsiId(oldEsi);
			gatewayMessagingWorkflow.setUsrCreated(userCreated);
			response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
			try{
				populateWorkflowWithReply(gatewayMessagingWorkflow, request.getReply());
			}catch(SchemaDataInvalidException exp){
				exception = exp;
				exp.printStackTrace();
			}
			gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow, exception);
			response.setTrackingId(gatewayMessagingWorkflow.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null) response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
			response.setResponseTime(datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar()));
			responseList.add(response);
		}else if(newEsi!=null  && oldEsi!=null){
				ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
				GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
				gatewayMessagingWorkflow.setGatewayMessagingWorkflowTypeId(esiBeanFacade.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
				gatewayMessagingWorkflow.setGatewayMessagingWorkflowOriginId(esiBeanFacade.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_MIGRATION));
				gatewayMessagingWorkflow.setEsiId(newEsi);
				gatewayMessagingWorkflow.setUsrCreated(userCreated);
				response.setStatus( ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY );
				try{
					populateWorkflowWithReply(gatewayMessagingWorkflow, request.getReply());
				}catch(SchemaDataInvalidException exp){
					exception = exp;
					exp.printStackTrace();
				}
				gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow, exception);
				response.setTrackingId(gatewayMessagingWorkflow.getGatewayMessagingWorkflowId());
				final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow.getGatewayMessagingWorkflowOriginId();
				if (gatewayMessagingWorkflowOriginId != null) response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
				response.setResponseTime(datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar()));
				responseList.add(response);
			
			
				ConsertAccountProvisioningResponse responseOldEsi = new ConsertAccountProvisioningResponse();
				GatewayMessagingWorkflow gatewayMessagingWorkflowOldEsi = new GatewayMessagingWorkflow();
				gatewayMessagingWorkflowOldEsi.setGatewayMessagingWorkflowTypeId(esiBeanFacade.getRefGatewayMessagingWorkflowType(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_PROVISIONING));
				gatewayMessagingWorkflowOldEsi.setGatewayMessagingWorkflowOriginId(esiBeanFacade.getRefGatewayMessagingWorkflowOrigin(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_MIGRATION));
				gatewayMessagingWorkflowOldEsi.setEsiId(oldEsi);
				gatewayMessagingWorkflowOldEsi.setUsrCreated(userCreated);
				responseOldEsi.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY );
				try{
					populateWorkflowWithReply(gatewayMessagingWorkflowOldEsi, request.getReply());
				}catch(SchemaDataInvalidException exp){
					exception = exp;
					exp.printStackTrace();
				}
				gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflowOldEsi, exception);
				responseOldEsi.setTrackingId(gatewayMessagingWorkflowOldEsi.getGatewayMessagingWorkflowId());
				final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginIdOldEsi = gatewayMessagingWorkflowOldEsi.getGatewayMessagingWorkflowOriginId();
				if (gatewayMessagingWorkflowOriginIdOldEsi != null && gatewayMessagingWorkflowOriginId != null)
				{
					responseOldEsi.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
				}
				responseOldEsi.setResponseTime(datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar()));
				responseList.add(responseOldEsi);
			}
		
		return responseList;
	}

	
	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioningLocal#vppAccountMigrationPersist(ConsertCompoundAccountKey, String, ConsertCompoundAccountKey, String)
	 */
	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public Esi[] vppAccountMigrationPersist(final ConsertCompoundAccountKey oldCompoundAccountKey, final String electricMeterNumber, 
										final ConsertCompoundAccountKey newCompoundAccountKey, final String standaloneGatewaySerialNumber) throws Exception {
		
		Esi[] esiArray = new Esi[2];
		
		/* Association After Migration 
		 * newGateway (SAG) => oldEsiGateway => oldEsi => newAccount
		 * oldGateway (UG) => newEsiGateway => oldEsiElectricMeter => newEsi => oldAccount
		 */

		/* Step 1: Validate that the oldCompoundAccountKey is associated to the electricMeter */ 
		// 1.a -> Validate Input
		if(oldCompoundAccountKey == null){
			throw new SchemaDataInvalidException("Old Compound Account Key is required and cannot be empty");
		}
		
		if(newCompoundAccountKey == null){
			throw new SchemaDataInvalidException("New Compound Account Key is required and cannot be empty");
		}
		
		if(electricMeterNumber== null){
			throw new SchemaDataInvalidException("Electric Meter Number is required and cannot be empty");
		}
		
		if(standaloneGatewaySerialNumber== null){
			throw new SchemaDataInvalidException("Standalone Gateway Serial Number is required and cannot be empty");
		}
		
		
		// 1.a -> Get Account using oldCompundAccontKey
		CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();			
		AccountPartsModel accountParts;
		try {
			accountParts = compoundAccountKeyUtility.getAccountParts();
		} catch (Exception e) {
			throw new CompoundAccountKeyException("Unexpected Error", e);
		}

		final Account oldAccount = getAccount(null, oldCompoundAccountKey, accountParts);
		
		if(oldAccount==null){
			throw new AccountNotFoundException("Old Account not found for " + accountParts.isCompoundKeyEnabled());
		}
		
		 
		
		
		

		// 1.c -> Get ElectircMeter for Old Account 
		final List<Esi> oldEsiList = esiBeanFacade.getEsiByAccountId(oldAccount.getAccountId());
		final Esi oldEsi = (oldEsiList !=null && !oldEsiList.isEmpty()) ? oldEsiList.get(0) : null;
		
		if(oldEsi == null){
				throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND, "Old Account not provisioned " + oldAccount.getAccountId());
		}
		
		// Validate that old account has devices
		final List<EsiDc> esiDcList = esiBeanFacade.getEsiDcByEsiId(oldEsi.getEsiId());
		if(esiDcList == null || esiDcList.isEmpty()){
			throw new SchemaDataInvalidException("No Active devices assigned to Old Account " + oldAccount.getAccountId());
		}
		
		
		 
		// Validate if ExternalAccountXref already exist
		Account validateAccount = null;
		try{
			validateAccount = getAccount(null, newCompoundAccountKey, accountParts);
		}catch (CompoundAccountKeyNotUniqueException e){
			throw new CompoundAccountKeyNotUniqueException("More than one account matched the provided compound key(s)");
		}catch (AccountNotFoundException e){
			// Nothing to do
		}catch (AbstractOpsCenterException e){
			throw e;
		}
		
		if(validateAccount!=null){
			throw new SchemaDataInvalidException("ExternalAccountXref Already Exist " + newCompoundAccountKey.getBillingAccountNumber() + " "+ newCompoundAccountKey.getPremiseNumber());
		}
		
		// Validate that the SAG exists
		final Gateway newGateway  = deviceBeanFacade.getGatewayBySerialNo(standaloneGatewaySerialNumber);
		if (newGateway == null || WebServiceUtil.killWhitespace(newGateway.getMeterSerialNo()) != null) {
			throw new GatewayNotFoundException(DefaultResources.ACC_ERR_CODE_GATEWAY_NOT_FOUND, "Unable to find a gateway for standaloneGatewaySerialNumber", standaloneGatewaySerialNumber);
		}

		// Validate that the SAG is not already associated to an account
		List<EsiGateway> existingEsiGatewayList = esiBeanFacade.getEsiGatewayByGatewayId(newGateway.getGatewayId()); 
		if (existingEsiGatewayList != null && !existingEsiGatewayList.isEmpty()){ 
	        throw new EsiGatewayAlreadyExistsException(DefaultResources.ACC_ERR_CODE_ESI_GATEWAY_ALREADY_EXISTS, "The gateway is already assocatied to account, gateway # "  + standaloneGatewaySerialNumber); 
		}
				
		EsiGateway oldEsiGateway = oldEsi.getEsiGatewayId();
		Gateway oldGateway = oldEsiGateway.getGatewayId();
		
		String oldSepVersion = oldGateway.getSepVersion();
		String newSepVersion = newGateway.getSepVersion();

		// Validate SEP matches, may need to loose this validation due to REV A gateways needing to me migrated
		// oldSepVersion != newSepVersion will most likely only be false if both values are null
		// this handles null != 1.1, 1.1 != null, && 1.1 != 1.2
		if (oldSepVersion != newSepVersion
				&& (oldSepVersion == null || !oldSepVersion.equalsIgnoreCase(newSepVersion)))
		{
			throw new SepVersionMismatchException(
					"Expected the standaloneGateway to have a SEP version = "
							+ oldSepVersion + " for standaloneGateway = "
							+ standaloneGatewaySerialNumber);
		}
		
		/*  Step 2: Create a newAccount with all the values from oldAccount  */
		List<String> targetedAccountFields = getTargetedPropertyNames(Account.class);
		Account newAccount = createAccount(oldAccount, targetedAccountFields);
		
		
		/* Step 3: Create newExternalAccountXref associated to newAccount w/ newCompoundAccountKey  */ 
		ExternalAccountXRef accountXRef = createExternalAccountXref(newCompoundAccountKey, newAccount);		
		String accountNumber = CompoundAccountKey.deriveAccountNumber(
				accountParts.getAccountPartDefinitions(), accountXRef);
		newAccount.setAccountNumber(accountNumber);
		
		/* Step 4: Set the newAccountId on the oldPrograms  */
		List<Program> programList = programBeanFacade.getProgramByAccountId(oldAccount.getAccountId());
		for(Program program : programList){
			program.setAccountId(newAccount);
		}		
		

		/* Steps 5-7: Not doing as a "swap" to avoid ProvisioningFacade.useSwapZigBeeFormat */
		
		DateTime currTime = new DateTime();
		
		/* Step 5: Clone oldEsi as newEsi, so newEsi pointed @ oldAccountId and oldEsiGateway */
		List<String> targetedEsiFields = getTargetedPropertyNames(Esi.class);
		Esi newEsi = createEsi(oldEsi, targetedEsiFields);
		
		/*  Step 6: Create a newEsiGateway for the newGateway  */
		final EsiGateway newEsiGateway = newEsiGateway(newGateway, currTime);
		
		esiBeanFacade.createEsiGateway(newEsiGateway);
		
		/* Step 7: Point oldEsi at newEsiGateway */
        oldEsi.setEsiGatewayId(newEsiGateway);
		
		/* Step 8: Set the newAccountId on the oldEsi */
		oldEsi.setAccountId(newAccount);
		
		/* Step 9: Copy the oldCeGroupAccountMaps but associate to the newAccount */
		List<String> targetedCeGroupAccountMapFields = getTargetedPropertyNames(CeGroupAccountMap.class);
	    List<CeGroupAccountMap> ceGroupAccountMapList = userAccountBeanFacade.getCeGroupAccountMapByAccountId(oldAccount.getAccountId());
	    for(CeGroupAccountMap ceGroupAccountMap : ceGroupAccountMapList){
	    	createCeGroupAccountMap(ceGroupAccountMap, newAccount, targetedCeGroupAccountMapFields);
	    }
		
	   
		
		/* Step 12: Update UserAccountMap to contain newAccountId */
		List<UserAccountMap> userAccountMapList = userAccountBeanFacade.getUserAccountMapByAccountId(oldAccount.getAccountId());
		for(UserAccountMap userAccountMap : userAccountMapList){
			userAccountMap.setAccountId(newAccount);
		}
		
		/* Step 13: Refresh the cache for both ESIs */
		//cacheManager.updateEsiInCache(oldEsi, newEsi);
		cacheManager.refreshGatewayAndEsiData(oldEsi);
		cacheManager.refreshGatewayAndEsiData(newEsi);
		
		esiArray[0] = oldEsi;
		esiArray[1] = newEsi;
		return esiArray;
	}

	/**
	 * @param gateway
	 * @param currTime
	 * @return
	 */
	private EsiGateway newEsiGateway(final Gateway gateway,
			DateTime currTime)
	{
		final EsiGateway newEsiGateway = new EsiGateway();		
		newEsiGateway.setConfigAckFlag(OpsCenterConstants.FALSE);
		newEsiGateway.setDateCreated(currTime);
		newEsiGateway.setDeleteFlag(OpsCenterConstants.FALSE);
		newEsiGateway.setGatewayId(gateway);
		newEsiGateway.setGatewayMqId(gateway.getGatewayMqId());
		newEsiGateway.setOutageFlag(OpsCenterConstants.FALSE);
		newEsiGateway.setDoNotManageFlag(OpsCenterConstants.FALSE);
		newEsiGateway.setVirtual(gateway.getVirtual());
		return newEsiGateway;
	}
	
	
	
	/**
	 * @param inAccount
	 * @param targetedAccountFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private Account createAccount(Account inAccount, List<String> targetedAccountFields) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
		final Account newAccount =  new Account();
		for (String field : targetedAccountFields) {
			Object o = null;
			boolean valid = true;
			try {
				o = PropertyUtils.getSimpleProperty(inAccount, field);
			} catch (Exception e) {
				// Don't care if the source does not have field
				valid = false;
			}
			if (valid) PropertyUtils.setSimpleProperty(newAccount, field, o);
		}
		
//		newAccount.setDateCreated(now);
//		newAccount.setDateModified(now);
//		newAccount.setUserCreated("System");
//		newAccount.setUserModified("System");
		userAccountBeanFacade.createAccount(newAccount);
		
		return newAccount;
	}
	
	/**
	 * @param inEsi
	 * @param targetedAccountFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private Esi createEsi(Esi inEsi, List<String> targetedAccountFields) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
		final Esi newEsi =  new Esi();
		for (String field : targetedAccountFields) {
			Object o = null;
			boolean valid = true;
			try {
				o = PropertyUtils.getSimpleProperty(inEsi, field);
			} catch (Exception e) {
				// Don't care if the source does not have field
				valid = false;
			}
			if (valid) PropertyUtils.setSimpleProperty(newEsi, field, o);
		}

		esiBeanFacade.createEsi(newEsi);
		return newEsi;
	}
	
	/**
	 * @param inEsi
	 * @param targetedAccountFields
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
	 * @throws NoSuchMethodException
	 */
	private CeGroupAccountMap createCeGroupAccountMap(CeGroupAccountMap inCeGroupAccountMap, Account newAccount, List<String> targetedFields) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
		final CeGroupAccountMap ceGroupAccountMap =  new CeGroupAccountMap();
		for (String field : targetedFields) {
			Object o = null;
			boolean valid = true;
			try {
				o = PropertyUtils.getSimpleProperty(inCeGroupAccountMap, field);
			} catch (Exception e) {
				// Don't care if the source does not have field
				valid = false;
			}
			if (valid) PropertyUtils.setSimpleProperty(ceGroupAccountMap, field, o);
		}
		ceGroupAccountMap.setAccountId(newAccount);

		userAccountBeanFacade.createCeGroupAccountMap(ceGroupAccountMap);
		return ceGroupAccountMap;
	}
	
	
	private ExternalAccountXRef createExternalAccountXref(ConsertCompoundAccountKey newCompoundAccountKey, Account newAccount){

		final ExternalAccountXRef externalAccountXref = new ExternalAccountXRef();
		externalAccountXref.setAccount(newAccount);
		externalAccountXref.setPremiseNumber(newCompoundAccountKey.getPremiseNumber());
		externalAccountXref.setMeterLocationNumber(newCompoundAccountKey.getMeterLocationNumber());
		externalAccountXref.setUtilityNumber(newCompoundAccountKey.getUtilityNumber());
		externalAccountXref.setBillingAccountNumber(newCompoundAccountKey.getBillingAccountNumber());
		
		userAccountBeanFacade.createAccountXRef(externalAccountXref);
		
		return externalAccountXref;
	}

	@Override
	public ConsertDeviceSearchResults deviceSearch(ConsertDeviceSearchCriteria request)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return deviceSearch(request, tenantId);
	}
	
	/**
	 * @see com.consert.service.ns.consertaccountprovisioning.ConsertAccountProvisioning#deviceSearch(com.consert.service.ns.xml.ConsertDeviceSearchCriteria)
	 */
	@Override
	public ConsertDeviceSearchResults deviceSearch(ConsertDeviceSearchCriteria request, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		if (request == null) return null;
		ConsertDeviceSearchResults results = new ConsertDeviceSearchResults();
		//need to add the account query hint
		String dcSerialNumber = WebServiceUtil.killWhitespace(request.getDcSerialNumber());
		if (dcSerialNumber != null) {
			List<Dc> deviceList = deviceBeanFacade.getDcLikeSerialNo(dcSerialNumber);
			for (Dc dc : deviceList)
			{
				results.getDc().add(WebServiceUtil.createView(dc));
			}
		}
		String gatewaySerialNumber = WebServiceUtil.killWhitespace(request.getGatewaySerialNumber());
		if (gatewaySerialNumber != null) {
			List<Gateway> deviceList = deviceBeanFacade.getGatewayLikeSerialNo(gatewaySerialNumber);
			for (Gateway g : deviceList)
			{
				results.getGateway().add(WebServiceUtil.createView(g));
			}
		}
		String lcsSerialNumber = WebServiceUtil.killWhitespace(request.getLcsSerialNumber());
		if (lcsSerialNumber != null) {
			List<Lcs> deviceList = deviceBeanFacade.getLcsLikeGsSbrSerialNo(lcsSerialNumber);
			for (Lcs l : deviceList)
			{
				results.getLcs().add(WebServiceUtil.createView(l));
			}
		}
 		 
		String tstatSerialNumber = WebServiceUtil.killWhitespace(request.getTstatSerialNumber());
		if (tstatSerialNumber != null) {
			List<Tstat> deviceList = deviceBeanFacade.getTstatLikeSerialNo(tstatSerialNumber);
			for (Tstat t : deviceList)
			{
				results.getThermostat().add(WebServiceUtil.createView(t));
			}
		}
		String wallplateSerialNumber = WebServiceUtil.killWhitespace(request.getWallplateSerialNumber());
		if (wallplateSerialNumber != null) {
			List<TstatWallPlate> deviceList = deviceBeanFacade.getTstatWallPlateLikeSerialNo(wallplateSerialNumber);
			for (TstatWallPlate twp : deviceList)
			{
				results.getWallplate().add(WebServiceUtil.createView(twp));
			}
		}
 		
		return results;
	}

	@Override
	public List<ConsertElectricHvacTypeView> electricHvacTypeFind()
	{	
		TenantPropertyUtil.getTenantId(wsctx);
		
		OpsCenterConstants.HvacType[] values = OpsCenterConstants.HvacType.values();
		ArrayList<ConsertElectricHvacTypeView> list = new ArrayList<ConsertElectricHvacTypeView>(values.length);
		for (OpsCenterConstants.HvacType hvacType : values)
		{
			ConsertElectricHvacTypeView view = new ConsertElectricHvacTypeView();
			view.setType(ConsertElectricHvacType.fromValue(hvacType.getWsiValue()));
			view.setG(hvacType.hasG());
			view.setY(hvacType.hasY());
			view.setY2(hvacType.hasY2());
			view.setW(hvacType.hasW());
			view.setW2(hvacType.hasW2());
			view.setW3(hvacType.hasW3());
		}
		return list;
	}

	@Override
	public ConsertWorkflowTrackResponse workflowTrack(ConsertWorkflowTrackRequest request)
	{
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return workflowTrack(request, tenantId);
	}
	
	@Override
	public ConsertWorkflowTrackResponse workflowTrack(ConsertWorkflowTrackRequest request, Integer tenantId)
	{
		TenantContext.setCurrentTenant(tenantId);
		DatatypeFactory datatypeFactory = null;
		try
		{
			datatypeFactory = DatatypeFactory.newInstance();
		} 
		catch (DatatypeConfigurationException e)
		{
			// I don't think this error will ever happen
			e.printStackTrace();
			return null;
		}

		ConsertWorkflowTrackResponse response = new ConsertWorkflowTrackResponse();
		final List<ConsertWorkflow> consertWorkflows = response.getWorkflow();

		String billingAccountNumber = null;
		String premiseNumber = null;
		String meterLocationNumber = null;
		String utilityNumber = null;
		Integer accountId = null;

		ConsertCompoundAccountKey cak  = request.getCompoundAccountKey();
		if (cak != null)
		{
			billingAccountNumber = cak.getBillingAccountNumber();
			premiseNumber = cak.getPremiseNumber();
			meterLocationNumber = cak.getMeterLocationNumber();
			utilityNumber = cak.getUtilityNumber();
			final Long consertId = cak.getConsertId();
			accountId = (consertId == null) ? null : consertId.intValue();			
		}

		final String electricMeterNumber = request.getElectricMeterNumber();
		final String lcsSerialNumber = request.getLcsSerialNumber();
		final String standaloneGatewaySerialNumber = request.getStandaloneGatewaySerialNumber();
		final String wallplateSerialNumber = request.getWallplateSerialNumber();

		final Integer trackingId = request.getTrackingId();

		final ConsertPage page = request.getPage();
		final int skip = (page != null) ? page.getSkip() : 0;
		final int take = (page != null) ? page.getTake() : 20;

		/* As per standars, Max Parameters to be passed to method is 5.  */
		ValueBean valueBean = new ValueBean();
		Map<String, Object> valueMap = new HashMap<String, Object>();
		valueMap.put("accountId", accountId);
		valueMap.put("billingAccountNumber", billingAccountNumber);
		valueMap.put("premiseNumber", premiseNumber);
		valueMap.put("meterLocationNumber", meterLocationNumber);
		valueMap.put("utilityNumber", utilityNumber);
		valueMap.put("lcsSerialNumber", lcsSerialNumber);
		valueMap.put("wallplateSerialNumber", wallplateSerialNumber);
		valueMap.put("trackingId", trackingId);
		valueBean.setValueMap(valueMap);
		
		List<GatewayMessagingWorkflowPlusSerialNo> results = esiBeanFacade.getGatewayMessagingWorkflowPlusSerialNoBySearchCriteria(valueBean, skip, take);

		List<Integer> gatewayMessagingWorkflowIds = new ArrayList<Integer>();
		for (GatewayMessagingWorkflowPlusSerialNo gatewayMessagingWorkflowPlusSerialNo : results)
		{
			gatewayMessagingWorkflowIds.add(gatewayMessagingWorkflowPlusSerialNo.getGatewayMessagingWorkflowId());
		}

		if (gatewayMessagingWorkflowIds.isEmpty())
		{
			log.error("No gateway messaging workflows found for the criteria specified in request");
			return null;
		}

		// This is sorted by gatewayMessagingWorkflowId desc, step
		final List<GatewayMessagingWorkflowStep> gatewayMessagingWorkflowSteps = 
				esiBeanFacade.getGatewayMessagingWorkflowStepByGatewayMessagingWorkflowIds(gatewayMessagingWorkflowIds);

		// Using LinkedHashMap to maintain order
		Map<GatewayMessagingWorkflowPlusSerialNo, List<GatewayMessagingWorkflowStep>> stepsByWorkflow = new LinkedHashMap<GatewayMessagingWorkflowPlusSerialNo, List<GatewayMessagingWorkflowStep>>();
		for (GatewayMessagingWorkflowStep gatewayMessagingWorkflowStep : gatewayMessagingWorkflowSteps)
		{
			GatewayMessagingWorkflowPlusSerialNo workflow = gatewayMessagingWorkflowStep.getGatewayMessagingWorkflowPlusSerialNo();
			List<GatewayMessagingWorkflowStep> steps = stepsByWorkflow.get(workflow);
			if (steps == null)
			{
				steps = new ArrayList<GatewayMessagingWorkflowStep>();
				stepsByWorkflow.put(workflow, steps);
			}
			steps.add(gatewayMessagingWorkflowStep);			
		}

		final Set<GatewayMessagingWorkflowPlusSerialNo> workflows = stepsByWorkflow.keySet();
		for (GatewayMessagingWorkflowPlusSerialNo workflow : workflows)
		{			
			ConsertWorkflow consertWorkflow = new ConsertWorkflow();
			consertWorkflow.setCompoundAccountKey(
					WebServiceUtil.createConsertCompoundAccountKeyPlus(workflow.getAccountId()));
			consertWorkflow.setLcsSerialNumber(workflow.getLcsSerialNo());
			ConsertReply reply = new ConsertReply();
			reply.setAsyncPublishEndpointUrl(workflow.getReplyAddress());
			reply.setEmailAddress(workflow.getReplyEmail());
			consertWorkflow.setReply(reply);
			consertWorkflow.setWallplateSerialNumber(workflow.getTstatWallPlateSerialNo());
			consertWorkflow.setTrackingId(workflow.getGatewayMessagingWorkflowId());
			final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = workflow.getGatewayMessagingWorkflowOriginId();
			if (gatewayMessagingWorkflowOriginId != null)
			{
				consertWorkflow.setTrackingOrigin(gatewayMessagingWorkflowOriginId.getName());
			}			
			final GatewayMessagingWorkflowType gatewayMessagingWorkflowTypeId = workflow.getGatewayMessagingWorkflowTypeId();
			if (gatewayMessagingWorkflowTypeId != null)
			{
				consertWorkflow.setTrackingType(gatewayMessagingWorkflowTypeId.getName());
			}			
			
			try
			{
				if (CcUtil.toHexString(parseLong(defaultIfEmpty(workflow.getLcsSerialNo(), workflow.getTstatWallPlateSerialNo()), 16)) != null)
				{
					consertWorkflow.setThirdPartyDevice(false);
				}
			} catch (IllegalArgumentException e)
			{
				consertWorkflow.setThirdPartyDevice(true);
			}
			
			final List<ConsertWorkflowStep> consertWorkflowSteps = consertWorkflow.getConsertWorkflowStep();
			List<GatewayMessagingWorkflowStep> steps = stepsByWorkflow.get(workflow);
			ConsertWorkflowStatus consertWorkflowStatus = ConsertWorkflowStatus.IN_PROGRESS;
			for (GatewayMessagingWorkflowStep step : steps)
			{
				ConsertWorkflowStep consertStep = new ConsertWorkflowStep();
				final DateTime stopTime = step.getStopTime();
				if (stopTime != null)
				{
					consertStep.setEndTime(datatypeFactory.newXMLGregorianCalendar(stopTime.toGregorianCalendar()));
				}
				final GatewayMessagingWorkflowTypeStep gatewayMessagingWorkflowTypeStepId = step.getGatewayMessagingWorkflowTypeStepId();
				if (gatewayMessagingWorkflowTypeStepId != null)
				{
					consertStep.setStep(gatewayMessagingWorkflowTypeStepId.getStep());
					final MessagingOpcode messagingOpcodeId = gatewayMessagingWorkflowTypeStepId.getMessagingOpcodeId();
					if (messagingOpcodeId != null)
					{
						consertStep.setName(messagingOpcodeId.getName());
						consertStep.setIncoming(OpsCenterConstants.TRUE.equals(messagingOpcodeId.getIncomingFlag()));
						consertStep.setOutgoing(OpsCenterConstants.TRUE.equals(messagingOpcodeId.getOutgoingFlag()));
					}
				}

				final DateTime startTime = step.getStartTime();
				if (startTime != null)
				{
					consertStep.setStartTime(datatypeFactory.newXMLGregorianCalendar(startTime.toGregorianCalendar()));
				}

				final Integer statusCode = step.getStatusCode();
				if (statusCode == null)
				{
					consertStep.setStatus(ConsertWorkflowStatus.IN_PROGRESS);
				} 
				else 
				{
					final int status = statusCode.intValue();
					switch (status)
					{
						case OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_STATUS_OK:
							if (gatewayMessagingWorkflowTypeStepId != null && OpsCenterConstants.TRUE.equals(gatewayMessagingWorkflowTypeStepId.getStopFlag())
									|| (gatewayMessagingWorkflowTypeStepId.getStep() == 3 && step.getGatewayMessagingWorkflowId().getEsiTstatId() != null
											&& step.getGatewayMessagingWorkflowId().getEsiTstatId().getEsiDcId().getDeviceTypeId()
													.getDeviceTypeId() == OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT))
							{
								consertWorkflowStatus = ConsertWorkflowStatus.SUCCESS;
							}
							consertStep.setStatus(ConsertWorkflowStatus.SUCCESS);
							break;
						case OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_STATUS_FAIL:
							consertWorkflowStatus = ConsertWorkflowStatus.ERROR;
							consertStep.setStatus(ConsertWorkflowStatus.ERROR);
							break;
						case OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_STATUS_TIMEOUT:
							consertWorkflowStatus = ConsertWorkflowStatus.TIMEOUT;
							consertStep.setStatus(ConsertWorkflowStatus.TIMEOUT);
							break;
						default:
							consertWorkflowStatus = ConsertWorkflowStatus.UNKNOWN;
							consertStep.setStatus(ConsertWorkflowStatus.UNKNOWN);
							break;
					}
				}
				consertStep.setStatusText(step.getStatusText());
				consertWorkflowSteps.add(consertStep);				
			}
			consertWorkflow.setStatus(consertWorkflowStatus);
			consertWorkflows.add(consertWorkflow);
		}

		response.setResponseTime(datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar()));
		return response;
	}

	@Override
	public ConsertAccountProvisioningResponse forceTimeout(Integer trackingId, Integer tenantId) {
		log.debug("Entering forceTimeout for messaging workflow ID : " + trackingId + ".");
		TenantContext.setCurrentTenant(tenantId);
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		if (null != trackingId && 0 < trackingId)
		{
			
			try
			{
				GatewayMessagingWorkflow mgWorkflow = esiBeanFacade.findGatewayMessagingWorkflow(trackingId);
				if (null != mgWorkflow)
					for (GatewayMessagingWorkflowStep msgWorkflowStep : mgWorkflow.getGatewayMessagingWorkflowStepCollection())
					{
						if (null != msgWorkflowStep)
						{
							
							if (null == msgWorkflowStep.getStatusCode())
							{
								msgWorkflowStep.setStatusCode(OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_STATUS_TIMEOUT);
								msgWorkflowStep.setStatusText("Timeout");
								msgWorkflowStep.setStopTime(new DateTime());
								response.setStatus(ConsertAccountProvisioningResponseStatus.SUCCESS);
							}
							
						}
						
					}
				else
				{
					throw new Exception("Messaging workflow ID " + trackingId + " was not found." );
				}
			}
			catch (Exception e)
			{
				log.error("Unable to update messaging workflow ID : " + trackingId + " " + e.getMessage(), e);
				response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
				
				ConsertError consertCreateUpdateError = new ConsertError();
				consertCreateUpdateError.setErrorLocation("request");
				consertCreateUpdateError.setErrorLevel("ERROR");
				consertCreateUpdateError.setErrorMessage("Unable to update messaging workflow ID : " + trackingId);
				
				response.setError(consertCreateUpdateError);
			}
		}
		else
		{		
			log.error("Tracking Id value passed was invalid : " + trackingId);
			response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
			
			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage("Tracking Id value passed was invalid : " + trackingId);
			
			response.setError(consertCreateUpdateError);
		}
		
		try
		{
			DatatypeFactory datatypeFactory = DatatypeFactory.newInstance();
			response.setResponseTime(datatypeFactory
					.newXMLGregorianCalendar(new GregorianCalendar()));
		} catch (DatatypeConfigurationException e)
		{
			//Continue - This shouldn't happen but the response time is not so important as to stop the response.
		}
		log.debug("Exiting forceTimeout for messaging workflow ID : " + trackingId + ".");
		return response;
	}
	@Override
	public ConsertAccountProvisioningResponse restartWorkflow(Integer trackingId)
	{
		return restartWorkflow(trackingId, getUserName(), TenantContext.getCurrentTenant());
	}
	
	@Override
	public ConsertAccountProvisioningResponse restartWorkflow(Integer trackingId, String userName, Integer tenantId)
	{

		log.debug("Entering restartWorkflow for messaging workflow ID : " + trackingId + ".");
		TenantContext.setCurrentTenant(tenantId);
		ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
		if (null != trackingId && 0 < trackingId)
		{
			GatewayMessagingWorkflow msgWorkflow = esiBeanFacade.findGatewayMessagingWorkflow(trackingId);
			
			Esi esi = msgWorkflow.getEsiId();
			EsiTstat esiTstat = msgWorkflow.getEsiTstatId();
			EsiLcs esiLcs = msgWorkflow.getEsiLcsId();
					
			Exception exception = null;
			ConsertAccountVppMarriage accountVppMarriage = new ConsertAccountVppMarriage();
			DatatypeFactory datatypeFactory = null;
			
			
			try
			{
				datatypeFactory = DatatypeFactory.newInstance();
			} catch (DatatypeConfigurationException e)
			{
				// I don't think this error will ever happen
				e.printStackTrace();
				return null;
			}
			
			final int workflowTypeId = msgWorkflow.getGatewayMessagingWorkflowTypeId().getGatewayMessagingWorkflowTypeId();
			
			boolean isGridStream = true;
			
			 
			final int workflowOriginId;
			if (null != msgWorkflow.getGatewayMessagingWorkflowOriginId())
			{
				workflowOriginId = msgWorkflow.getGatewayMessagingWorkflowOriginId().getGatewayMessagingWorkflowOriginId();
			}
			else
			{
				workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_VPPACCOUNT_PROVISION;
			}
			String userCreated = userName;
					
			 
				
				if (null != esiTstat)
				{
					response = startWorkflow(
							accountVppMarriage.getReply(), esi, esiTstat, datatypeFactory,
							workflowTypeId, workflowOriginId, userCreated);
					log.debug("Exiting restartWorkflow for new messaging workflow ID : " + trackingId + ". New workflow ID : " + response.getTrackingId());
					return response;
				}
				
				if (null != esiLcs)
				{
					response = startWorkflow(
							accountVppMarriage.getReply(), esi, esiLcs, datatypeFactory,
							workflowTypeId, workflowOriginId, userCreated);
					log.debug("Exiting restartWorkflow for new messaging workflow ID : " + trackingId + ". New workflow ID : " + response.getTrackingId());
					return response;
				}
			 
			log.debug("Exiting restartWorkflow with null response for messaging workflow ID : " + trackingId + ".");
		}		
		else
		{		
			log.error("Tracking Id value passed was invalid : " + trackingId);
			response.setStatus(ConsertAccountProvisioningResponseStatus.ERROR);
			
			ConsertError consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage("Tracking Id value passed was invalid : " + trackingId);
			
			response.setError(consertCreateUpdateError);
		}
		return response;
	
	}
	private void validateProgramTemplate(Account account) throws Exception
	{
		if(account == null){
			throw new AccountNotFoundException(
					"Account not found (or) Null");
		}
		
		ProgramTemplate prgmTemplt = account.getProgramTemplateId();
		if(prgmTemplt == null) return;
		
		if(OpsCenterConstants.TRUE.equals(prgmTemplt.getDeleteFlag())){
			throw new ProgramTemplateException("Program Template is not Valid");
		}
		
	}
	
	@Override
    public List<ConsertAccountProvisioningResponse> accountChangeProgramTemplate(ConsertAccountProgramTemplateReMarriage request){
		Integer tenantId = TenantPropertyUtil.getTenantId(wsctx);
		return accountChangeProgramTemplate(request, tenantId);
	}
	
	@Override
    public List<ConsertAccountProvisioningResponse> accountChangeProgramTemplate(ConsertAccountProgramTemplateReMarriage request, Integer tenantId){
    	
		log.debug("[ENTER] accountChangeProgramTemplate");
		TenantContext.setCurrentTenant(tenantId);
		List<ConsertAccountProvisioningResponse> responseList = new ArrayList<ConsertAccountProvisioningResponse>();
		DatatypeFactory datatypeFactory = null;
		Exception exception = null;
		ConsertError consertCreateUpdateError = null;
		Esi esi = null;
		String userCreated = OpsCenterConstants.PROVISIONING_USER;

		try {
			datatypeFactory = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException e){
			e.printStackTrace();
			return null;
		}
		
		final String accountNumber = request.getAccountNumber();
		final ConsertCompoundAccountKey compoundAccountKey = request.getCompoundAccountKey();
		final ConsertProgramTemplate newProgramTemplate = request.getNewProgramTemplate();
		final ConsertProgramTemplate oldProgramTemplate = request.getOldProgramTemplate();

		try{
			esi = accountChangeProgramTemplatePersist(accountNumber, compoundAccountKey, newProgramTemplate, oldProgramTemplate);
		}
		catch (Exception e1){
			final String errorCode;
			final AbstractOpsCenterException abstractOpsCenterException;
			if (e1 instanceof AbstractOpsCenterException)
			{
				abstractOpsCenterException = (AbstractOpsCenterException) e1;
				errorCode = abstractOpsCenterException.getErrorCode();
			} else
			{
				errorCode = "UNKNOWN";
				abstractOpsCenterException = null;
			}
			log.error("Failed to Account_Change_ProgramTemplate", e1);

			consertCreateUpdateError = new ConsertError();
			consertCreateUpdateError.setErrorCode(errorCode);
			consertCreateUpdateError.setErrorLocation("request");
			consertCreateUpdateError.setErrorLevel("ERROR");
			consertCreateUpdateError.setErrorMessage(e1.getMessage());

			final List<ConsertErrorById> errorObjectDetails = consertCreateUpdateError.getErrorObjectDetails();
			addToErrorObjectDetails(errorObjectDetails, accountNumber, compoundAccountKey);
			if (abstractOpsCenterException != null){

				abstractOpsCenterException.setContext(getContext(errorObjectDetails));
			}
			exception = e1;

		}
		
		final int workflowTypeId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ID_GS_PROVISIONING;
		final int workflowOriginId = OpsCenterConstants.GATEWAY_MESSAGING_WORKFLOW_ORIGIN_ID_ACCOUNT_MOVEOUT_MOVEIN;

		if (exception == null && esi != null){
			

			final List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(esi.getEsiId());
			for (EsiTstat esiTstat : esiTstatList)
			{
				if (esiTstat.getEsiDcId().getDeviceTypeId().getDeviceTypeId()!= OpsCenterConstants.DEVICE_TYPE_ID_THIRD_PARTY_TSTAT)
				{
					TstatWallPlate tstatWallPlate = esiTstat.getTstatWallPlate();
					if (tstatWallPlate != null)
					{
						ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
						response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
						GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
						gatewayMessagingWorkflow
								.setGatewayMessagingWorkflowTypeId(esiBeanFacade
										.getRefGatewayMessagingWorkflowType(workflowTypeId));
						gatewayMessagingWorkflow
								.setGatewayMessagingWorkflowOriginId(esiBeanFacade
										.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
						gatewayMessagingWorkflow.setEsiId(esi);
						gatewayMessagingWorkflow.setEsiTstatId(esiTstat);
						gatewayMessagingWorkflow.setUsrCreated(userCreated);
						try
						{
							populateWorkflowWithReply(gatewayMessagingWorkflow, request.getReply());
						} catch (SchemaDataInvalidException exp)
						{
							exception = exp;
							exp.printStackTrace();
						}
						gatewayMessagingWorkflowBean.startWorkflow(
								gatewayMessagingWorkflow, exception);
						response.setTrackingId(gatewayMessagingWorkflow
								.getGatewayMessagingWorkflowId());
						response.setWallplateSerialNumber(tstatWallPlate.getGsSbrSerialNo());
						final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow
								.getGatewayMessagingWorkflowOriginId();
						if (gatewayMessagingWorkflowOriginId != null)
						{
							response.setTrackingType(gatewayMessagingWorkflowOriginId
									.getName());
						}
						response.setResponseTime(datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar()));
						responseList.add(response);
					}
				}
				
			}
			
			final List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(esi.getEsiId());
			for (EsiLcs esiLcs : esiLcsList)
			{
				Lcs lcsId = esiLcs.getLcsId();
				if (lcsId != null)
				{
					ConsertAccountProvisioningResponse response = new ConsertAccountProvisioningResponse();
					response.setStatus(ConsertAccountProvisioningResponseStatus.EXPECTS_ASYNC_REPLY);
	
					GatewayMessagingWorkflow gatewayMessagingWorkflow = new GatewayMessagingWorkflow();
					gatewayMessagingWorkflow.setUsrCreated(userCreated);
					gatewayMessagingWorkflow.setGatewayMessagingWorkflowTypeId(esiBeanFacade.getRefGatewayMessagingWorkflowType(workflowTypeId));
					gatewayMessagingWorkflow.setGatewayMessagingWorkflowOriginId(esiBeanFacade.getRefGatewayMessagingWorkflowOrigin(workflowOriginId));
					gatewayMessagingWorkflow.setEsiId(esi);
					gatewayMessagingWorkflow.setEsiLcsId(esiLcs);
					try
					{
						populateWorkflowWithReply(gatewayMessagingWorkflow, request.getReply());
					} catch (SchemaDataInvalidException exp)
					{
						exception = exp;
						exp.printStackTrace();
					}
					gatewayMessagingWorkflowBean.startWorkflow(gatewayMessagingWorkflow, exception);
					response.setTrackingId(gatewayMessagingWorkflow.getGatewayMessagingWorkflowId());
					final GatewayMessagingWorkflowOrigin gatewayMessagingWorkflowOriginId = gatewayMessagingWorkflow.getGatewayMessagingWorkflowOriginId();
					if (gatewayMessagingWorkflowOriginId != null)
					{
						response.setTrackingType(gatewayMessagingWorkflowOriginId.getName());
					}
					response.setLcsSerialNumber(lcsId.getGsSbrSerialNo());
					response.setResponseTime(datatypeFactory
							.newXMLGregorianCalendar(new GregorianCalendar()));
					responseList.add(response);
				}
			}
		}
		
    	return responseList;
    }
	
	
	//@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public Esi accountChangeProgramTemplatePersist(final String accountNumber, final ConsertCompoundAccountKey compoundAccountKey, 
					final ConsertProgramTemplate newProgramTemplate, final ConsertProgramTemplate oldProgramTemplate) throws Exception{
		log.debug("[ENTER] accountChangeProgramTemplatepPersist: accountNumber"+ accountNumber );
		Esi esi = null;
		try{
			
			/* Find Account */
			CompoundAccountKey compoundAccountKeyUtility = new CompoundAccountKey();
			final AccountPartsModel accountParts;
			try
			{
				accountParts = compoundAccountKeyUtility.getAccountParts();
			} catch (Exception e)
			{
				// Compound Account Key Error
				throw new CompoundAccountKeyException("Unexpected Error", e);
			}
			final Account account = getAccount(accountNumber, compoundAccountKey, accountParts);
			
			/* Validate Program Template*/
			if(newProgramTemplate == null || newProgramTemplate.getProgramTemplateId() == null) {
				throw new ProgramTemplateException("New Program Template Id can not be null");
			}
			final Integer newPrgTmplId = newProgramTemplate.getProgramTemplateId();
			final String  newPrgTmplName = newProgramTemplate.getProgramTemplateName();
			final ProgramTemplate template = programTemplateFacade.getActiveProgramTemplateById(newPrgTmplId);
			
			if(template == null){
				throw new ProgramTemplateException("Program Template not found " + newPrgTmplId + " - "+ newPrgTmplName);
			}
			
			if(account.getProgramTemplateId() == null || template.getProgramTemplateId() != account.getProgramTemplateId().getProgramTemplateId()){
				log.debug("Update Account with new Program Template");
				account.setProgramTemplateId(template);
				userAccountBeanFacade.updateAccount(account);
			}
			
			/* Find Account is provisioned (has devices)*/
			List<Esi> esiList = esiBeanFacade.getEsiByAccountId(account.getAccountId());
			esi = esiList == null || esiList.isEmpty() ? null : esiList.get(0);

			if (esi == null){
				//throw new EsiNotFoundException(DefaultResources.ACC_ERR_CODE_ESI_NOT_FOUND, "Account not provisioned " + account.getAccountNumber());
				log.debug("Account is not Provisioned");
				return null;
			}
			
			List<EsiTstat> esiTstatList = esiBeanFacade.getEsiTstatByEsiId(esi.getEsiId());
			List<EsiLcs> esiLcsList = esiBeanFacade.getEsiLcsByEsiId(esi.getEsiId());
			
			log.debug("No of Esi Tstat " + esiTstatList.size());
			log.debug("No of Esi Lcs " + esiLcsList.size());
			
			if (esiList.size() == 0 && esiTstatList.size() == 0)
			{
				log.debug(" No devices found for this Account. Program Template is not applied to Devices ");
				return null;
			}
			
			log.debug("Applying program template " + template.getProgramTemplateId() + " - " + template.getName() + " to an Account "+ account.getAccountNumber());
			
			String userCreated = OpsCenterConstants.PROVISIONING_USER;
			DateTime now = new DateTime();
			
			
			/* Delete all current programs */			
			UserProgramModel usrPrgModel = new UserProgramModel();
			usrPrgModel.setAccountId(account.getAccountId());
			usrPrgModel.setUserModified(userCreated);
			
			try{
				userProgramBean.deleteProgramsAndTP(usrPrgModel);
			}catch (Exception e){
				log.info("No programs exists for this account "+ account.getAccountNumber());
			}
			
			/* Create Programs from ProgramTemplate */
			assignProgramTemplateProgramsIfNecessary(account, userCreated, now);
			
		}catch (Exception e){
			context.setRollbackOnly();
			throw e;
		}
		
		return esi;
	}

    @Override
	public ConsertDeviceSearchResults unprovisionedDeviceSearch(ConsertUnprovisionedDeviceSearchCriteria request) {
    	
    	TenantPropertyUtil.getTenantId(wsctx);
    	
		ConsertDeviceSearchResults results = new ConsertDeviceSearchResults();
		final int lastMinutes = (request != null && request.getSearchWindowInMinutes() != null)
				? request.getSearchWindowInMinutes()
				: 20;
		
		if (lastMinutes > MAX_UNPROVISIONED_DEVICE_SEARCH_MINUTES || lastMinutes <= 0) {
			ConsertError error = new ConsertError();
			error.setErrorCode(SCH_ERR_CODE_DATA_INVALID);
			error.setErrorLocation("request");
			error.setErrorLevel("ERROR");
			error.setErrorMessage("Data validation error: searchWindowInMinutes = "+lastMinutes+
					", must be > 0 and <= " + MAX_UNPROVISIONED_DEVICE_SEARCH_MINUTES);
			results.setError(error);
			return results;
		}
		List<Lcs> lcsBunch = deviceBeanFacade.getLcsByUnprovisionedAndLastReadAfterMinutesAgo(lastMinutes);
		for (Lcs lcs : lcsBunch) {
			results.getLcs().add(WebServiceUtil.createView(lcs));
		}
		List<TstatWallPlate> wallplateBunnch = deviceBeanFacade.getTstatWallPlateByUnprovisionedAndLastReadAfterMinutesAgo(lastMinutes);
		for (TstatWallPlate tstatWallPlate : wallplateBunnch) {
			results.getWallplate().add(WebServiceUtil.createView(tstatWallPlate));
		}

		return results;
	}

	@Override
	public Esi electricMeterProvisionPersist(String accountNumber,
			ConsertCompoundAccountKey compoundAccountKey,
			String electricMeterNumber) throws AbstractOpsCenterException {
		// TODO Auto-generated method stub
		return null;
	}
	
}